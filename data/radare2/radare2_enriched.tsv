q	a	thinking	breakdown
I think there's a jump table in this function. How can I find its location?	CCf~cases	"
When looking for jump tables in a function, we need to analyze the comments that r2 has added during analysis. Jump tables are usually commented with ""switch"" or ""case"" statements. The most direct way to find these is by looking at the function's comments that contain the word ""cases"", which would indicate switch-case constructs.

The command needs to list comments (CC) in the current function (f) and then filter for any mentions of cases. This would help locate the jump table's position in the code.
"	"
[
  {
    ""part"": ""CC"", 
    ""category"": ""comments"",
    ""desc"": ""list comments - we need to see what r2 has identified""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""restrict to current function only since we're looking for a jump table in this function""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output""
  },
  {
    ""part"": ""<cases>"",
    ""category"": ""filter_term"",
    ""desc"": ""search term to find switch-case related comments""
  }
]
"
How to determine the switch table destinations?	afb.	"
When analyzing a binary, switch tables are important control flow structures. To understand where each case of a switch statement jumps to, we need to analyze the basic blocks of the current function. The command should show us the basic blocks and their relationships, which would include the switch table destinations.

Looking at the function analysis commands (af), we need something that deals with basic blocks (b), so afb seems logical. The period modifier will show us the information for the current location, which is useful when we're already positioned at the switch statement we want to analyze.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis command is needed since we're examining program structure""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""we want to analyze at the function level since switch statements are function components""
  },
  {
    ""part"": ""b"",
    ""category"": ""basic block"",
    ""desc"": ""basic blocks will show us the different paths of the switch statement""
  },
  {
    ""part"": ""."",
    ""category"": ""current"",
    ""desc"": ""focus on the current location where we're analyzing the switch statement""
  }
]
"
How do I find out what type of file this is? Like if it's ELF or PE or something?	i~^format[1]	"
When we need to identify a file format in radare2, we need to use the binary information commands. The most basic one is 'i' which shows various information about the loaded file. However, we want to specifically find the format type, so we need to filter the output. The '~' grep operator can help us find just the format line, and by using '^format' we ensure we match from the start of the line. The [1] selects just the second column which contains the actual format type.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""info"",
    ""desc"": ""shows information about the loaded binary file""
  },
  {
    ""part"": ""~"",
    ""category"": ""filter"",
    ""desc"": ""grep operator to filter output""
  },
  {
    ""part"": ""^format"",
    ""category"": ""regex"",
    ""desc"": ""matches 'format' at the start of a line""
  },
  {
    ""part"": ""[1]"",
    ""category"": ""column_selector"",
    ""desc"": ""selects the second column which contains the format type""
  }
]
"
I want to see all the loops in a function. Is there a way to highlight or find them?	/abf	"
When looking for loops in a function, we need to analyze the control flow, specifically looking for backward jumps since they're typically what creates loops. The question asks about finding loops, so we need a command that can analyze basic blocks and find these backward-flowing patterns.

Looking through the help, we can see this falls under the analysis category ('a'), then basic blocks ('b'), and there's a specific flag for finding loops ('f'). This makes perfect sense because loops are essentially backward jumps in the control flow.
"	"
[
    {
        ""part"": ""/"",
        ""category"": ""search"",
        ""desc"": ""indicates we're searching for something specific""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""we're doing analysis-related operations""
    },
    {
        ""part"": ""b"",
        ""category"": ""basic blocks"",
        ""desc"": ""we're working with basic blocks which are fundamental for control flow""
    },
    {
        ""part"": ""f"",
        ""category"": ""find"",
        ""desc"": ""specifically looking for backward jumps which indicate loops""
    }
]
"
I want to find places where the program might be using command line arguments. Where would I look?	axt@@=reloc.optind reloc.optarg sym.imp.getopt_long sym.imp.getopt	"
To find command line argument usage, we need to look for references to common argument parsing functions and variables. The question provides the key symbols we want to examine: optind, optarg, getopt_long and getopt - these are the standard C functions and variables used for parsing command line arguments.

The command needs to:
1. Find cross-references (axt) to these symbols
2. Do this for multiple targets (@@=)
3. Look at both relocations (reloc.) and imported symbols (sym.imp.)

This command will show all code locations that reference these argument-handling functions and variables, effectively mapping out where command line processing happens.
"	"
[
  {
    ""part"": ""ax"", 
    ""category"": ""xrefs"",
    ""desc"": ""analyze cross-references to find what uses these symbols""
  },
  {
    ""part"": ""t"",
    ""category"": ""type"",
    ""desc"": ""specifically find code that references these symbols ('to' these targets)""
  },
  {
    ""part"": ""@@="",
    ""category"": ""iterator"",
    ""desc"": ""run the previous command for each of the following items""
  },
  {
    ""part"": ""<reloc.optind reloc.optarg sym.imp.getopt_long sym.imp.getopt>"",
    ""category"": ""arguments"",
    ""desc"": ""the list of argument-handling symbols to search for references to""
  }
]
"
How do I see what's in the data section? I want to look at initialized variables.	pxr $SS @@= `iS,name/str/data,vaddr/cols,:tsv~0x`	"
To find initialized variables in the data section, we need to:
1. First find where the data section is located using the section info command (iS)
2. Then we want to examine the data at that location with references (pxr)
3. We need to do this for the full size of the section ($SS)
4. The command uses a table query to get the data section's virtual address
5. The command combines these by using @@= to iterate over the results

This is a sophisticated way to look at the data section because it:
- Automatically finds the right section
- Shows references to the data
- Covers the whole section
- Works even if the section address changes
"	"
[
    {""part"": ""p"", ""category"": ""print"", ""desc"": ""print command to show data""},
    {""part"": ""x"", ""category"": ""hex"", ""desc"": ""in hexadecimal format""},
    {""part"": ""r"", ""category"": ""references"", ""desc"": ""show references to the data""},
    {""part"": ""<$SS>"", ""category"": ""variable"", ""desc"": ""section size variable""},
    {""part"": ""@@="", ""category"": ""iterator"", ""desc"": ""iterate over the following command output""},
    {""part"": ""`iS,name/str/data,vaddr/cols,:tsv~0x`"", ""category"": ""query"", ""desc"": ""get virtual address of data section using table query""}
]
"
I'm trying to find where malloc is called. How can I see references to memory allocation?	axt @sym.malloc	"
When looking for memory allocation calls, we need to find cross-references (xrefs) to the malloc function. The most direct way is to look for references to the malloc symbol. We need to:
1. Find all places that reference malloc
2. Show those references in a readable format

The command needs to:
- Find cross references (x)
- To a specific symbol (sym.malloc)
- Using the @ operator to specify where to look
"	"
[
    {
        ""part"": ""ax"", 
        ""category"": ""analysis"",
        ""desc"": ""find cross-references""
    },
    {
        ""part"": ""t"",
        ""category"": ""type"",
        ""desc"": ""show references to this specific address""
    },
    {
        ""part"": ""@"",
        ""category"": ""operator"",
        ""desc"": ""specify where to look""
    },
    {
        ""part"": ""<sym.malloc>"",
        ""category"": ""argument"",
        ""desc"": ""the symbol name to find references to""
    }
]
"
How do I check if this binary is stripped? I want to see if it has debug symbols.	i~stripped	"
When dealing with binaries, one of the first things we want to know is whether debug symbols are present, as this affects our analysis strategy. The binary header contains this information, and we need to:
1. Get information about the binary ('i' command for info)
2. Filter through that information to find the stripped status ('~' grep)
So we need to look at binary information and filter for the word ""stripped"" to quickly see this status.
"	"
[
    {
        ""part"": ""i"",
        ""category"": ""information"",
        ""desc"": ""get binary information - this shows details about the loaded file including headers, sections, etc""
    },
    {
        ""part"": ""~"",
        ""category"": ""grep"",
        ""desc"": ""filter the output using radare's built-in grep""
    },
    {
        ""part"": ""<stripped>"",
        ""category"": ""argument"",
        ""desc"": ""the string we're searching for in the binary information output""
    }
]
"
I want to see all the network-related functions this program might use. How do I search for those?	afl~socket,connect,bind	"
When looking for network-related functions, we need to list all functions and filter for common networking API calls. The key functions in networking are typically socket(), connect(), and bind(), so those are good search terms.

We need to:
1. List all functions (afl)
2. Filter that list for multiple networking-related terms
3. The terms should be socket, connect, and bind as these are the most common networking function names

This leads to using afl to list functions and the ~ grep operator with multiple terms separated by commas.
"	"
[
    {
        ""part"": ""a"", 
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are needed to work with functions""
    },
    {
        ""part"": ""f"",
        ""category"": ""functions"", 
        ""desc"": ""list functions - we want to see function names""
    },
    {
        ""part"": ""l"",
        ""category"": ""listing"",
        ""desc"": ""long format listing to show full function details""
    },
    {
        ""part"": ""~"",
        ""category"": ""grep"",
        ""desc"": ""filter the output""
    },
    {
        ""part"": ""<socket,connect,bind>"",
        ""category"": ""search terms"",
        ""desc"": ""common networking function names to search for, comma-separated for multiple terms""
    }
]
"
How can I find all the comparison instructions in a function? Like cmp or test	/at cmp @e:search.in=anal.fcn	"
We need to search for specific types of instructions within the current function. The key components we need are:
1. Search functionality (/)
2. Assembly instruction type search (at)
3. Scope limitation to current function (search.in=anal.fcn)

The /at command is perfect for this as it's specifically designed to search for instructions by type. The 'cmp' parameter tells it to look for comparison instructions. The @e:search.in=anal.fcn part restricts the search to only the current function's analysis.
"	"
[
  {""part"": ""/"", ""category"": ""search"", ""desc"": ""initiate a search command""},
  {""part"": ""at"", ""category"": ""assembly"", ""desc"": ""search for instructions by their type""},
  {""part"": ""<cmp>"", ""category"": ""argument"", ""desc"": ""specify we want comparison instructions""},
  {""part"": ""@"", ""category"": ""temporary_config"", ""desc"": ""introduce a temporary configuration change""},
  {""part"": ""e:search.in=anal.fcn"", ""category"": ""eval"", ""desc"": ""limit search scope to current function""}
]
"
I want to find all functions that are bigger than 100 bytes. How can I do that?	afl,size/gt/100,name/cols,:quiet	"
To find functions by size, we need to first list all functions, then filter them by size. The command needs to:
1. List all functions (we need their sizes)
2. Filter them to show only those bigger than 100 bytes
3. Show just the names to keep it clean
4. Make it quiet to avoid extra noise

This leads to using 'afl' (analyze function list) with table filtering (,) to check sizes and get names, with :quiet to clean up the output.
"	"
[
  {
    ""part"": ""afl"",
    ""category"": ""analysis"",
    ""desc"": ""List all functions - gives us the base data to filter from""
  },
  {
    ""part"": "","",
    ""category"": ""table"",
    ""desc"": ""Switch to table query mode for filtering columns""
  },
  {
    ""part"": ""size/gt/100"",
    ""category"": ""filter"",
    ""desc"": ""Filter where size column is greater than 100""
  },
  {
    ""part"": "","",
    ""category"": ""separator"",
    ""desc"": ""Chain another table operation""
  },
  {
    ""part"": ""name/cols"",
    ""category"": ""columns"",
    ""desc"": ""Select only the name column from results""
  },
  {
    ""part"": "":quiet"",
    ""category"": ""output"",
    ""desc"": ""Remove headers and extra formatting from output""
  }
]
"
How do I see what libraries this program needs to run? Like its dependencies?	il	"
When we want to see library dependencies of a binary, we're looking for its dynamic linking information. In reverse engineering terms, these are the libraries that get loaded when the program starts. The most direct way to see this would be to list the libraries, which is what we need to do here. Looking at the commands, 'i' is for information about the binary, and 'l' specifically lists libraries.
"	"
[
    {
        ""part"": ""i"",
        ""category"": ""information"",
        ""desc"": ""information about the binary is needed, so 'i' is the base command for binary info""
    },
    {
        ""part"": ""l"",
        ""category"": ""libraries"",
        ""desc"": ""specifically lists the linked libraries (dependencies) of the program""
    }
]
"
How can I see if there are any hidden or suspicious strings in the binary?	izz	"
When looking for hidden strings in a binary, we want to search through the entire file, not just the data sections where strings are typically stored. Regular string search (iz) only looks in data sections, but for malware analysis or forensics we need to scan everything. The command should be related to string searching but more thorough.

Looking at the string-related commands, I see 'izz' which is described as ""search for Strings in the whole binary"". This is perfect because it will find strings anywhere in the file, even if they're hidden in unusual sections or encoded.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""info"",
    ""desc"": ""information commands are used to analyze file contents""
  },
  {
    ""part"": ""z"",
    ""category"": ""strings"",
    ""desc"": ""specifies we want to work with strings in the binary""
  },
  {
    ""part"": ""z"",
    ""category"": ""depth"",
    ""desc"": ""second z indicates we want to search deeply through the whole binary, not just data sections""
  }
]
"
How do I check what CPU architecture this binary is compiled for?	i~arch,bits	"
When examining a binary, one of the first things we need to know is its architecture and bit width. This information is stored in the binary's headers. In radare2, the 'i' command shows binary information. However, there's usually a lot of information, so we need to filter it down to just show architecture and bits. The tilde (~) operator with a comma lets us search for multiple terms at once.
"	"
[
    {
        ""part"": ""i"",
        ""category"": ""info"",
        ""desc"": ""display information about the loaded binary""
    },
    {
        ""part"": ""~"",
        ""category"": ""grep"",
        ""desc"": ""filter the output using grep-like functionality""
    },
    {
        ""part"": ""<arch,bits>"",
        ""category"": ""search terms"",
        ""desc"": ""search for lines containing either 'arch' or 'bits' in the output""
    }
]
"
I want to find all the places where a global variable is being used. How do I do that?	axt@address	"
To find all references to a global variable, we need to use cross-reference analysis. Since we're looking for where a variable is being used, we need to find all the places that reference a specific address. This is a common reverse engineering task when tracking data flow.

The command should show us every place in the code that reads from, writes to, or otherwise references our variable's address. We need a command that shows cross-references (x-refs) to a specific target address.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used for extracting program information""
    },
    {
        ""part"": ""x"",
        ""category"": ""xrefs"",
        ""desc"": ""cross-references subcommand - shows relationships between code/data""
    },
    {
        ""part"": ""t"",
        ""category"": ""type"",
        ""desc"": ""specifies we want to find references TO this address""
    },
    {
        ""part"": ""@<address>"",
        ""category"": ""address"",
        ""desc"": ""specifies the target address of the global variable we want to find references to""
    }
]
"
I want to look at the biggest functions in the program	afl,size/sort/dec,./head/10,addr/cols/size/name	"
You want to find the largest functions in the program, which requires:
1. Getting a list of all functions (afl)
2. Sorting them by size in descending order
3. Taking only the top 10
4. Showing specific columns (address, size, name) 

This is a perfect use case for the table query syntax in radare2 (,) which allows filtering and formatting data in tables. The command uses afl to list functions, then chains several table operations with commas to process and display the data exactly as needed.
"	"
[
  {
    ""part"": ""afl"",
    ""category"": ""analysis"",
    ""desc"": ""list all functions - gives us the base data to work with""
  },
  {
    ""part"": "","",
    ""category"": ""table"",
    ""desc"": ""switch to table processing mode for the afl output""
  },
  {
    ""part"": ""size/sort/dec"",
    ""category"": ""sort"",
    ""desc"": ""sort the functions by their size column in descending order""
  },
  {
    ""part"": "","",
    ""category"": ""separator"",
    ""desc"": ""chain another table operation""
  },
  {
    ""part"": ""./head/10"",
    ""category"": ""limit"",
    ""desc"": ""take only the first 10 results""
  },
  {
    ""part"": "","",
    ""category"": ""separator"", 
    ""desc"": ""chain final table operation""
  },
  {
    ""part"": ""addr/cols/size/name"",
    ""category"": ""columns"",
    ""desc"": ""show only the address, size and name columns in that order""
  }
]
"
How do I sort functions by size?	aflss	"
Looking at the function listing commands, we want to list functions but with a specific sorting. The question asks for sorting by size, so we need the function list command (afl) with some sort of size sorting modifier. Looking at the help, we can see that 'afls' allows sorting functions, and adding another 's' specifically sorts by size.

The command builds up logically - first we need analysis of functions (af), then we need to list them (l), then we need to sort them (s), and finally we want to sort by size (s again).
"	"
[
    {""part"": ""a"", ""category"": ""analysis"", ""desc"": ""analysis command, since we're working with analyzed functions""},
    {""part"": ""f"", ""category"": ""functions"", ""desc"": ""specifies we're working with functions""},
    {""part"": ""l"", ""category"": ""listing"", ""desc"": ""list the functions""},
    {""part"": ""s"", ""category"": ""sort"", ""desc"": ""enables sorting mode for the function list""},
    {""part"": ""s"", ""category"": ""size"", ""desc"": ""specifies size as the sorting criteria""}
]
"
I want to see what math operations a function is doing. How do I find arithmetic instructions?	/at add,sub,mul,div@e:search.in=anal.fcn	"
To find arithmetic operations in a function, we need to search through the analyzed function's instructions looking specifically for arithmetic operations. The question is asking about math operations, which maps directly to assembly instructions like add, sub, mul, and div.

The /at command is perfect for this because it searches for specific instruction types. By providing the list of arithmetic operations and limiting the search scope to the current function with @e:search.in=anal.fcn, we'll get exactly what we want.
"	"
[
    {
        ""part"": ""/"",
        ""category"": ""search"",
        ""desc"": ""Search command - we're looking for specific things in the code""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""Search in analyzed code rather than raw bytes""
    },
    {
        ""part"": ""t"",
        ""category"": ""type"",
        ""desc"": ""Search for specific types of instructions""
    },
    {
        ""part"": ""<add,sub,mul,div>"",
        ""category"": ""arguments"",
        ""desc"": ""The arithmetic operations we want to find""
    },
    {
        ""part"": ""@e:search.in=anal.fcn"",
        ""category"": ""scope"",
        ""desc"": ""Limit search to current function only""
    }
]
"
I want to see what binary operations a function is doing. How do I find logic binary instructions?	/at shl,shr,rol,ror,sal,sar,xor@e:search.in=anal.fcn	"
To find binary operations in a function, we need to search through the analyzed function's instructions. We want to specifically look for bit manipulation instructions like shifts and rotates.

The command needs to:
1. Search (/command) for specific instruction types
2. Look for assembly instructions (at subcommand)
3. List multiple operation types (comma separated)
4. Limit the search to the current function (using @e:search.in=)

The /at command is perfect because it searches for instruction types within the disassembly, and we can provide multiple types separated by commas.
"	"
[
    {
        ""part"": ""/"",
        ""category"": ""search"",
        ""desc"": ""initiate a search command""
    },
    {
        ""part"": ""at"",
        ""category"": ""analysis"",
        ""desc"": ""search for specific instruction types in assembly""
    },
    {
        ""part"": ""<shl,shr,rol,ror,sal,sar,xor>"",
        ""category"": ""arguments"",
        ""desc"": ""list of binary operations to search for""
    },
    {
        ""part"": ""@"",
        ""category"": ""specifier"",
        ""desc"": ""indicates we're about to specify where to search""
    },
    {
        ""part"": ""e:search.in=anal.fcn"",
        ""category"": ""configuration"",
        ""desc"": ""limit search to current analyzed function""
    }
]
"
I want to see if there are any URLs addresses hidden in the binary. How do I search?	iz~http://,https://,www	"
To find URLs in a binary, we need to:
1. First, search through strings in the data sections - that's where URLs are typically stored
2. Then filter those results to look specifically for URLs
3. The URLs usually start with http:// or https://, and can also contain www

The command needs to start with 'iz' to list strings, then use grep (~) to filter for these common URL patterns. Multiple patterns can be separated by commas in the grep.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""info"",
    ""desc"": ""information commands to analyze binary contents""
  },
  {
    ""part"": ""z"",
    ""category"": ""strings"",
    ""desc"": ""list strings in data sections""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output""
  },
  {
    ""part"": ""<http://,https://,www>"",
    ""category"": ""patterns"",
    ""desc"": ""common URL patterns to search for, separated by commas""
  }
]
"
How can I find all the switch statements in a function?	pdr~switch	"
To find switch statements in a function, we need to:
1. First disassemble the function
2. But we want to do it recursively to see all possible paths
3. Then filter the output to only show lines containing ""switch""

This leads to using pdr (print disassemble recursive) which will show all possible execution paths in the function, followed by the grep operator (~) to filter for ""switch"" keywords.
"	"
[
    {
        ""part"": ""p"",
        ""category"": ""print"",
        ""desc"": ""print command is the base for displaying data""
    },
    {
        ""cmd"": ""d"",
        ""category"": ""disassembly"",
        ""desc"": ""specifies we want to disassemble code""
    },
    {
        ""cmd"": ""r"",
        ""category"": ""recursive"",
        ""desc"": ""tells disassembler to follow all possible execution paths recursively""
    },
    {
        ""cmd"": ""~"",
        ""category"": ""grep"",
        ""desc"": ""filter operator to search through the output""
    },
    {
        ""cmd"": ""<switch>"",
        ""category"": ""filter_term"",
        ""desc"": ""the keyword we're searching for in the disassembly""
    }
]
"
I want to see if this program creates any child processes. How do I find fork calls?	axt @sym.fork	"
To find fork calls in a program, we need to find cross-references (xrefs) to the fork system call. The fork() function is typically a symbol in the binary, so we want to find all code locations that reference this symbol.

The most direct way to do this is to find all cross-references to the fork symbol. We need a command that:
1. Analyzes cross-references (ax)
2. Specifically looks at cross-references TO (t) a specific symbol
3. Points to the fork symbol (@sym.fork)
"	"
[
    {
        ""part"": ""ax"", 
        ""category"": ""analysis"",
        ""desc"": ""cross-references command to find code/data references""
    },
    {
        ""part"": ""t"",
        ""category"": ""direction"",
        ""desc"": ""specifies we want references TO the target (not from)""
    },
    {
        ""part"": ""@"",
        ""category"": ""addressing"",
        ""desc"": ""specifies we want to look at a specific address/symbol""
    },
    {
        ""part"": ""<sym.fork>"",
        ""category"": ""symbol"",
        ""desc"": ""the symbol name we're looking for references to""
    }
]
"
I want to see all the places where data is being copied in memory. How do I find memcpy calls?	axt @sym.memcpy	"
To find all places where memcpy is being called, we need to look for cross-references (xrefs) to the memcpy symbol. This is a common analysis task when tracking data movement in a binary.

The process is:
1. First, we need to reference the memcpy symbol (@sym.memcpy)
2. Then we want to find all cross-references to it (axt)
3. This will show us every location in the code that calls memcpy

The command `axt` (analyze xrefs to) is perfect for this as it shows all code locations that reference a given address or symbol.
"	"
[
  {
    ""part"": ""ax"",
    ""category"": ""analysis"",
    ""desc"": ""analyze cross references""
  },
  {
    ""part"": ""t"",
    ""category"": ""type"",
    ""desc"": ""specifically find references 'to' the target""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""specify the target address/symbol to analyze""
  },
  {
    ""part"": ""<sym.memcpy>"",
    ""category"": ""symbol"",
    ""desc"": ""the memcpy function symbol to find references to""
  }
]
"
I want to see what happens right after the program starts. Where's the initialization code?	pdf@entry0	"
When a program starts, the first code that runs is usually at the entry point. This is where initialization, runtime setup, and the path to main() begins. To see this code, we need to:
1. Print/display the code
2. In a disassembly format
3. For a function
4. Specifically at the entry point (entry0)

The command needs to show us the full function disassembly starting at the program's entry point, which is exactly what we want to see for initialization code.
"	"
[
    {""part"": ""p"", ""category"": ""print"", ""desc"": ""We want to display/print something""},
    {""part"": ""d"", ""category"": ""disassembly"", ""desc"": ""We want to see the code disassembled""},
    {""part"": ""f"", ""category"": ""function"", ""desc"": ""We want to see the complete function""},
    {""part"": ""@entry0"", ""category"": ""address"", ""desc"": ""At the program's entry point, where execution begins""}
]
"
How do I find all the functions that use floating-point math?	afn.@@=`/af fpu~[0]`	"
To find functions using floating-point math, we need to:
1. First search for FPU (Floating Point Unit) instructions
2. Get their addresses
3. Then find which functions contain those addresses
4. Finally rename or list those functions

The command builds this pipeline: It searches for FPU instructions (/af fpu), gets the addresses (~[0]), and then uses those addresses as input for a function command (afn) using the foreach iterator (@@=).
"	"
[
  {""part"": ""afn"", ""category"": ""analysis_function"", ""desc"": ""function rename/list command""},
  {""part"": ""."", ""category"": ""current"", ""desc"": ""operate on current function""},
  {""part"": ""@@="", ""category"": ""iterator"", ""desc"": ""foreach iterator that takes a list of offsets""},
  {""part"": ""`"", ""category"": ""command_substitution"", ""desc"": ""backtick to execute inner command first""},
  {""part"": ""/af"", ""category"": ""search"", ""desc"": ""search for AMS instructions""},
  {""part"": ""<fpu>"", ""category"": ""argument"", ""desc"": ""specify floating point instructions""},
  {""part"": ""~"", ""category"": ""grep"", ""desc"": ""filter output""},
  {""part"": ""[0]"", ""category"": ""column_selector"", ""desc"": ""select first column (addresses)""}
]
"
I want to analyze all functions in the binary	aaa	"
When you want to analyze a binary, you need to understand its functions, references, variables and more. The most thorough way to do this in r2 is through automated analysis. Looking at the options, 'aaa' stands out as it's specifically designed to ""analyze all"" - it's the most common and comprehensive analysis command that performs deeper analysis of the whole program. This is typically the first command you run after loading a binary to get a good understanding of its structure.

The command is actually doing multiple steps behind the scenes - it runs the equivalent of 'af' (analyze functions) on all detected function locations, analyzes arguments (afva), and performs many other analysis tasks to give you a complete picture of the binary.
"	"
[
  {
    ""part"": ""a"", 
    ""category"": ""analysis"",
    ""desc"": ""Analysis command - we need to analyze something""
  },
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""Second 'a' indicates we want to perform deeper analysis""
  },
  {
    ""part"": ""a"",
    ""category"": ""analysis"", 
    ""desc"": ""Third 'a' makes it the most comprehensive analysis command - analyze all""
  }
]
"
How do I seek to the entry point of the binary?	s entry0	"
When working with binaries, one of the most common needs is to navigate to the entry point - the first instruction that gets executed when the program starts. This is typically labeled as 'entry0' in radare2. Since we need to change our current position in the binary, we need a seek command, which in radare2 is done with 's'. The entry point is a known symbol in radare2 called 'entry0', so we can directly seek to it.
"	"
[
    {
        ""part"": ""s"",
        ""category"": ""seek"",
        ""desc"": ""seek command - used to change current position in the binary""
    },
    {
        ""part"": ""<entry0>"",
        ""category"": ""symbol"",
        ""desc"": ""standard name for program entry point in radare2""
    }
]
"
Disassemble 20 instructions starting from the current address	pd 20	"
When we need to disassemble code, we need a command that can show us the assembly instructions. Looking at the command set, we know we need to print something ('p' commands), and specifically we want to disassemble ('d' for disassembly). Since we want a specific number of instructions (20), we'll need to provide that as an argument. The command builds naturally as 'pd' followed by the number of instructions we want to see.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""we start with print because we want to output something""
  },
  {
    ""part"": ""d"",
    ""category"": ""disassembly"",
    ""desc"": ""specifies we want to disassemble rather than print raw bytes or other formats""
  },
  {
    ""part"": ""<20>"",
    ""category"": ""argument"",
    ""desc"": ""specifies the number of instructions to disassemble""
  }
]
"
How do I list all functions found in the analysis?	afl	"
When analyzing a binary, one of the most common needs is to see what functions were discovered during analysis. Since we're asking about functions, and we want a list of them, we need a command that combines analysis ('a') with function ('f') operations and specifically listing ('l') them. The command needs to be quick and provide a comprehensive overview of all functions found during analysis.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis command, since we're working with analyzed data""
    },
    {
        ""part"": ""f"",
        ""category"": ""functions"",
        ""desc"": ""specifies we want to work with functions""
    },
    {
        ""part"": ""l"",
        ""category"": ""listing"",
        ""desc"": ""indicates we want to list/enumerate the functions""
    }
]
"
I want to see the disassembly of the `main` function	pdf @ main	"
You want to see the disassembly of a specific function - in this case 'main'. This requires:
1. A command to print/show something
2. That something needs to be disassembly
3. It needs to be function-specific
4. We need to specify which function to look at

Looking at the commands, 'pdf' is perfect for this - it's specifically designed to ""disassemble function"". The '@ main' syntax is used to specify we want to look at the 'main' function rather than whatever function contains the current seek position.
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""print command - the base for showing/displaying data""
  },
  {
    ""part"": ""d"",
    ""category"": ""disassembly"", 
    ""desc"": ""specifies we want to see disassembly output""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""indicates we want to see a complete function rather than just N instructions""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""specifies where to apply the command""
  },
  {
    ""part"": ""<main>"",
    ""category"": ""argument"",
    ""desc"": ""the name of the function we want to disassemble""
  }
]
"
How can I print the contents at the address stored in the `esp` register?	px 200 @r:esp	"
To print contents at an address stored in a register, we need to:
1. First, understand we want to print/examine memory
2. The address we want to examine is stored in the esp register
3. We need to tell r2 to use the value IN the register as the address
4. We want to see enough data to be useful - 200 bytes seems reasonable

The command needs to:
- Use px for hexdump printing
- Specify length (200)
- Use @r: syntax to dereference register value
- Name the register (esp)
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""Print command - we want to examine memory contents""
  },
  {
    ""part"": ""x"",
    ""category"": ""format"", 
    ""desc"": ""Hexdump format - shows both hex and ASCII representation""
  },
  {
    ""part"": ""<200>"",
    ""category"": ""argument"",
    ""desc"": ""Number of bytes to print - reasonable amount to see stack contents""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""At address operator - specifies where to print from""
  },
  {
    ""part"": ""r:"",
    ""category"": ""register"",
    ""desc"": ""Register prefix - tells r2 to use the register's value as an address""
  },
  {
    ""part"": ""<esp>"",
    ""category"": ""register"",
    ""desc"": ""Stack pointer register name - contains the address we want to examine""
  }
]
"
Dump the `main` function's buffer as a C byte array to `main.c`	pcf @ main > main.c	"
Looking at this question, we need to:
1. Dump a function's contents
2. Format it as a C byte array
3. Output it to a file
4. Target the main function specifically

This suggests we need the print command (p) followed by some formatting options. Since we want C format output and specifically a function's buffer, we'll need 'pc' for C output and 'f' to specify we want the function's data. The @ symbol allows us to specify which function to target (main), and the > redirects the output to a file.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command to output data""
  },
  {
    ""part"": ""c"",
    ""category"": ""format"",
    ""desc"": ""format output as C code""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""specify we want the current function's buffer""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""at operator to specify where to read from""
  },
  {
    ""part"": ""<main>"",
    ""category"": ""argument"",
    ""desc"": ""target the main function""
  },
  {
    ""part"": "">"",
    ""category"": ""redirect"",
    ""desc"": ""redirect output to file""
  },
  {
    ""part"": ""<main.c>"",
    ""category"": ""argument"",
    ""desc"": ""output filename""
  }
]
"
Replace every symbol with a RET instruction.	wao ret0 @@ sym.*	"
We need to modify every symbol in the binary to return 0. This is a common technique when wanting to stub out functionality or make functions return a specific value. We need to:
1. Find all symbols (sym.*)
2. Replace their first instruction with a return 0 instruction
3. Do this for each one (@@ iterator)

The command needs to combine:
- A way to modify instructions (wao)
- The specific modification to return 0 (ret0)
- Apply it to all symbols (@@ sym.*)
"	"
[
  {
    ""part"": ""wao"", 
    ""category"": ""write"",
    ""desc"": ""write assembly operation - modifies existing instructions""
  },
  {
    ""part"": ""ret0"",
    ""category"": ""argument"",
    ""desc"": ""specific operation to make current instruction return 0""
  },
  {
    ""part"": ""@@"",
    ""category"": ""iterator"",
    ""desc"": ""foreach operator - applies command to multiple targets""
  },
  {
    ""part"": ""sym.*"",
    ""category"": ""argument"",
    ""desc"": ""glob pattern matching all symbols""
  }
]
"
NOP the current instruction	wao nop	"
When we want to modify the current instruction to be a NOP (no operation), we need a way to write assembly while being aware of the current instruction's context. The 'write assembly operation' command family is perfect for this since it handles the complexities of replacing instructions while maintaining proper sizing and alignment.

First, we need to write (w), then we need to perform an assembly operation (a), and finally we want to modify/overwrite (o) the current instruction with a specific operation (nop). This leads us naturally to the wao command which is specifically designed for modifying existing instructions.
"	"
[
    {""part"": ""w"", ""category"": ""write"", ""desc"": ""We need to write to memory""},
    {""part"": ""a"", ""category"": ""assembly"", ""desc"": ""We're dealing with assembly level operations""},
    {""part"": ""o"", ""category"": ""operation"", ""desc"": ""We want to modify/overwrite an existing instruction""},
    {""part"": ""<nop>"", ""category"": ""argument"", ""desc"": ""The specific operation we want to perform - insert a NOP instruction""}
]
"
Grep for instructions that use the `eax` register within the first 2000 instructions.	pd 2000~eax	"
We need to look at 2000 instructions and then filter them to only show ones that contain ""eax"". This is a two-part operation:
1. First we need to disassemble 2000 instructions 
2. Then we need to grep through those instructions looking for ""eax""

The natural way to build this command is:
1. Start with print command since we want to display something
2. We want disassembly, so we use 'd' 
3. We specify the number of instructions (2000)
4. Finally, we use the grep operator (~) to filter for ""eax""
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command - the base operation for displaying data""
  },
  {
    ""cmd"": ""d"", 
    ""category"": ""disassembly"",
    ""desc"": ""disassemble - convert machine code to assembly instructions""
  },
  {
    ""cmd"": ""<2000>"",
    ""category"": ""count"",
    ""desc"": ""number of instructions to disassemble""
  },
  {
    ""cmd"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output""
  },
  {
    ""cmd"": ""<eax>"",
    ""category"": ""pattern"",
    ""desc"": ""the text pattern to search for in the disassembly""
  }
]
"
Step through the debugger 10 times.	10ds	"
When debugging, we often want to step through the code instruction by instruction to understand the program flow. The question asks to step 10 times, so we need a command that combines debugging step functionality with a count.

Looking at the debug commands (d), we need stepping functionality (ds) and we want to do it multiple times. In radare2, you can prefix most commands with a number to repeat them that many times.
"	"
[
  {""part"": ""10"", ""category"": ""count"", ""desc"": ""number of times to repeat the command""},
  {""part"": ""d"", ""category"": ""debug"", ""desc"": ""enter debug command mode""},
  {""part"": ""s"", ""category"": ""step"", ""desc"": ""step instruction - executes one instruction at a time""}
]
"
Show me 20 hexadecimal bytes at the stack pointer.	px 20 @r:SP	"
You want to see memory contents at a specific location - the stack pointer. This requires:
1. A way to print memory in hex format
2. A specific length (20 bytes)
3. A way to reference the stack pointer register
4. A way to specify we want to read from that address

The command builds naturally:
- We need hex dump, so 'px' is our base
- We need 20 bytes, so that's our first argument
- We need to read from SP, but need to specify it's a register value with r:
- The @ symbol is used to specify where to read from
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command - the base for showing data""
  },
  {
    ""part"": ""x"",
    ""category"": ""format"",
    ""desc"": ""specify hexadecimal output format""
  },
  {
    ""part"": ""<20>"",
    ""category"": ""argument"",
    ""desc"": ""number of bytes to print""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""specify where to read from (temporary seek)""
  },
  {
    ""part"": ""r:"",
    ""category"": ""register"",
    ""desc"": ""indicate we want to read from register value""
  },
  {
    ""part"": ""<SP>"",
    ""category"": ""register"",
    ""desc"": ""specify the stack pointer register""
  }
]
"
How do I rename the function at address `0x080485a5` to `new_func`?	afn new_func @ 0x080485a5	"
To rename a function, we need to work with function-related commands, which are typically under the 'a' (analysis) namespace. Since we want to modify a function's name, we'll need something that combines function ('f') and name ('n') operations. The address specification comes after the new name since we're applying the change to a specific location.

The thought process is:
1. Need to modify analysis data -> 'a' command
2. Working with functions -> 'f' subcommand
3. Changing name -> 'n' operation
4. Need to specify new name and target address
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""start with analysis commands since we're modifying analysis metadata""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""specify we're working with function-related commands""
    },
    {
        ""part"": ""n"",
        ""category"": ""name"",
        ""desc"": ""indicate we want to modify the name""
    },
    {
        ""part"": ""<new_func>"",
        ""category"": ""argument"",
        ""desc"": ""the new name we want to give the function""
    },
    {
        ""part"": ""@"",
        ""category"": ""location"",
        ""desc"": ""specify that what follows is the target address""
    },
    {
        ""part"": ""<0x080485a5>"",
        ""category"": ""address"",
        ""desc"": ""the address of the function we want to rename""
    }
]
"
I want to set a breakpoint at the `main` function.	db sym.main	"
When debugging, one of the most common tasks is setting breakpoints at key functions. The main function is typically where program execution begins after initialization, so it's a natural place to want to stop. We need a command that handles breakpoints and can understand symbolic names. Looking at the command set, 'db' is the breakpoint management command, and it accepts either addresses or symbol names. Since we want to break at main, we can use its symbol name 'sym.main'.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""debug commands are used for dynamic analysis and breakpoint management""
    },
    {
        ""part"": ""b"",
        ""category"": ""breakpoint"",
        ""desc"": ""specifically for managing breakpoints - adding, removing, enabling, disabling""
    },
    {
        ""part"": ""<sym.main>"",
        ""category"": ""argument"",
        ""desc"": ""the symbol name for the main function where we want the breakpoint""
    }
]
"
Continue execution in the debugger until the next breakpoint.	dc	"
When debugging, one of the most common operations is to let the program run until it hits the next breakpoint. This is similar to GDB's ""continue"" command. Since we're in a debugging context, we need a command that starts with 'd' for debug operations. Looking at the debug commands, 'dc' makes perfect sense - it stands for ""debug continue"" and does exactly what we need - continues execution until the next breakpoint or program end.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""debug commands always start with d to group debugging operations""
  },
  {
    ""cmd"": ""c"",
    ""category"": ""continue"",
    ""desc"": ""continue execution - logical choice after d since we want the program to continue running""
  }
]
"
Show all imported functions in JSON format.	iij	"
I need to list imported functions from the binary. Since this involves binary information, I'll start with the 'i' command family which handles binary info. I want specifically imported functions, so that's another 'i'. And since I want JSON output, I need 'j'. This sequence makes perfect sense as it builds up from basic binary info to specific imports in JSON format.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""info"",
    ""desc"": ""binary information commands""
  },
  {
    ""cmd"": ""i"",
    ""category"": ""imports"",
    ""desc"": ""list imports specifically""
  },
  {
    ""cmd"": ""j"",
    ""category"": ""format"",
    ""desc"": ""output in JSON format""
  }
]
"
List all sections of the binary.	iS	"
When working with binaries, one of the first things we need to understand is its structure - particularly the sections like .text, .data, .bss etc. This is fundamental binary analysis information, so we need an information command that specifically deals with sections.

Looking at the commands, 'i' is for information commands related to the binary. Since we specifically want sections information, we need the 'S' subcommand which is dedicated to listing sections and segments.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""information command for getting details about the loaded binary""
  },
  {
    ""cmd"": ""S"",
    ""category"": ""sections"",
    ""desc"": ""specifically lists sections and segments of the binary, providing details like address ranges, permissions and names""
  }
]
"
"Search for the string ""password"" in the binary."	/ password	"
Looking for a string ""password"" in a binary requires using the search command. In radare2, the forward slash (/) is the search command prefix. Since we're looking for a plain string, we can directly use the string after the slash without any special modifiers. This is the most basic form of search - looking for ASCII strings in the binary data.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""initiate a search operation in the binary""
  },
  {
    ""part"": ""<password>"",
    ""category"": ""argument"",
    ""desc"": ""the literal string to search for in ASCII format""
  }
]
"
How do I list all loaded types (structs, enums, ..)?	t	"
When working with binary analysis, you often need to see what types are loaded into r2 to understand the data structures you're working with. The most basic way to get this information would be to list all types that have been loaded, whether they came from parsed headers, manually defined types, or other sources. Since we're asking about listing types, we should look at the type-related commands, which all start with 't'. The base 't' command without any arguments is the most basic form that shows everything.
"	"
[{
    ""part"": ""t"",
    ""category"": ""types"",
    ""desc"": ""The types command - this single letter shows all loaded types in a human readable format. No additional arguments needed since we want the complete list.""
}]
"
Define a new struct named `MyStruct` with a `char a` and `int b`.	'td struct MyStruct {char a; int b;};	"
We need to define a new data structure in radare2. Looking at the help, 't' commands are for types management. Since we need to define a new type, specifically a struct, we need the 'td' command which loads types from a string. The syntax follows C-style struct definitions, so we can directly use the C struct syntax in quotes.
"	"
[
    {
        ""part"": ""t"", 
        ""category"": ""types"",
        ""desc"": ""Type management commands are under 't'""
    },
    {
        ""part"": ""d"",
        ""category"": ""define"",
        ""desc"": ""Define a new type from a string definition""
    },
    {
        ""part"": ""<struct MyStruct {char a; int b;}>"",
        ""category"": ""arguments"",
        ""desc"": ""The C-style struct definition string to define the new type""
    }
]
"
Calculate the size of the string at address `0x080487cf`	ps@0x100007d58~?.	"
We need to find the length of a string at a specific address. Let's break this down:
1. First we need to print/show the string at that address (p for print, s for string)
2. Then we need to get the length of that string using the grep operator (~)
3. The ?. modifier for grep counts the number of characters

This is a common pattern when you need to get string lengths in r2. The command combines string printing with length counting in one go.
"	"
[
    {""part"": ""ps"", ""category"": ""print_string"", ""desc"": ""print string - we need to show the string contents""},
    {""part"": ""@"", ""category"": ""at_operator"", ""desc"": ""at operator - specifies we want to read from a specific address""}, 
    {""part"": ""<0x100007d58>"", ""category"": ""address"", ""desc"": ""the memory address where we want to read the string from""},
    {""part"": ""~"", ""category"": ""grep"", ""desc"": ""grep operator - we want to filter/process the output""},
    {""part"": ""?."", ""category"": ""grep_count"", ""desc"": ""count the number of characters in the string""}
]
"
Show the control flow graph of the `main` function in DOT format.	agfc @ sym.main`	"
Looking at this question, we need to visualize the control flow of the main function. We need a graph command that can show function control flow and output it in DOT format.

Breaking this down:
1. We need a graph visualization - that's the 'ag' command family
2. We want to see function control flow - 'f' for function
3. We want it in DOT format - 'c' for DOT (graphviz)
4. We want to look at main function - need to specify @ sym.main

This leads us to combine these elements into agfc @ sym.main, which will generate a DOT format graph showing how the code flows through the main function.
"	"
[
  {
    ""part"": ""ag"",
    ""category"": ""graph"",
    ""desc"": ""graph command prefix for generating visual graphs""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""specifies we want to graph function basic blocks""
  },
  {
    ""part"": ""c"",
    ""category"": ""format"",
    ""desc"": ""output in DOT format for graphviz""
  },
  {
    ""part"": ""@ <sym.main>"",
    ""category"": ""address"",
    ""desc"": ""specifies the target function to analyze""
  }
]
"
Export the list of functions to a JSON file.	aflj > functions.json	"
We need to list all the functions in the binary, but in JSON format, and then redirect that output to a file. This requires:
1. A command to list functions
2. A way to format it as JSON 
3. Shell redirection to save to a file

The 'afl' command lists functions, and adding 'j' typically converts output to JSON in radare2. The '>' is standard shell redirection to write to a file.
"	"
[
  {
    ""part"": ""a"", 
    ""category"": ""analysis"",
    ""desc"": ""analysis command namespace""
  },
  {
    ""part"": ""f"",
    ""category"": ""functions"", 
    ""desc"": ""function-specific subcommand""
  },
  {
    ""part"": ""l"",
    ""category"": ""listing"",
    ""desc"": ""list all functions""
  },
  {
    ""part"": ""j"",
    ""category"": ""format"",
    ""desc"": ""output in JSON format""
  },
  {
    ""part"": ""> <functions.json>"",
    ""category"": ""shell"",
    ""desc"": ""redirect output to specified file""
  }
]
"
How do I visualize the call graph of the binary?	agcd`	"
To visualize a call graph of a binary, we need a command that generates graphs ('ag' commands) and specifically one that shows function calls. Looking at the help, we can see that 'agc' generates a callgraph. The 'd' suffix specifies we want it in dot format, which is a common graph visualization format that can be rendered with tools like Graphviz. This command will show the relationships between functions based on which functions call each other.
"	"
[
  {
    ""part"": ""a"", 
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used to extract information from the binary""
  },
  {
    ""part"": ""g"",
    ""category"": ""graph"",
    ""desc"": ""graph generation commands to visualize data""
  },
  {
    ""part"": ""c"",
    ""category"": ""calls"",
    ""desc"": ""specifies we want to see function calls relationships""
  },
  {
    ""part"": ""d"",
    ""category"": ""format"",
    ""desc"": ""output in dot format for graph visualization tools""
  }
]
"
Search for syscall instructions in the binary	/as	"
Looking for syscall instructions in a binary requires searching through the code. Since this is a search operation, I know it starts with '/'. Then, since we're looking specifically for assembly instructions (syscalls), I'd want to use the assembly search variant 'a'. Finally, since we're looking specifically for syscalls, we need the syscall search specifier 's'. This forms the command /as which will search through the binary looking for syscall instructions.
"	"
[
    {
        ""part"": ""/"",
        ""category"": ""search"",
        ""desc"": ""indicates a search operation is needed""
    },
    {
        ""cmd"": ""a"",
        ""category"": ""assembly"",
        ""desc"": ""specifies we're searching for assembly instructions""
    },
    {
        ""cmd"": ""s"",
        ""category"": ""syscall"",
        ""desc"": ""narrows the assembly search to specifically find syscall instructions""
    }
]
"
Show all environment variables set by radare2	%	"
When working with radare2, we often need to check the environment variables that are set by the tool itself. These variables can contain important information about the current state, file properties, and configuration. The question asks for a way to list ALL environment variables, which suggests we need a simple listing command. Looking at the % command family, which handles environment variables, the simplest form without any arguments would show all variables.
"	"
[{
    ""part"": ""%"",
    ""category"": ""environment"",
    ""desc"": ""The standalone % command is used to list all environment variables. This is the most direct way to see all variables set by radare2""
}]
"
How do I execute the shell command `ls` from within radare2?	!ls	"
When working within radare2, sometimes you need to execute system commands without leaving the r2 shell. The most direct way to interact with the system shell is through the '!' command prefix, which tells r2 to execute what follows as a shell command. In this case, we want to run the simple 'ls' command to list directory contents.
"	"
[
  {
    ""part"": ""!"",
    ""category"": ""shell"",
    ""desc"": ""tells r2 to execute the following as a system shell command""
  },
  {
    ""part"": ""<ls>"",
    ""category"": ""arguments"",
    ""desc"": ""the actual shell command to be executed""
  }
]
"
Pipe the disassembly of `main` to `grep` for the `call` instruction.	pdf @ sym.main | grep call	"
We need to disassemble a function, specifically 'main', and then filter the output to only show lines containing 'call' instructions. This is a common task when analyzing function calls within a program.

First, we need the print disassembly function command, then we need to specify which function, and finally pipe that through grep to filter for calls.
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""Start with printing command as we want to output something""
  },
  {
    ""part"": ""d"",
    ""category"": ""disassembly"", 
    ""desc"": ""We want to disassemble, so d for disassembly""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""We specifically want to disassemble a function""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""@ indicates we're specifying where to perform the command""
  },
  {
    ""part"": ""<sym.main>"",
    ""category"": ""argument"",
    ""desc"": ""The specific function we want to disassemble""
  },
  {
    ""part"": ""|"",
    ""category"": ""pipe"",
    ""desc"": ""Pipe the output to the next command""
  },
  {
    ""part"": ""<grep call>"",
    ""category"": ""filter"",
    ""desc"": ""Filter the output to only show lines containing 'call'""
  }
]
"
How can I load FLIRT signatures from `libc.flirt`?	zfs libc.flirt	"
Looking at this question about FLIRT signatures, which are used for function identification and matching. The task is to load and scan FLIRT signatures from a specific file. In radare2, FLIRT operations are handled under the 'z' (zignatures) command namespace. Since we're dealing with FLIRT specifically, we'll need the 'zf' subcommand which manages FLIRT signatures. For loading and scanning a FLIRT file, we want the 's' operation (scan) rather than 'd' (dump) or 'z' (convert to sig commands).
"	"
[
    {
        ""part"": ""z"",
        ""category"": ""zignatures"",
        ""desc"": ""access the zignatures functionality""
    },
    {
        ""part"": ""f"",
        ""category"": ""flirt"",
        ""desc"": ""specify we're working with FLIRT signatures specifically""
    },
    {
        ""part"": ""s"",
        ""category"": ""scan"",
        ""desc"": ""scan/load the signatures into radare2""
    },
    {
        ""part"": ""<libc.flirt>"",
        ""category"": ""argument"",
        ""desc"": ""the FLIRT signature file to load""
    }
]
"
How can I load Radare2 function signatures from `libc.sdb`?	zo libc.sdb;z/	"
Looking at the question, we need to do two things: load function signatures and then use them. The question specifically mentions an .sdb file which contains signatures, so we need to first understand how to load those signatures.

Looking through the command help, we find 'zo' which is specifically for managing zignature files from .sdb format. After loading the signatures, we'll want to actually use them to find matches in our current binary, which is where the z/ command comes in - it performs the actual signature matching search.

This is a two-part command separated by a semicolon to execute them sequentially - first load, then search.
"	"
[
  {
    ""part"": ""z"",
    ""category"": ""zignatures"",
    ""desc"": ""Base command for working with function signatures""
  },
  {
    ""part"": ""o"",
    ""category"": ""file operations"",
    ""desc"": ""Load operation for signature files""
  },
  {
    ""part"": ""<libc.sdb>"",
    ""category"": ""argument"",
    ""desc"": ""The signature database file to load""
  },
  {
    ""part"": "";"",
    ""category"": ""separator"",
    ""desc"": ""Command separator to chain operations""
  },
  {
    ""part"": ""z"",
    ""category"": ""zignatures"",
    ""desc"": ""Base command for working with loaded signatures""
  },
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""Search for matches of the loaded signatures""
  }
]
"
Generate a signature for the `entry0` function.	zaf entry0	"
Looking at the task, we need to generate a zignature (a unique fingerprint) for a specific function - in this case the entry point function 'entry0'. Zignatures are useful for binary analysis and matching similar functions across different binaries.

The command needs to use the zignature subsystem ('z'), then specifically the add functionality ('a'), and since we're working with a function we want 'f'. The command needs the function name as a parameter.
"	"
[
  {
    ""part"": ""z"",
    ""category"": ""zignatures"",
    ""desc"": ""access the zignature subsystem""
  },
  {
    ""part"": ""a"",
    ""category"": ""add"",
    ""desc"": ""add a new zignature""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""create zignature specifically for a function""
  },
  {
    ""part"": ""<entry0>"",
    ""category"": ""argument"",
    ""desc"": ""the name of the function to generate signature for""
  }
]
"
List all currently loaded signatures in JSON format.	zj	"
Looking at this question, we need to list signatures, and specifically in JSON format. In radare2, signatures (also called zignatures) are patterns that help identify functions and code patterns. The 'z' command family handles all signature-related operations. Since we want JSON output, and radare2 typically uses 'j' as a suffix for JSON output, this leads us to the zj command.
"	"
[
  {
    ""part"": ""z"",
    ""category"": ""signatures"",
    ""desc"": ""Base command for working with zignatures (code signatures)""
  },
  {
    ""cmd"": ""j"",
    ""category"": ""output_format"",
    ""desc"": ""Modifier to output the results in JSON format, consistent with radare2's convention of using j for JSON output""
  }
]
"
Display the virtual address corresponding to the physical address `0x4000`.	?P 0x4000	"
When working with memory in a debugger or analysis tool, we often need to translate between physical and virtual addresses. The question asks for finding the virtual address that corresponds to the physical address 0x4000. This is a common operation when dealing with memory mappings and loaded binaries.

Looking through the help, I see that the '?' command family handles calculations and format conversions, and specifically ?P is designed to get the virtual address for a given physical one. This is exactly what we need.
"	"
[
  {
    ""part"": ""?"",
    ""category"": ""help/math"",
    ""desc"": ""The question mark indicates we're doing a calculation or conversion""
  },
  {
    ""part"": ""P"",
    ""category"": ""address conversion"",
    ""desc"": ""P specifically converts physical to virtual addresses""
  },
  {
    ""part"": ""<0x4000>"",
    ""category"": ""argument"",
    ""desc"": ""The physical address we want to convert to virtual""
  }
]
"
Display the physical address corresponding to the virtual address `0x80585a5`.	?P 0x80485a5	"
Looking at this question, we need to convert a virtual address to its physical address. In reverse engineering and debugging, virtual addresses are what the program sees, while physical addresses are where the data actually resides in memory. The `?` command is radare2's help/evaluation command, and when combined with `P`, it specifically handles address conversions. This command will take the virtual address as input and show its corresponding physical address based on the current mapping.
"	"
[
    {
        ""part"": ""?"",
        ""category"": ""evaluate"",
        ""desc"": ""evaluate expressions or show help""
    },
    {
        ""part"": ""P"",
        ""category"": ""conversion"",
        ""desc"": ""convert virtual address to physical address""
    },
    {
        ""part"": ""<0x80485a5>"",
        ""category"": ""argument"",
        ""desc"": ""virtual address to be converted""
    }
]
"
How do I view the current seek offset?	s	"
When working with binary analysis, one of the most fundamental things you need to know is ""where am I right now?"" - this is your current position or ""seek"" in the file. The simplest way to check this would be to just print the current seek offset. Looking through the seek commands (s), the basic form without any arguments is exactly what we need - it will print the current address.
"	"
[{
    ""part"": ""s"",
    ""category"": ""seek"",
    ""desc"": ""The seek command by itself, with no arguments, will print the current seek offset - this is the most basic and direct way to show where we are in the file""
}]
"
How do I view the current seek offset in decimal?	?vi $$	"
When working with offsets in radare2, we often need to convert between different number bases. The question asks for the current seek in decimal format. I know that $$ is the current seek pseudo-variable, but by default it would show in hex. To view it in decimal, we need to evaluate it as a number. The '?v' command is used for numeric/data conversion and printing values, and adding 'i' to it forces decimal (integer) output.
"	"
[
    {
        ""part"": ""?"",
        ""category"": ""help/evaluate"",
        ""desc"": ""evaluate numeric expressions""
    },
    {
        ""part"": ""v"",
        ""category"": ""value"",
        ""desc"": ""print value of expression""
    },
    {
        ""part"": ""i"",
        ""category"": ""integer"",
        ""desc"": ""force decimal (integer) output format""
    },
    {
        ""part"": ""<$$>"",
        ""category"": ""variable"",
        ""desc"": ""current seek position pseudo-variable""
    }
]
"
I want to list all loaded enums.	te	"
When working with binary analysis, we often need to inspect data types, including enumerations. The question asks for listing all loaded enums, which is a fundamental type operation. Looking at the command set, we need something that deals with types ('t' commands) and specifically enums, so we're looking for a type-enum related command.
"	"
[
    {
        ""part"": ""t"",
        ""category"": ""types"",
        ""desc"": ""This is the main type manipulation command prefix""
    },
    {
        ""cmd"": ""e"",
        ""category"": ""enums"",
        ""desc"": ""Specifically targets enum operations, making 'te' the command to list enums""
    }
]
"
"Add a comment ""Initialize variables"" at address `0x08048648`."	'@0x08048648'CC Initialize variables	"
The question asks to add a comment at a specific address. In radare2, comments are managed with the 'C' command family. Since we want to add a simple comment, we need the 'CC' command which is for adding/modifying comments. The command needs the comment text and the address where to place it. The address can be specified using the '@' syntax in radare2. So we need to combine 'CC' with the comment text and target address.
"	"
[
  {""part"": ""CC"", ""category"": ""comments"", ""desc"": ""add/modify comments command - CC is the basic comment command""},
  {""part"": "" <Initialize variables>"", ""category"": ""argument"", ""desc"": ""the actual comment text to add""},
  {""part"": "" @"", ""category"": ""address_specifier"", ""desc"": ""tells r2 that what follows is the target address""},
  {""part"": ""<0x08048648>"", ""category"": ""address"", ""desc"": ""the hexadecimal address where to place the comment""}
]
"
Remove all comments from the binary.	CC-*	"
When working with binaries, comments are often added during analysis to help understand the code. Sometimes you need to remove all these comments, perhaps to start fresh or to share a clean binary. Looking at the command structure, we need something that deals with comments (C) and removes them all (*). The minus sign is commonly used for removal operations.
"	"
[
    {""part"": ""C"", ""category"": ""metadata"", ""desc"": ""Command for working with comments and metadata""},
    {""part"": ""C"", ""category"": ""comments"", ""desc"": ""Specifically targets comments subsection""},
    {""part"": ""-"", ""category"": ""operation"", ""desc"": ""Indicates a removal operation""},
    {""part"": ""*"", ""category"": ""scope"", ""desc"": ""Applies to all comments in the binary""}
]
"
Show the comments in JSON format.	CCj	"
We need to show comments, and we want them in JSON format. In radare2, comments are typically managed with the 'C' command family. Since we want to see them in JSON format, we'll need to use a JSON modifier. Looking at the help, we can see that 'CC' is used to list comments, and adding 'j' at the end will give us JSON output.
"	"
[
  {
    ""part"": ""C"",
    ""category"": ""metadata"",
    ""desc"": ""manages comments and metadata""
  },
  {
    ""part"": ""C"",
    ""category"": ""comments"",
    ""desc"": ""specifically handles comment operations""
  },
  {
    ""part"": ""j"",
    ""category"": ""output_format"",
    ""desc"": ""modifier to output in JSON format""
  }
]
"
How do I list all loaded core plugins?	Lc	"
When working with radare2, plugins are a crucial part of extending functionality. The question asks about listing core plugins specifically, which are the fundamental plugins that provide core functionality to r2. Looking at the command help, we need a command that deals with listing plugins, and specifically core plugins. The 'L' command family handles plugin management, and since we want core plugins specifically, we need the 'c' modifier.
"	"
[
    {
        ""part"": ""L"",
        ""category"": ""plugins"",
        ""desc"": ""The main command for plugin management and listing""
    },
    {
        ""part"": ""c"",
        ""category"": ""core"",
        ""desc"": ""Specifies we want to list core plugins specifically, rather than other plugin types like analysis or debug plugins""
    }
]
"
How do I list all loaded bin parser plugins?	Lb	"
When working with binary files in radare2, we often need to know what binary format parsers are available. Since this is about listing plugins, and specifically binary parsing plugins, we need a command that deals with listing (L) and binary parsing (b). The question is asking about listing all loaded binary parser plugins, which are the modules that help r2 understand different binary formats like ELF, PE, Mach-O, etc.
"	"
[
  {
    ""part"": ""L"", 
    ""category"": ""plugins"",
    ""desc"": ""The capital L indicates we're working with plugin management""
  },
  {
    ""part"": ""b"",
    ""category"": ""binary"",
    ""desc"": ""The b specifier tells r2 we want to see binary format plugins specifically""
  }
]
"
How do I list all loaded arch plugins?	La	"
When dealing with architecture plugins in radare2, we need a way to see what's available to us. The question asks specifically about listing arch plugins, which are the plugins that handle different CPU architectures for disassembly and analysis. This is a common need when working with binaries for different platforms.

Looking at the command structure, we need something that deals with listing (L) and specifically architecture (a). The 'L' command family handles plugins, and since we want architecture plugins specifically, 'La' makes perfect sense as it combines both concepts.
"	"
[
  {
    ""part"": ""L"", 
    ""category"": ""plugins"",
    ""desc"": ""The main command for listing/managing plugins""
  },
  {
    ""part"": ""a"",
    ""category"": ""architecture"",
    ""desc"": ""Specifies we want to list architecture plugins specifically""
  }
]
"
Mount an ext2 filesystem located at offset 0 to `/mnt`.	m /mnt ext2 0	"
When we need to analyze a filesystem within a binary or disk image, we need to mount it first to access its contents. The question asks to mount an ext2 filesystem at a specific location (/mnt) and specifies it's at offset 0 in the current file. This is a common task when analyzing disk images or embedded systems. The command needs to specify three things: the mount point, the filesystem type, and the offset where the filesystem starts.
"	"
[
    {
        ""part"": ""m"",
        ""category"": ""mountpoints"",
        ""desc"": ""mount command - manages mountpoints in r2""
    },
    {
        ""part"": ""</mnt>"",
        ""category"": ""arguments"",
        ""desc"": ""mount point - where to mount the filesystem in r2's virtual fs""
    },
    {
        ""part"": ""<ext2>"",
        ""category"": ""arguments"",
        ""desc"": ""filesystem type - specifies we're mounting an ext2 filesystem""
    },
    {
        ""part"": ""<0>"",
        ""category"": ""arguments"",
        ""desc"": ""offset - where in the current file the filesystem starts""
    }
]
"
List all current mount points.	m	"
When working with filesystems and mount points in radare2, we need a way to see what's currently mounted. The question asks for a list of all current mount points, which suggests we need a simple listing command. Looking at the available commands, 'm' is the mount command category and using it without arguments should list the current mounts in a human readable format.
"	"
[{
    ""part"": ""m"",
    ""category"": ""mountpoints"",
    ""desc"": ""The mountpoints command without arguments lists all current mountpoints in human readable format""
}]
"
Push the current directory onto the stack and change to `/tmp`.	pushd /tmp	"
To manage directory navigation with a stack mechanism, we need a command that both changes the current directory and remembers where we were. This is a common shell operation where you want to temporarily switch to another directory while keeping track of your previous location. The 'pushd' command is perfect for this as it combines both operations - it stores the current directory on a stack and then changes to the specified directory, in this case '/tmp'.
"	"
[{
    ""part"": ""pushd"",
    ""category"": ""directory_stack"",
    ""desc"": ""command to push current directory onto stack""
}, {
    ""part"": ""</tmp>"",
    ""category"": ""arguments"",
    ""desc"": ""target directory to change to after pushing current directory""
}]
"
Pop the last directory from the stack and change back to it.	popd	"
Looking at the question, we need to manage directory navigation using a stack-based approach. This is a common shell operation where you want to return to a previous directory after temporarily changing to another one. The operation involves two parts: removing the last directory from the stack and changing the current working directory to that location. The 'popd' command is specifically designed for this purpose in shell environments, and radare2 implements this common shell command.
"	"
[{
    ""part"": ""popd"",
    ""category"": ""filesystem"",
    ""desc"": ""Single command that handles both popping the directory from the stack and changing to it. This is a shell-like command implemented in radare2 for compatibility and convenience with standard shell operations""
}]
"
I want to visualize the basic blocks of the `foo` function.	afb @ sym.foo	"
When you want to visualize basic blocks of a function, you need to first analyze it and then display its basic blocks. The question is asking specifically about the 'foo' function, so we need to use a command that deals with analyzing basic blocks ('b') within function analysis ('f') and target it at a specific function ('sym.foo').

Looking at the command help, under the function analysis commands (af), there's a specific subcommand for basic blocks (afb). This is exactly what we need since we want to see the basic blocks of a specific function.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used to analyze code""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""function-specific analysis commands""
    },
    {
        ""part"": ""b"",
        ""category"": ""basic blocks"",
        ""desc"": ""display basic blocks information""
    },
    {
        ""part"": ""@"",
        ""category"": ""address"",
        ""desc"": ""specifies where to perform the operation""
    },
    {
        ""part"": ""<sym.foo>"",
        ""category"": ""argument"",
        ""desc"": ""the target function to analyze""
    }
]
"
Search for the hexadecimal pattern `0x90 0x90 0x90` in the binary.	/x 909090	"
Looking for a specific hex pattern in a binary - this is a classic search operation. The pattern 0x90 0x90 0x90 represents three consecutive NOP instructions in x86, which is a common pattern to look for. We need a search command that can handle raw hex values.

The / command is radare2's search command, and since we're looking for hex values specifically (not strings or other data types), we need the /x variant which is designed for hex pattern searching. The pattern can be written without the 0x prefixes and spaces since /x expects a continuous string of hex digits.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""base search command - the primary way to search through memory/binary""
  },
  {
    ""part"": ""x"",
    ""category"": ""type"",
    ""desc"": ""specifies hexadecimal search mode - tells radare2 to interpret the following input as hex bytes""
  },
  {
    ""part"": ""<909090>"",
    ""category"": ""argument"",
    ""desc"": ""the actual hex pattern to search for - three bytes of 0x90""
  }
]
"
How do I decode a base64 string `SGVsbG8=` and write it to address `0x08049000`?	w6e SGVsbG8= @ 0x08049000	"
To decode and write base64 data, I need a write command that specifically handles base64. Looking at the write commands (w), I see there's a w6 command family that deals with base64/string/hex operations. Since we want to decode base64 and write it, we need the decode variant. The target address is specified using the @ syntax for seeking to a specific location before performing the operation.

The process is:
1. Write command (w)
2. Base64 operation (6)
3. Decode operation (e for ""extract/decode"")
4. The base64 string itself
5. The target address with @
"	"
[
  {
    ""part"": ""w"",
    ""category"": ""write"",
    ""desc"": ""write operation - we need to modify memory""
  },
  {
    ""part"": ""6"",
    ""category"": ""encoding"",
    ""desc"": ""specifies base64 operation mode""
  },
  {
    ""part"": ""e"",
    ""category"": ""operation"",
    ""desc"": ""decode the base64 string""
  },
  {
    ""part"": ""<SGVsbG8=>"",
    ""category"": ""argument"",
    ""desc"": ""the base64 encoded string to decode""
  },
  {
    ""part"": ""@"",
    ""category"": ""addressing"",
    ""desc"": ""specify target address""
  },
  {
    ""part"": ""<0x08049000>"",
    ""category"": ""argument"",
    ""desc"": ""the memory address to write to""
  }
]
"
List all loaded union types.	tu	"
The question is asking to list all loaded union types in the binary or project. Since we're dealing with types, specifically unions, we need a command from the type-related commands. Looking at the 't' command family which handles types, we see there's a specific subcommand 'tu' that deals with unions. The base command without arguments will list all loaded unions, which is exactly what we need.
"	"
[
  {
    ""part"": ""t"",
    ""category"": ""types"",
    ""desc"": ""The main type manipulation command, since we're dealing with type information""
  },
  {
    ""part"": ""u"",
    ""category"": ""unions"",
    ""desc"": ""Specifies we want to work with union types specifically, and without arguments it lists all loaded unions""
  }
]
"
How can I display the stack frames or backtrace in the debugger?	dbt	"
When debugging, one of the most important things to inspect is the call stack or backtrace to understand how the program got to the current point. Since we're looking for a debugging feature that shows the stack frames, we need a command that combines debugging capabilities with backtrace functionality. The command should start with 'd' for debug-related operations, and since we're looking at the backtrace, 'bt' is a common abbreviation used in many debuggers (like gdb) for backtrace.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""debug commands are prefixed with d to group all debugging operations""
    },
    {
        ""part"": ""b"",
        ""category"": ""backtrace"",
        ""desc"": ""indicates we want to work with the backtrace/stack frames""
    },
    {
        ""part"": ""t"",
        ""category"": ""trace"",
        ""desc"": ""specifies we want to see the trace of calls that led to current position""
    }
]
"
Rename the symbol `fcn.08048648` to `init`.	fr init fcn.08048648	"
When working with symbols in reverse engineering, we often need to rename functions to make them more meaningful. The question asks to rename a function from its default name `fcn.08048648` (which is an auto-generated name by radare2) to `init` (which is more descriptive). 

To do this, we need a command that handles flags/references since function names are stored as flags in radare2. The 'f' command family deals with flags, and specifically 'fr' is used for renaming flags, making it the perfect choice for this operation.
"	"
[
    {
        ""part"": ""f"",
        ""category"": ""flags"",
        ""desc"": ""flags command family, used for managing offset-name flags""
    },
    {
        ""part"": ""r"",
        ""category"": ""rename"",
        ""desc"": ""rename subcommand for flags""
    },
    {
        ""part"": ""<init>"",
        ""category"": ""arguments"",
        ""desc"": ""new name for the function""
    },
    {
        ""part"": ""<fcn.08048648>"",
        ""category"": ""arguments"",
        ""desc"": ""original function name to be renamed""
    }
]
"
Show the sizes of all functions in the binary.	afl,size/cols/name	"
To show function sizes, I need to list functions first. The 'a' commands handle analysis, and 'af' deals with functions specifically. Since I want to list all functions, 'afl' is the base command I need. But I want to focus on sizes and names, and present them in a specific way. The comma operator in radare2 allows for table queries, and I can specify which columns I want to see and how to organize them. So by adding ',size/cols/name' I'm asking for a table with just those two columns.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis command prefix for working with code analysis""
    },
    {
        ""part"": ""f"",
        ""category"": ""functions"",
        ""desc"": ""narrows down to function-related operations""
    },
    {
        ""part"": ""l"",
        ""category"": ""listing"",
        ""desc"": ""lists all functions""
    },
    {
        ""part"": "","",
        ""category"": ""table"",
        ""desc"": ""switches to table query mode""
    },
    {
        ""part"": ""<size/cols/name>"",
        ""category"": ""format"",
        ""desc"": ""specifies which columns to show (size and name) and how to display them""
    }
]
"
How do I check the endianness of the binary?	e arch.endian	"
When working with binaries, endianness is a critical property that determines how bytes are ordered in memory. To check this, I need to access the configuration settings in r2, which are managed through the 'e' command. Since endianness is an architectural property, it would be under the 'arch' namespace. The specific variable that controls this would be 'arch.endian'.
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""evaluate/show configuration variables""
  },
  {
    ""part"": ""arch.endian"",
    ""category"": ""variable"",
    ""desc"": ""the specific configuration variable that stores the endianness setting for the current architecture""
  }
]
"
Set the architecture to ARM.	e asm.arch=arm	"
To change the architecture in radare2, we need to modify the assembly-related configuration. The question asks to set it specifically to ARM. This is a common task when analyzing ARM binaries or working with ARM assembly. The most direct way to do this is through the eval (e) command, which is used to get/set configuration variables. The architecture setting is controlled by the 'asm.arch' variable.
"	"
[
    {
        ""part"": ""e"",
        ""category"": ""eval"",
        ""desc"": ""access configuration variables""
    },
    {
        ""part"": ""asm.arch"",
        ""category"": ""config_var"",
        ""desc"": ""specifies which architecture to use for disassembly""
    },
    {
        ""part"": ""<arm>"",
        ""category"": ""value"",
        ""desc"": ""sets the architecture to ARM""
    }
]
"
Set the architecture to ARM THUMB.	e asm.arch=arm;e asm.bits=16;ahb 16	"
We need to configure radare2 to analyze ARM THUMB code. This requires multiple steps:
1. Set the architecture to ARM
2. Set the bit width to 16 (THUMB mode)
3. Set a hint to force 16-bit mode at the current address

The command combines these three operations using semicolons to chain them together. This is a common configuration needed when working with ARM THUMB code, especially in embedded systems or iOS/Android binaries.
"	"
[
  {""part"": ""e"", ""category"": ""eval"", ""desc"": ""evaluate/set configuration variable""},
  {""part"": ""asm.arch=<arm>"", ""category"": ""config"", ""desc"": ""set assembly architecture to ARM""},
  {""part"": "";"", ""category"": ""separator"", ""desc"": ""chain multiple commands""},
  {""part"": ""e"", ""category"": ""eval"", ""desc"": ""another configuration setting""},
  {""part"": ""asm.bits=<16>"", ""category"": ""config"", ""desc"": ""set assembly bits to 16 for THUMB mode""},
  {""part"": "";"", ""category"": ""separator"", ""desc"": ""chain another command""},
  {""part"": ""ahb"", ""category"": ""analysis"", ""desc"": ""set analysis hint for bits""},
  {""part"": ""<16>"", ""category"": ""argument"", ""desc"": ""specify 16-bit mode for the hint""}
]
"
How do I list all imported libraries?	il	"
To find imported libraries, we need to look at binary information commands. The question asks about listing libraries, so we need a command that shows library dependencies. Looking at the information commands (i), there's a specific subcommand for listing libraries (l).
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""information commands are used to get details about the binary""
  },
  {
    ""part"": ""l"",
    ""category"": ""libraries"",
    ""desc"": ""lists all libraries that the binary imports/depends on""
  }
]
"
Find all references to the function `printf`.	axt sym.imp.printf	"
When looking for references to a function, we need to find all the places in the code that call or use that function. In radare2, we're specifically looking for cross-references (xrefs) to printf.

Since printf is typically an imported function (sym.imp.printf), we want to see all the places that reference this symbol. The most direct way to find these references is using the cross-reference analysis commands.

The command needs to:
1. Find cross-references (x)
2. To a specific target (t)
3. For the printf function symbol

This leads us to using 'axt' (analyze xrefs to) followed by the symbol name.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis command group - for working with code analysis""
  },
  {
    ""part"": ""x"",
    ""category"": ""xrefs"",
    ""desc"": ""cross references subgroup - for finding code/data relationships""
  },
  {
    ""part"": ""t"",
    ""category"": ""target"",
    ""desc"": ""to - show references to this target""
  },
  {
    ""part"": ""<sym.imp.printf>"",
    ""category"": ""argument"",
    ""desc"": ""the target symbol we want to find references to""
  }
]
"
Visualize the control flow graph of the `main` function using Graphviz.	agfd main > cfg.dot	"
We need to visualize a control flow graph (CFG) for the main function. This requires:
1. First generating a graph representation of the function
2. Converting it to DOT format (used by Graphviz)
3. Saving it to a file

The natural progression would be:
- 'ag' for graph generation
- 'f' to specify we want a function graph
- 'd' to output in DOT format
And then we need to specify which function ('main') and redirect to a file.
"	"
[
  {
    ""part"": ""ag"", 
    ""category"": ""analysis_graph"",
    ""desc"": ""Generate a graph visualization""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""Specify we want a function-level graph""
  },
  {
    ""part"": ""d"",
    ""category"": ""format"",
    ""desc"": ""Output in DOT format for Graphviz""
  },
  {
    ""part"": ""<main>"",
    ""category"": ""argument"",
    ""desc"": ""The function name to graph""
  },
  {
    ""part"": ""> cfg.dot"",
    ""category"": ""redirect"",
    ""desc"": ""Save output to a DOT file""
  }
]
"
Convert a string into a list of bytes	?x hello	"
Looking at this question, we need to convert a text string into its hexadecimal byte representation. Since we're working with hexadecimal conversion, we'll want to use the '?' command family which handles conversions and calculations. Within that family, 'x' is perfect because it's specifically designed to convert a string into its hex representation.
"	"
[
  {
    ""part"": ""?"",
    ""category"": ""help/math"",
    ""desc"": ""indicates we want to perform a calculation or conversion""
  },
  {
    ""part"": ""x"",
    ""category"": ""conversion"",
    ""desc"": ""specifies we want to convert a string to hex bytes""
  },
  {
    ""part"": ""<hello>"",
    ""category"": ""argument"",
    ""desc"": ""the string we want to convert to hex bytes""
  }
]
"
Show all reachable functions from the `main` function.	aflm.@main	"
We need to list all functions that are called or reachable from the main function. This requires analyzing the function list (afl) but specifically in a way that shows the makefile-like format which displays function calls. Since we want to focus on main, we use @ to specify the address/function we want to analyze.

The command needs to combine:
1. Function listing capability
2. Makefile format to show relationships
3. Targeting specifically the main function
"	"
[
    {
        ""part"": ""afl"", 
        ""category"": ""analysis"",
        ""desc"": ""list functions - this is the base command to show functions""
    },
    {
        ""part"": ""m"",
        ""category"": ""format"",
        ""desc"": ""makefile format - shows dependencies between functions like a Makefile would show dependencies between targets""
    },
    {
        ""part"": ""."",
        ""category"": ""current"",
        ""desc"": ""current function only - limits the output to just the function we're interested in""
    },
    {
        ""part"": ""@"",
        ""category"": ""address"",
        ""desc"": ""at address/symbol operator - specifies where to perform the command""
    },
    {
        ""part"": ""<main>"",
        ""category"": ""argument"",
        ""desc"": ""specifies the main function as the target of our analysis""
    }
]
"
How do I set the stack frame size for the current function to 0x30?	afS 0x30	"
When working with functions in reverse engineering, we often need to define the stack frame size to properly analyze the function's local variables and stack usage. The question asks about setting the stack frame size, so we need a command that deals with function analysis ('af' commands) and specifically stack frames ('S' for stack). The value 0x30 is the size we want to set it to.
"	"
[
    {
        ""part"": ""af"",
        ""category"": ""analysis_function"",
        ""desc"": ""Function analysis command prefix - used for all function-related operations""
    },
    {
        ""part"": ""S"",
        ""category"": ""stack"",
        ""desc"": ""Stack frame subcommand - specifically for setting stack frame size""
    },
    {
        ""part"": ""<0x30>"",
        ""category"": ""arguments"",
        ""desc"": ""The size value to set the stack frame to, in hexadecimal""
    }
]
"
Create a new flag named `myFlag` at address `0x08049000` with size 8.	f myFlag 8 = 0x08049000`	"
To create a flag in radare2, I need to use the flag management command. Looking at the task:
1. Need to create a new flag (not modify existing)
2. Name should be ""myFlag""
3. Size should be 8 bytes
4. Located at specific address 0x08049000

The 'f' command is used for flag operations, and its syntax allows specifying the name, size, and address. The format is 'f name size @ addr' or 'f name = addr' for simpler flags. In this case, we need to specify size too, so we'll use the full format.
"	"
[
  {
    ""part"": ""f"",
    ""category"": ""flags"",
    ""desc"": ""flag command - used for creating and managing flags""
  },
  {
    ""part"": ""<myFlag>"",
    ""category"": ""arguments"",
    ""desc"": ""name of the flag to create""
  },
  {
    ""part"": ""<8>"",
    ""category"": ""arguments"",
    ""desc"": ""size of the flag in bytes""
  },
  {
    ""part"": ""="",
    ""category"": ""operator"",
    ""desc"": ""assignment operator for setting flag address""
  },
  {
    ""part"": ""<0x08049000>"",
    ""category"": ""arguments"",
    ""desc"": ""hexadecimal address where the flag should be created""
  }
]
"
List all flags in the current flagspace.	f	"
When working with reverse engineering, flags are essential markers or labels that help identify important locations in the code or data. The question asks for listing flags, specifically in the current flagspace. In radare2, flagspaces are like namespaces that help organize different types of flags (like functions, sections, symbols, etc.). Since we want a simple listing of the flags in the current space, we just need the basic flag command without any modifiers.
"	"
[{
    ""part"": ""f"",
    ""category"": ""flags"",
    ""desc"": ""The flag command by itself lists all flags in the current flagspace. This is the most basic and direct way to view flags, which makes sense as it's the primary command for flag operations.""
}]
"
List all flag spaces	fs	"
When working with flags in reverse engineering, they are often organized into different namespaces or ""spaces"" to keep things organized. For example, you might have different spaces for symbols, sections, functions, etc. To effectively manage these flags, I need to see what spaces exist. The question is asking for a way to list all these flag spaces, so I need a command that deals with flags and specifically their spaces.

Looking at the command reference, I see that 'f' is the base command for flags, and 's' is used for spaces within the flags system. This makes the 'fs' command the natural choice to list flag spaces.
"	"
[
  {
    ""part"": ""f"",
    ""category"": ""flags"",
    ""desc"": ""The base command for working with flags - this is the main category since we're dealing with flag management""
  },
  {
    ""part"": ""s"",
    ""category"": ""spaces"",
    ""desc"": ""The subcommand for managing flag spaces - when combined with f it lists all flag spaces""
  }
]
"
How do I create a new flag named `hint.foo` in the address 0x8123?	f hint.foo=0x8123	"
To create a flag at a specific address, I need to use the flag command. Looking at the flag help (`f?`), I can see that flags are used to mark specific memory addresses with names. The question asks to create a flag named ""hint.foo"" at address 0x8123. The syntax for creating a flag is straightforward - it's just `f` followed by the flag name, then `=` and the address. The dot notation in ""hint.foo"" suggests it's part of the ""hint"" namespace, which is a common practice in r2 for organizing related flags.
"	"
[
  {
    ""part"": ""f"",
    ""category"": ""flags"",
    ""desc"": ""flag command is used to create, modify or delete flags""
  },
  {
    ""part"": ""<hint.foo>"",
    ""category"": ""name"",
    ""desc"": ""the name of the flag to create, using dot notation for namespace""
  },
  {
    ""part"": ""="",
    ""category"": ""operator"",
    ""desc"": ""assigns the flag to a specific address""
  },
  {
    ""part"": ""<0x8123>"",
    ""category"": ""address"",
    ""desc"": ""the hexadecimal address where the flag should be created""
  }
]
"
Remove the flag named `oldFlag`.	f-oldFlag	"
Looking at the question, we need to remove a flag with a specific name. The flag management commands in radare2 start with 'f'. Since we want to remove a flag, we'd need the delete operation which is indicated by the minus sign (-) in radare2's consistent syntax style. The flag name is provided directly after the removal operator.
"	"
[
    {
        ""part"": ""f"", 
        ""category"": ""flags"",
        ""desc"": ""flag command - manages flags in radare2""
    },
    {
        ""part"": ""-"",
        ""category"": ""operators"",
        ""desc"": ""remove/delete operator for flags""
    },
    {
        ""part"": ""<oldFlag>"",
        ""category"": ""arguments"",
        ""desc"": ""name of the flag to be removed""
    }
]
"
How can I export all current flags to a file?	fj > flags.json	"
When we need to export data from r2, we usually want it in a format that's easy to parse or reuse. Since the question asks about exporting flags, I know we need the 'f' command which handles flags. And since we want ALL flags and we want them in a file, we need a format that's structured - JSON is perfect for this. The output redirection '>' is a standard shell operation to save output to a file.

The command needs to list all flags in JSON format and save it to a file called flags.json. This is a common operation when you want to process the flags externally or save them for later use.
"	"
[
    {
        ""part"": ""f"",
        ""category"": ""flags"",
        ""desc"": ""base command for working with flags""
    },
    {
        ""part"": ""j"",
        ""category"": ""output_format"",
        ""desc"": ""modifier to output in JSON format""
    },
    {
        ""part"": ""> <flags.json>"",
        ""category"": ""redirection"",
        ""desc"": ""shell redirection to save output to specified file""
    }
]
"
How can I export all current flags as radare2 comments?	f* > flags.r2	"
When working with radare2, flags are important markers in the binary. To share or save these flags for later use, we need a way to export them in a format that radare2 can understand. The question asks about exporting flags as comments, and the command uses the asterisk modifier which is commonly used in radare2 to output commands that can be executed again later. The redirection to a file (> flags.r2) suggests we want to save these commands for later use. This is a common pattern in radare2 where commands with * output their results in a reusable command format.
"	"
[
  {
    ""part"": ""f"",
    ""category"": ""flags"",
    ""desc"": ""Access the flags subsystem""
  },
  {
    ""part"": ""*"",
    ""category"": ""modifier"",
    ""desc"": ""Output in radare2 command format instead of human readable""
  },
  {
    ""part"": ""> <flags.r2>"",
    ""category"": ""shell_redirection"",
    ""desc"": ""Save the output to a file named flags.r2""
  }
]
"
Import flags from a an r2 script	. flags.r2file named `import_flags.json`.	"
We need to import flags from an external r2 script file. This is a common operation when working with saved analysis data or sharing flags between sessions. The dot command (.) is used to execute r2 commands from a file. Since we're given the filename, we just need to use the dot command followed by the filename.
"	"
[{
    ""part"": ""."", 
    ""category"": ""script execution"",
    ""desc"": ""Execute commands from a file - perfect for importing flags or other r2 commands""
}, {
    ""part"": ""<import_flags.json>"",
    ""category"": ""argument"",
    ""desc"": ""The filename containing the r2 commands to import flags""
}]
"
Show the value of the register `eax`.	dr eax	"
When dealing with registers, we need to use the debug/register commands. The question asks for a specific value of a register (eax), so we need a command that can display register values. Looking at the command reference, 'dr' is the command for CPU registers, and we can follow it with a register name to show its specific value.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""debug commands are used to interact with program execution and state""
    },
    {
        ""part"": ""r"",
        ""category"": ""registers"",
        ""desc"": ""register subcommand allows viewing and modifying CPU registers""
    },
    {
        ""part"": ""<eax>"",
        ""category"": ""argument"",
        ""desc"": ""specific register name to display its value""
    }
]
"
Dump the memory from address `0x08048000` to `0x08049000` into a file named `dump.bin`.	wtf dump.bin 0x1000 @ 0x8048000	"
Looking at this task, we need to write memory contents to a file. The key elements are:
1. Source address: 0x08048000
2. Size: The difference between end and start (0x08049000 - 0x08048000 = 0x1000)
3. Output file: dump.bin

We need a command that can write memory to a file. Looking at the 'w' (write) commands, 'wt' (write to file) stands out, and specifically 'wtf' which allows specifying both filename and size. The @ operator lets us set the address to read from.
"	"
[
  {
    ""part"": ""w"",
    ""category"": ""write"",
    ""desc"": ""write operations are needed to output data""
  },
  {
    ""part"": ""t"",
    ""category"": ""file"",
    ""desc"": ""write to file operation""
  },
  {
    ""part"": ""f"",
    ""category"": ""file"",
    ""desc"": ""specifies we want to write to file with size parameter""
  },
  {
    ""part"": ""<dump.bin>"",
    ""category"": ""argument"",
    ""desc"": ""output filename""
  },
  {
    ""part"": ""<0x1000>"",
    ""category"": ""argument"",
    ""desc"": ""size to dump""
  },
  {
    ""part"": ""@"",
    ""category"": ""operator"",
    ""desc"": ""at operator to specify address""
  },
  {
    ""part"": ""<0x8048000>"",
    ""category"": ""argument"",
    ""desc"": ""source address to read from""
  }
]
"
List all available calling conventions for the current architecture.	afcl	"
To understand calling conventions for the current architecture, I need to look at function analysis commands. Since we're dealing with function metadata, specifically calling conventions, this would be under the function analysis commands.

Looking at the command structure, we need something that lists calling conventions. The question specifically asks for ""all available"" calling conventions, so we need a listing command.

The path to this is:
1. Function analysis (af)
2. Calling convention subcommand (c) 
3. List option (l)

This makes perfect sense as afcl would show all the calling conventions that can be applied to functions in the current architecture.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are needed for function-level operations""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""specifies we're working with function-related commands""
    },
    {
        ""part"": ""c"",
        ""category"": ""calling convention"",
        ""desc"": ""narrows down to calling convention related operations""
    },
    {
        ""part"": ""l"",
        ""category"": ""list"",
        ""desc"": ""lists all available calling conventions for the current architecture""
    }
]
"
How do I search for all conditional jumps in the binary?	/at jmp	"
When searching for specific types of instructions in a binary, we need a search command that understands assembly instruction types. Looking at the search commands (/), we can see there's a specific subcommand for searching by instruction type (/at). Since we want to find conditional jumps specifically, which are a type of jump instruction, we can use /at with the 'jmp' argument to find all jump instructions.

This is a two-part approach: first searching (/), then specifying we want to search by instruction type (at), and finally indicating we're interested in jump instructions (jmp). The command will find all jump instructions in the binary, including both conditional and unconditional jumps.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""initiate a search operation in the binary""
  },
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""specify that we're searching in analyzed code/data""
  },
  {
    ""part"": ""t"",
    ""category"": ""type"",
    ""desc"": ""indicate we want to search by instruction type""
  },
  {
    ""part"": ""<jmp>"",
    ""category"": ""argument"",
    ""desc"": ""specify we're looking for jump instructions""
  }
]
"
Reload the current binary in read-write	o+	"
To reload a binary in read-write mode, we need a command that deals with file operations. Since we're working with an already opened file and want to modify its access mode, we should look for a command that handles file operations and has the capability to reopen files. The 'o' command family handles file operations, and adding '+' is a common modifier to indicate write permissions.
"	"
[
  {
    ""part"": ""o"",
    ""category"": ""file_operations"",
    ""desc"": ""The 'o' command family handles opening, closing and reopening files""
  },
  {
    ""part"": ""+"",
    ""category"": ""modifiers"",
    ""desc"": ""The '+' modifier is used to add write permissions when opening files""
  }
]
"
Show the current file's sections with their permissions.	iS	"
When working with binary files, we often need to understand the structure and permissions of different sections like .text, .data, etc. To get this information, we need to use information commands (i) and specifically query for Sections (S). This command is part of the binary analysis features and will display details about each section including their permissions (r/w/x).
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""Information commands are used to get details about the loaded binary""
  },
  {
    ""part"": ""S"",
    ""category"": ""sections"",
    ""desc"": ""Specifically shows section information, including addresses, sizes, and permissions""
  }
]
"
How do I list all register-based arguments of a function?	afvr @ sym.main	"
Looking at this function analysis question, we need to examine function variables, specifically the register-based arguments. The question is about function analysis (a), dealing with function variables (v), and specifically register-based ones (r). Since we want to list/show them, and it's targeted at a specific function (sym.main), this leads us to the afvr command, which is designed exactly for this purpose - analyzing function variables that are register-based.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis command family, needed for deep function inspection""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""specifies we're working with function-related commands""
  },
  {
    ""part"": ""v"",
    ""category"": ""variables"",
    ""desc"": ""indicates we want to work with function variables""
  },
  {
    ""part"": ""r"",
    ""category"": ""registers"",
    ""desc"": ""specifies we want register-based variables""
  },
  {
    ""part"": ""@"",
    ""category"": ""location"",
    ""desc"": ""specifies where to perform the operation""
  },
  {
    ""part"": ""<sym.main>"",
    ""category"": ""argument"",
    ""desc"": ""the target function to analyze""
  }
]
"
Execute a script named `fix_flags.r2`.	. fix_flags.r2	"
Looking at the question, we need to execute an external r2 script file named ""fix_flags.r2"". When thinking about executing scripts in radare2, the dot command (.) is used as it's designed specifically for interpreting and running scripts. This is similar to how ""source"" works in bash or ""."" in sh shells. The dot command is followed by the script filename to execute its contents.
"	"
[{
    ""part"": ""."",
    ""category"": ""script execution"",
    ""desc"": ""The dot command is used to execute external scripts""
}, {
    ""part"": ""<fix_flags.r2>"",
    ""category"": ""argument"",
    ""desc"": ""The filename of the script to be executed""
}]
"
Search for hexadecimal bytes `0xCAFEBABE` inside the binary.	/v4 0xCAFEBABE	"
Looking for a specific 4-byte value (0xCAFEBABE) in the binary. Since this is a 32-bit value (4 bytes), we need to use the value search command with the appropriate size. The search command in radare2 starts with '/', and since we're looking for a specific value of known size, we'll use the value search modifier 'v' with size '4' to search for a 32-bit value.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""Base search command in radare2""
  },
  {
    ""part"": ""v"",
    ""category"": ""search_type"",
    ""desc"": ""Search for a value of specific size""
  },
  {
    ""part"": ""4"",
    ""category"": ""size"",
    ""desc"": ""Size in bytes (32-bit value)""
  },
  {
    ""part"": ""<0xCAFEBABE>"",
    ""category"": ""argument"",
    ""desc"": ""The actual 32-bit value to search for""
  }
]
"
Visualize the call graph in an interactive ASCII art view.	agcv	"
Looking at the question, we need to visualize a call graph - that means we need to see how functions call each other. We want this in an interactive ASCII art format.

The command should start with 'a' since we're doing analysis. Then 'g' makes sense because we're creating a graph. The 'c' would specify we want a call graph (showing function calls). Finally, 'v' indicates we want the visual/interactive ASCII art mode rather than just static output.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used when working with function and code analysis""
    },
    {
        ""part"": ""g"",
        ""category"": ""graph"",
        ""desc"": ""graph generation subcommand, used for various types of graphs""
    },
    {
        ""part"": ""c"",
        ""category"": ""callgraph"",
        ""desc"": ""specifies we want a call graph showing function relationships""
    },
    {
        ""part"": ""v"",
        ""category"": ""visual"",
        ""desc"": ""switches to interactive visual mode with ASCII art representation""
    }
]
"
Change the endianness to big endian.	e cfg.bigendian=true	"
We need to modify how r2 handles byte ordering. Endianness determines how multi-byte values are interpreted - little endian reads least significant byte first, big endian reads most significant byte first. Since this is a configuration setting that affects how r2 interprets data, we'll use the 'e' command to modify the appropriate configuration variable.

Looking at the command structure, we need to set the cfg.bigendian configuration variable to true to switch to big endian mode. This is a fundamental setting that affects how r2 reads and displays data throughout the program.
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""config"", 
    ""desc"": ""evaluate/configure settings command""
  },
  {
    ""part"": ""cfg.bigendian="",
    ""category"": ""variable"",
    ""desc"": ""the configuration variable that controls byte ordering""
  },
  {
    ""part"": ""<true>"",
    ""category"": ""value"",
    ""desc"": ""boolean value to enable big endian mode""
  }
]
"
Compare the current binary with another binary `another.exe`.	!radiff2 $R2_FILE another.exe	"
You need to compare two binaries. The question is asking for binary diffing capabilities. Looking at the radare2 ecosystem, radiff2 is the specialized tool for binary diffing. Since we're already in an r2 session and have a file loaded, we can access the current file through the $R2_FILE environment variable and compare it with another.exe.

The ! command is used to execute shell commands from within radare2, which is exactly what we need to run radiff2 while keeping our current r2 session active.
"	"
[
  {
    ""part"": ""!"",
    ""category"": ""shell"",
    ""desc"": ""escape to shell to execute external command""
  },
  {
    ""part"": ""radiff2"",
    ""category"": ""tool"",
    ""desc"": ""binary diffing utility from radare2 framework""
  },
  {
    ""part"": ""$R2_FILE"",
    ""category"": ""variable"",
    ""desc"": ""environment variable containing current file path""
  },
  {
    ""part"": ""<another.exe>"",
    ""category"": ""argument"",
    ""desc"": ""target file to compare against""
  }
]
"
How do I display the stack trace in the debugger?	dbt	"
When debugging, one of the most important pieces of information is the stack trace - showing the sequence of function calls that led to the current execution point. Since this is a debugger-related operation, I'd look for commands starting with 'd' for debug. Within debug commands, 'b' often relates to breakpoints or backtrace/stack operations. The 't' would naturally extend this to mean ""trace"". This combination makes sense as a debugger backtrace command.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""debug commands are the main category for debugger operations""
    },
    {
        ""cmd"": ""b"",
        ""category"": ""backtrace"",
        ""desc"": ""within debug context, 'b' typically refers to backtrace/breakpoint operations""
    },
    {
        ""cmd"": ""t"",
        ""category"": ""trace"",
        ""desc"": ""specifies we want the trace/stack information rather than other backtrace operations""
    }
]
"
Rename a variable in the current function from `var1` to `counter`.	afvn counter	"
We need to rename a variable in the current function. This is a common analysis task, and since we're dealing with function variables, we'll be working with the function analysis commands. The command should be in the 'af' (analyze function) family since we're modifying function metadata. Within function analysis, we need to work with variables ('v' for variables), and specifically we want to handle the naming ('n' for name) of these variables.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""Analysis commands are used for understanding and modifying program structure""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""We're working with function-level operations""
  },
  {
    ""part"": ""v"",
    ""category"": ""variables"",
    ""desc"": ""Specifically dealing with function variables""
  },
  {
    ""part"": ""n"",
    ""category"": ""name"",
    ""desc"": ""The operation we want is renaming""
  },
  {
    ""part"": ""<counter>"",
    ""category"": ""argument"",
    ""desc"": ""The new name we want to give to the variable""
  }
]
"
How do you calculate the checksum of a basic block?	ph crc32 $Fs	"
To calculate a checksum of a basic block, we need a way to hash a specific amount of data. The basic block size is accessible through the $Fs variable, which represents the current function size. We want to calculate a hash, specifically CRC32, of this data block.

The 'ph' command is perfect for this as it's designed to calculate hashes of blocks of data. CRC32 is a common checksum algorithm that's good for detecting data corruption and generating quick checksums of blocks.
"	"
[
    {
        ""part"": ""p"", 
        ""category"": ""print"",
        ""desc"": ""print command is the base for many data output operations""
    },
    {
        ""part"": ""h"",
        ""category"": ""hash"",
        ""desc"": ""specifies we want to calculate a hash of data""
    },
    {
        ""part"": ""<crc32>"",
        ""category"": ""algorithm"",
        ""desc"": ""specifies the CRC32 hashing algorithm""
    },
    {
        ""part"": ""<$Fs>"",
        ""category"": ""variable"",
        ""desc"": ""uses the function size variable to determine how many bytes to hash""
    }
]
"
How do you find the hexadecimal pattern a0cc33?	/x a0cc33	"
Looking for a hexadecimal pattern in memory requires a search command. In radare2, the forward slash (/) is used for searching. Since we're looking for a specific hex pattern (a0cc33), we need to use the hex search variant. The pattern is already in hex format so we don't need any conversion.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""Base search command - tells r2 we want to find something""
  },
  {
    ""part"": ""x"",
    ""category"": ""format"",
    ""desc"": ""Specifies we're searching for a hexadecimal pattern""
  },
  {
    ""part"": ""<a0cc33>"",
    ""category"": ""argument"",
    ""desc"": ""The actual hex pattern we're looking for""
  }
]
"
Disable colors in the commands output.	e scr.color=0	"
To disable colors in radare2's output, we need to modify a configuration variable. The question specifically asks about colors in command output, which is a screen/display setting. In radare2, configuration variables are accessed using the 'e' command, and screen-related options typically start with 'scr.'. Since we want to turn off colors, we'll set the color variable to 0 (false/disabled).
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""evaluate/modify configuration variables""
  },
  {
    ""part"": ""scr.color"",
    ""category"": ""variable"",
    ""desc"": ""screen color configuration variable""
  },
  {
    ""part"": ""="",
    ""category"": ""operator"",
    ""desc"": ""assignment operator to set the value""
  },
  {
    ""part"": ""<0>"",
    ""category"": ""value"",
    ""desc"": ""disable colors by setting to false/zero""
  }
]
"
How to display the local variables in the current function?	afv	"
When working with functions in reverse engineering, we often need to analyze their local variables to understand the function's behavior. The question asks about displaying local variables, which is a function-level analysis task. Since we're dealing with function analysis, we'd start with commands under 'af' (analyze function), and since we want to see variables specifically, we'd need the variable subcommand 'v'.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used for extracting information from code""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""narrows down to function-specific analysis commands""
  },
  {
    ""part"": ""v"",
    ""category"": ""variables"",
    ""desc"": ""specifically targets function variables, which is what we want to display""
  }
]
"
Change the program counter to 0x5000	dr PC=0x5000	"
We need to modify a register value - specifically the program counter (PC). In assembly and debugging contexts, the program counter holds the address of the next instruction to be executed. To change register values in radare2, we use the 'dr' command which stands for 'debug registers'. The format is straightforward - we want to set the PC register to a specific value using the equals sign.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""debug commands are used to interact with program execution state""
  },
  {
    ""part"": ""r"",
    ""category"": ""registers"",
    ""desc"": ""register manipulation subcommand - allows viewing and modifying CPU registers""
  },
  {
    ""part"": ""<PC=0x5000>"",
    ""category"": ""arguments"", 
    ""desc"": ""sets the Program Counter (PC) register to the hexadecimal value 0x5000""
  }
]
"
Initialize the stack and register state for emulation	aeim	"
When working with ESIL emulation in radare2, we need to set up the environment before we can start emulating code. This involves initializing both the stack and registers to a known state. The command needs to be related to ESIL (e for ESIL) and needs to handle initialization (i for init) of memory (m for memory).
"	"
[
    {""part"": ""a"", ""category"": ""analysis"", ""desc"": ""analysis commands are used for deep inspection of code""},
    {""part"": ""e"", ""category"": ""esil"", ""desc"": ""indicates we're working with ESIL emulation""},
    {""part"": ""i"", ""category"": ""init"", ""desc"": ""initialization command to set up state""},
    {""part"": ""m"", ""category"": ""memory"", ""desc"": ""specifies we're dealing with memory initialization""}
]
"
How can I analyze all the symbols in a binary?	aa	"
When working with a binary, one of the first things we want to do is analyze it to understand its structure, functions, and symbols. The question asks for analyzing ""all"" symbols, which suggests we need a comprehensive analysis command. Looking at the analysis commands (starting with 'a'), we need something that performs a deep analysis of everything. The 'aa' command is perfect for this as it runs a comprehensive analysis that includes functions, basic blocks, and references.

This command is typically one of the first things you run after loading a binary in radare2, as it provides the foundation for further analysis by identifying and marking up the binary's key components.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis command prefix, used for all analysis operations""
  },
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""second 'a' indicates 'analyze all', making it perform a comprehensive analysis of the binary""
  }
]
"
Which option should I set to analyze consecutive functions to improve code coverage?	e anal.hasnext=true	"
When analyzing code, we want to maximize coverage to understand the program's flow better. The question asks about analyzing consecutive functions, which implies we want the analyzer to continue looking for functions that come one after another. The setting 'anal.hasnext=true' tells the analyzer to assume there's another function right after the current one ends, improving the function detection process by continuing analysis at the end of each function.

This is particularly useful when dealing with stripped binaries or code that doesn't have clear function boundaries. By enabling this option, r2 will be more aggressive in its function detection, assuming that code continues after each function ends rather than stopping analysis.
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""configuration command to set/get/list variables""
  },
  {
    ""part"": ""anal.hasnext"",
    ""category"": ""analysis"",
    ""desc"": ""specific configuration variable for controlling consecutive function analysis behavior""
  },
  {
    ""part"": ""=true"",
    ""category"": ""value"",
    ""desc"": ""boolean value to enable the consecutive function analysis feature""
  }
]
"
What target operating system (OS) is the current binary suposed to run?	e~^os[1]	"
The question asks about the target OS of the current binary. This requires checking the configuration/environment settings of r2. We need to find a setting related to the OS. Since we want to query configuration values, we'll use the 'e' command to evaluate/show config vars, and then filter the output to only show OS-related settings. The '~' grep operator with '^os' will match lines starting with ""os"" and [1] will select the second column which contains the value.
"	"
[
  {
    ""part"": ""e"", 
    ""category"": ""eval"",
    ""desc"": ""evaluate/show configuration variables""
  },
  {
    ""part"": ""~"",
    ""category"": ""filter"",
    ""desc"": ""grep operator to filter output""
  },
  {
    ""part"": ""^os"",
    ""category"": ""regex"",
    ""desc"": ""match lines starting with 'os'""
  },
  {
    ""part"": ""[1]"",
    ""category"": ""column_select"",
    ""desc"": ""select second column containing the value""
  }
]
"
How do I see all imports in the binary?	ii	"
When analyzing a binary, one of the key things to understand is what external functions it imports from other libraries. The imports give us insight into the binary's functionality and dependencies. To see all imports, we need a command that deals with binary information and specifically lists imports. Looking at the command categories, 'i' is for information/imports which makes sense as our starting point, and since we want to see imports specifically, another 'i' would narrow it down to imports.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""this is the main command for getting information about the binary""
  },
  {
    ""part"": ""i"",
    ""category"": ""imports"",
    ""desc"": ""specifically selects imports from all the possible information subcommands""
  }
]
"
What command lists all the strings in the binary?	iz	"
When looking for strings in a binary, we need a command that can identify and list all the printable character sequences. This is a common analysis task when reverse engineering binaries. The 'i' command family deals with getting information from opened files, and since strings are a type of information stored in the binary's data sections, we'll want to use a subcommand of 'i' that specifically handles strings. The 'z' subcommand is perfect for this as it focuses on string data.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""information command - used to get details about the loaded binary""
  },
  {
    ""part"": ""z"",
    ""category"": ""strings"",
    ""desc"": ""strings subcommand - specifically handles listing strings from data sections""
  }
]
"
How do I change the current address 12 instructions or opcodes forward?	so 12	"
When you want to move forward in a binary, you're essentially seeking to a new address. But instead of calculating the exact address, you want to move relative to the current position based on instruction count. Since instructions can have different sizes, you need a command that understands opcode lengths and can move forward by counting instructions rather than just bytes. The 'seek opcode' command is perfect for this, as it's designed to seek forward (or backward) by a specified number of instructions.
"	"
[
  {
    ""part"": ""s"", 
    ""category"": ""seek"",
    ""desc"": ""This is the base seek command - we need to change position""
  },
  {
    ""part"": ""o"",
    ""category"": ""opcode"",
    ""desc"": ""Specifies we want to seek by opcode count rather than bytes""
  },
  {
    ""part"": ""<12>"",
    ""category"": ""argument"",
    ""desc"": ""Number of opcodes to move forward (negative would move backward)""
  }
]
"
How do I display the control flow graph for the current function?	agf	"
When working with functions, we often want to visualize their control flow to understand the program's logic better. For the current function, we need a graph command that specifically handles function visualization. Looking at the command help, we can see that 'ag' is for graphs, and we need something that shows basic blocks and their connections within a function, which points to 'agf'.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used for understanding program structure""
    },
    {
        ""cmd"": ""g"",
        ""category"": ""graph"",
        ""desc"": ""graph generation and visualization commands""
    },
    {
        ""cmd"": ""f"",
        ""category"": ""function"",
        ""desc"": ""specifies we want the basic blocks function graph""
    }
]
"
What command disassembles the current function?	pdf	"
To disassemble a function, I need to first consider what we're working with - we want to see the assembly instructions for a function that's already been analyzed. Since we want to print something, it makes sense to start with 'p' for print. Then, since we want to see disassembly, 'd' is the natural choice. Finally, since we specifically want to see a function's disassembly, 'f' for function completes the command. This command requires prior analysis of the function using 'af' to work properly.
"	"
[
    {""part"": ""p"", ""category"": ""print"", ""desc"": ""start with print command since we want to output something""},
    {""part"": ""d"", ""category"": ""disassembly"", ""desc"": ""add disassembly modifier to print assembly instructions""},
    {""part"": ""f"", ""category"": ""function"", ""desc"": ""specify we want to disassemble the current function rather than a fixed number of instructions""}
]
"
How can I print a hexdump of 64 bytes at the current address?	px 64	"
Looking to print data in hexadecimal format, so I need a print command that handles hex output. The current address is implied since no specific address is given, and we need exactly 64 bytes of data. The 'px' command is perfect for this as it shows hexdump output and takes a length parameter. The length parameter directly follows the command to specify how many bytes to display.
"	"
[
    {
        ""part"": ""p"",
        ""category"": ""print"",
        ""desc"": ""print command - the base for all data visualization commands""
    },
    {
        ""part"": ""x"",
        ""category"": ""hex"",
        ""desc"": ""specifies hexadecimal output format, showing both hex and ASCII representation""
    },
    {
        ""part"": ""<64>"",
        ""category"": ""arguments"",
        ""desc"": ""number of bytes to print in the hexdump""
    }
]
"
How to scan and analyze the binary for references to the sym.imp.puts symbol?	/r sym.imp.puts	"
When looking for references to a specific symbol, especially an imported function like puts, we need to search through the binary to find all code locations that reference this symbol. The question specifically asks about sym.imp.puts which is the import table entry for the puts function. The /r command is perfect for this as it's designed to search for references to addresses or symbols in the code.

This is a common reverse engineering task when you want to find all places where a particular function is called, which is essential for understanding the program's behavior and data flow.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""initiate a search command""
  },
  {
    ""part"": ""r"",
    ""category"": ""references"",
    ""desc"": ""specify we want to search for references/xrefs""
  },
  {
    ""part"": ""<sym.imp.puts>"",
    ""category"": ""argument"",
    ""desc"": ""the symbol we're searching references for - in this case the puts import""
  }
]
"
How to start debugging the current binary?	ood	"
When working with a binary in r2, we often need to restart debugging or begin debugging after analysis. The question asks about starting debug - not attaching to a process or launching a new one, but debugging the current binary that's loaded. This suggests we need the ""reopen"" functionality, specifically in debug mode. Since we're already in r2 with a file loaded, we want to reopen the same file but in debug mode.
"	"
[
    {""part"": ""o"", ""category"": ""file_ops"", ""desc"": ""file operations - we need to work with the opened file""},
    {""cmd"": ""o"", ""category"": ""reopen"", ""desc"": ""second 'o' indicates reopen - we want to work with same file""},
    {""cmd"": ""d"", ""category"": ""debug"", ""desc"": ""specify debug mode for reopening""}
]
"
How can I run the program and attach the debugger?	doo	"
When debugging a program, you often need to restart it from scratch while keeping the debugger attached. The question asks about running and attaching, which implies we need a debug-oriented operation. Looking at the debug commands (starting with 'd'), we find 'doo' which is specifically designed to reopen in debug mode. This makes perfect sense as a way to (re)run the program while keeping the debugger attached.

The command is essentially a shortcut for ""debug reopen"", which is exactly what we want to do - restart the program in debug mode.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""debug commands are the main category for debugger operations""
    },
    {
        ""part"": ""o"",
        ""category"": ""open"",
        ""desc"": ""operations related to opening/reopening files""
    },
    {
        ""part"": ""o"",
        ""category"": ""open"",
        ""desc"": ""second 'o' specifically indicates reopen operation in debug mode""
    }
]
"
What command executes a single instruction in debugging mode?	ds	"
When debugging, we often need to execute code step by step. The most basic stepping operation is executing a single instruction. This is commonly known as ""single stepping"" or ""step into"" in debuggers. Since we're dealing with debugging operations in radare2, we'll be using the 'd' (debug) namespace, and since we want to step through code, 's' for step makes logical sense. The command `ds` is the basic debugging step command that executes exactly one instruction.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""debug namespace - we're performing a debugging operation""
  },
  {
    ""part"": ""s"",
    ""category"": ""step"",
    ""desc"": ""step command - execute one instruction at a time""
  }
]
"
What command quits radare2?	q	"
The user wants to know how to exit radare2. This is a fundamental operation in any interactive program, and typically 'q' stands for 'quit'. Looking at the help documentation, under the 'q' command section, we can see it's exactly what we need - a simple 'q' command that quits the program. There are variations like q! for force quit, but the basic 'q' is the standard way to exit cleanly.
"	"
[{
  ""part"": ""q"",
  ""category"": ""program control"",
  ""desc"": ""The quit command - a universal convention in command-line programs for exiting cleanly""
}]
"
How can I list all symbols in the binary?	is	"
When dealing with binaries, symbols are crucial pieces of information that can include function names, variables, and other named elements. The question asks for listing ""all symbols"", so we need a command that can display symbol information. In radare2, the 'i' command family handles information about the binary, and since we specifically want symbols, we'd use 'is' which is dedicated to symbol listing.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""information command - used to get various details about the loaded binary""
  },
  {
    ""part"": ""s"",
    ""category"": ""symbols"",
    ""desc"": ""specifies we want to list symbols - this is a natural extension of the info command when we want symbol information""
  }
]
"
How can I display registers in debugging mode?	dr	"
When debugging, one of the most fundamental needs is to examine register values to understand the program's state. Looking at the command help, we need a command that deals with debugging and specifically register inspection. Since we're working with registers in debug mode, the natural combination would be 'd' for debug followed by 'r' for registers - this gives us the basic register display functionality.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""Debug commands are the primary way to interact with debugging functionality""
  },
  {
    ""part"": ""r"",
    ""category"": ""registers"",
    ""desc"": ""Register subcommand specifically handles register operations, displaying current register values when used alone""
  }
]
"
What command lists all classes and methods?	ic	"
When dealing with classes and methods, we need a way to list or inspect them. Since we're looking at classes specifically, we should look at class-related commands. The 'i' command family deals with getting information from the opened file, and since we want class information, 'ic' would be the natural choice as it combines information retrieval with class inspection.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""information command to get data from the opened file""
  },
  {
    ""cmd"": ""c"",
    ""category"": ""classes"",
    ""desc"": ""specifies we want to list class information, including methods""
  }
]
"
How do I show the current instruction pointer	dr?PC	"
You want to know the value of the program counter (PC) register. Since this is about registers, we need the register commands, which start with 'dr'. Since we want to query a specific register value, we need the question mark syntax to show the value of a specific register. The PC is a special register that points to the current instruction being executed.
"	"
[
  {
    ""part"": ""d"", 
    ""category"": ""debug"",
    ""desc"": ""debug commands are used to interact with program execution state""
  },
  {
    ""part"": ""r"",
    ""category"": ""registers"", 
    ""desc"": ""register manipulation subcommand""
  },
  {
    ""part"": ""?"",
    ""category"": ""query"",
    ""desc"": ""query the value of a specific register""
  },
  {
    ""part"": ""<PC>"",
    ""category"": ""argument"",
    ""desc"": ""program counter register name""
  }
]
"
What command shows detailed memory mappings when debugging?	dm	"
When debugging, one of the most important things to understand is how memory is laid out - where different segments are mapped, their permissions, and sizes. Since this is about memory and we're debugging, we need a command that deals with memory maps in the debug context. Looking through the commands, 'dm' is the dedicated memory map command under the debug category, which will show us a detailed view of all memory regions in the target process.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""debug commands are the main category for anything debugging related""
    },
    {
        ""part"": ""m"",
        ""category"": ""memory"",
        ""desc"": ""memory maps subcommand, specifically shows memory regions and their attributes""
    }
]
"
How do I find out the current calling convention of the binary?	e anal.cc	"
When working with binaries, understanding the calling convention is crucial for analysis since it determines how function parameters are passed and how the stack is managed. To get this information, we need to look at the analysis settings, specifically the calling convention configuration. The command needs to query the current value of the analysis-related calling convention setting.

The command structure follows the pattern of accessing configuration variables in radare2, which uses the 'e' command for examining/setting eval variables. Since this relates to analysis and specifically calling conventions, we'd want to look at 'anal.cc'.
"	"
[
    {
        ""part"": ""e"",
        ""category"": ""eval"",
        ""desc"": ""command to get/set config variables""
    },
    {
        ""part"": ""anal.cc"",
        ""category"": ""config_variable"",
        ""desc"": ""specific configuration variable for analysis calling convention""
    }
]
"
How do I display flags in JSON format?	fj	"
You want to see the flags in the binary, but in a machine-readable format. When working with data in radare2, JSON output is often used for scripting and automation. The base command to list flags is 'f', and in radare2's convention, adding 'j' as a suffix typically converts the output to JSON format.
"	"
[
    {
        ""part"": ""f"",
        ""category"": ""flags"",
        ""desc"": ""base command for working with flags - shows list of flags""
    },
    {
        ""part"": ""j"",
        ""category"": ""output_format"",
        ""desc"": ""modifier to output in JSON format, following r2's common pattern of adding j for JSON output""
    }
]
"
How can I print zero-terminated strings in memory?	ps	"
When analyzing binaries or memory dumps, one of the most common tasks is finding and displaying strings. In memory, strings typically end with a null byte (0x00), which is why they're called ""zero-terminated"" or ""null-terminated"" strings. 

The question asks specifically about printing these zero-terminated strings, so we need a command that will read memory until it hits a null byte and interpret those bytes as a string. Looking at the print commands (p), we need something specific to strings (s).
"	"
[
    {
        ""part"": ""p"",
        ""category"": ""print"",
        ""desc"": ""Base print command - we want to output something""
    },
    {
        ""part"": ""s"",
        ""category"": ""strings"",
        ""desc"": ""String-specific print mode that reads until null terminator""
    }
]
"
What command shows all exported symbols?	iE	"
When working with binaries, we often need to see what symbols are exported - these are the functions and variables that the binary makes available for other programs to use. This is particularly useful for analyzing libraries and understanding their API surface. We need a command that deals with binary information (i) and specifically exports (E).
"	"
[
    {
        ""part"": ""i"",
        ""category"": ""information"",
        ""desc"": ""information command - used for getting details about the binary""
    },
    {
        ""cmd"": ""E"",
        ""category"": ""exports"",
        ""desc"": ""specifically targets exported symbols, distinguishing them from other binary information like imports or sections""
    }
]
"
How do I list all exported symbols?	iE	"
When dealing with binaries, we often need to see what symbols are exported - these are the functions and variables that the binary makes available for other programs to use. In radare2, this would be part of the binary information commands, which all start with 'i'. Since we specifically want exports, which are a fundamental part of binary analysis, there should be a specific command for it. Looking at the available 'i' commands, 'iE' stands out as it's specifically designed to list exported symbols.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""This is the main command for getting information about the binary""
  },
  {
    ""part"": ""E"",
    ""category"": ""exports"",
    ""desc"": ""Specifically targets exported symbols, capital E distinguishes it from other info subcommands""
  }
]
"
How do I show the list of imports with JSON output?	iij	"
When dealing with imports in binary analysis, we need the imports command which starts with 'i'. Since we want specifically imports (not exports or other binary info), we need another 'i'. And since we want JSON output, which is a common pattern in radare2 commands, we need 'j' at the end. This follows the common radare2 pattern where adding 'j' to a command gives JSON output.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""info"",
    ""desc"": ""base command for getting information about the binary""
  },
  {
    ""part"": ""i"",
    ""category"": ""imports"",
    ""desc"": ""specifies we want to list imports specifically""
  },
  {
    ""part"": ""j"",
    ""category"": ""output_format"",
    ""desc"": ""modifier to get the output in JSON format instead of plain text""
  }
]
"
How can I remove all breakpoints in the debugger?	db-*	"
To remove all breakpoints in a debugger, we need a command that deals with breakpoints and has a way to remove all of them at once. Looking at the debug commands, 'db' is for breakpoints, and many radare2 commands use '-*' as a suffix to mean ""remove all"". This follows the common pattern in radare2 where '*' often means ""all"" and '-' means ""remove"" or ""delete"".
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""debug command namespace, since we're working with debugger functionality""
  },
  {
    ""part"": ""b"",
    ""category"": ""breakpoint"",
    ""desc"": ""breakpoint subcommand - handles breakpoint operations""
  },
  {
    ""part"": ""-"",
    ""category"": ""operator"",
    ""desc"": ""removal operator - indicates we want to delete""
  },
  {
    ""part"": ""*"",
    ""category"": ""modifier"",
    ""desc"": ""wildcard modifier - indicates we want to affect all breakpoints""
  }
]
"
How do I remove all flags?	f-*	"
Looking at the task of removing all flags, I know flags are essential markers in r2 that point to specific addresses. When you want to clean up or reset the workspace, removing all flags is a common operation. The command should be in the flags namespace (f), and since we want to remove them all, we need a removal operator (-) and a wildcard (*) to target all flags.
"	"
[
  {
    ""part"": ""f"", 
    ""category"": ""flags"",
    ""desc"": ""flags namespace - handles all flag operations""
  },
  {
    ""part"": ""-"",
    ""category"": ""operators"",
    ""desc"": ""removal operator for flags""
  },
  {
    ""part"": ""*"",
    ""category"": ""wildcards"",
    ""desc"": ""wildcard to select all flags""
  }
]
"
What command prints the current stack pointer?	dr?SP	"
To print a register value, we need to use register-related commands. The question asks specifically about the stack pointer (SP), which is a special register. The command needs to both access registers and query a specific value. Looking at the help, 'dr' is for registers and adding '?' allows querying specific register values. SP is the common name for stack pointer register.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""debug commands are used to interact with program state""
  },
  {
    ""part"": ""r"",
    ""category"": ""registers"",
    ""desc"": ""register manipulation subcommand""
  },
  {
    ""part"": ""?"",
    ""category"": ""query"",
    ""desc"": ""show value of given register""
  },
  {
    ""part"": ""<SP>"",
    ""category"": ""argument"",
    ""desc"": ""stack pointer register name""
  }
]
"
How do I change the burrent block size to 512 bytes?	b 512	"
When working with binary analysis, you often need to control how much data you're working with at once. The block size is a fundamental concept in radare2 that determines how many bytes are processed in various commands. To change it to 512 bytes, we need the block size command, which is one of the most basic and frequently used commands. The block size affects commands like print (p) and write (w), so it's important to be able to set it precisely.
"	"
[
    {
        ""part"": ""b"",
        ""category"": ""block"",
        ""desc"": ""The block command is used to manipulate block size""
    },
    {
        ""part"": ""<512>"",
        ""category"": ""argument"",
        ""desc"": ""The decimal number of bytes to set as the new block size""
    }
]
"
How to extend the file size with 128 bytes more?	r+128	"
When we need to modify the size of a file in r2, we need to think about resizing operations. The question asks about extending the file by adding 128 bytes, so we need a command that can increase the file size. Looking at the 'r' command which handles resizing, we can see it accepts a size parameter. Since we want to add bytes (not remove them), we use the '+' operator followed by the number of bytes we want to add.
"	"
[
  {
    ""part"": ""r"",
    ""category"": ""resize"",
    ""desc"": ""resize command is used for file size modifications""
  },
  {
    ""part"": ""+"",
    ""category"": ""operator"",
    ""desc"": ""plus sign indicates we want to increase the size""
  },
  {
    ""part"": ""<128>"",
    ""category"": ""argument"",
    ""desc"": ""number of bytes to add to the current file size""
  }
]
"
How do I chang the size of the file to 512KB?	r 512K	"
To change the file size, we need a command that can resize files. Looking at the command list, 'r' is the resize command that can expand or truncate files. The question asks for 512KB, and the command accepts size arguments. The 'K' suffix is a common way to specify kilobytes in Unix-like systems, making '512K' a valid size specification. This is a straightforward resize operation to set the exact file size.
"	"
[
  {
    ""part"": ""r"",
    ""category"": ""file operations"",
    ""desc"": ""resize command that can expand or truncate files""
  },
  {
    ""part"": ""<512K>"",
    ""category"": ""size argument"",
    ""desc"": ""size specification in kilobytes, using K suffix for multiplication by 1024""
  }
]
"
What command prints a fortune message in radare2?	fo	"
Looking for a command to display fortune messages - these are typically fun/humorous messages shown in Unix-like systems. Since it's asking for a simple output feature and the answer is 'fo', this must be related to the flags ('f') commands section, with 'o' likely standing for ""oracle"" or ""output"". Looking at the help, we can see it's listed under the flags section as 'fo' with the description ""show fortunes"".
"	"
[
  {
    ""part"": ""f"",
    ""category"": ""flags"",
    ""desc"": ""This is under the flags command category as it's a simple output feature integrated into the flags system""
  },
  {
    ""part"": ""o"",
    ""category"": ""output"",
    ""desc"": ""The 'o' subcommand specifically handles the fortune output functionality""
  }
]
"
How to perform a step into using the ESIL emulation?	aes	"
When working with ESIL (Evaluable Strings Intermediate Language) in radare2, we need a command that performs a single step of emulation. Since we're working with ESIL specifically, we need to use the 'ae' (Analysis ESIL) command set. The step operation is one of the most basic debugging operations, and in ESIL context, it's represented by 's' for step, making 'aes' the logical command to perform a single step in ESIL emulation mode.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used for code analysis tasks""
    },
    {
        ""part"": ""e"",
        ""category"": ""esil"",
        ""desc"": ""indicates we're working with ESIL operations""
    },
    {
        ""part"": ""s"",
        ""category"": ""step"",
        ""desc"": ""performs a single step operation in ESIL emulation""
    }
]
"
What command disassembles the hexadecimal bytes `90c3` for x86-32?	pad 90c3 @e:asm.arch=x86@e:asm.bits=32	"
We need to disassemble some hex bytes, specifically 90c3 for x86 32-bit architecture. The question includes the settings for architecture and bits, but we need the core command to disassemble hex bytes.

Looking at the command reference, we need a way to ""print disassembly"". The 'pa' command family handles assembly/disassembly operations, and specifically 'pad' is for disassembling hex bytes directly.

The command makes sense because we want to Print Assembly Disassembly of the given hex bytes, with the architecture parameters specified after it.
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""print command - we want to output something""
  },
  {
    ""part"": ""a"",
    ""category"": ""assembly"",
    ""desc"": ""assembly subcommand - we're dealing with assembly code""
  },
  {
    ""part"": ""d"",
    ""category"": ""disassembly"", 
    ""desc"": ""disassembly operation - we want to convert hex to assembly""
  },
  {
    ""part"": ""<90c3>"",
    ""category"": ""argument"",
    ""desc"": ""hex bytes to disassemble""
  }
]
"
How to nop one instruction in the current address?	wao nop @ $$	"
We need to modify an instruction at the current position to become a NOP. This is an assembly operation that needs to modify the existing instruction, not just write raw bytes. Since we're working with the current instruction at the current address ($$), we need a command that can handle assembly operations. The 'wa' command family handles assembly writing, and 'wao' specifically handles assembly operation modifications of existing instructions. The 'nop' argument tells it exactly what operation we want to perform.
"	"
[
  {""part"": ""w"", ""category"": ""write"", ""desc"": ""We need to write/modify something in memory""},
  {""part"": ""a"", ""category"": ""assembly"", ""desc"": ""We're dealing with assembly level operations""},
  {""part"": ""o"", ""category"": ""operation"", ""desc"": ""We want to modify an existing instruction with an operation""},
  {""part"": ""<nop>"", ""category"": ""argument"", ""desc"": ""The specific operation we want to perform - convert to NOP""},
  {""part"": ""@"", ""category"": ""address"", ""desc"": ""Specifies where to perform the operation""},
  {""part"": ""<$$>"", ""category"": ""current_seek"", ""desc"": ""References the current position in the file/memory""}
]
"
What command writes the 32bit value 0x123 in little endian to the given address?	wv4 0x123 @ address	"
When we need to write a specific value to memory, we need a write command that understands data types and endianness. Looking at the 'w' commands, we see several variants but 'wv' specifically handles writing values of different sizes with proper handling of endianness. Since we need to write a 32-bit value (4 bytes), we'll use 'wv4'. The '@' syntax is used in r2 to specify the target address for the operation.
"	"
[
  {
    ""part"": ""w"",
    ""category"": ""write"",
    ""desc"": ""write command is needed to modify memory""
  },
  {
    ""part"": ""v"",
    ""category"": ""value"",
    ""desc"": ""specifies we want to write a value with proper size and endianness handling""
  },
  {
    ""part"": ""4"",
    ""category"": ""size"",
    ""desc"": ""indicates we want to write a 32-bit (4-byte) value""
  },
  {
    ""part"": ""<0x123>"",
    ""category"": ""argument"",
    ""desc"": ""the actual value we want to write""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""specifies that what follows is the target address""
  },
  {
    ""part"": ""<address>"",
    ""category"": ""argument"",
    ""desc"": ""the memory address where we want to write the value""
  }
]
"
How to disable the virtual addressing to work with physical offsets?	e io.va=false	"
When working with binary analysis, sometimes we need to work with the raw file offsets (physical) rather than the virtual addresses that would be used when the program is loaded into memory. This is especially important when analyzing firmware or raw binary data where virtual addressing might not make sense.

The key here is controlling how radare2 interprets addresses. By default, it uses virtual addressing (io.va=true), but we need to disable this to work directly with file offsets.

The solution involves using the eval (e) command to modify a configuration variable that controls this behavior.
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""The eval command is used to get/set configuration variables""
  },
  {
    ""part"": ""io.va"",
    ""category"": ""config_variable"",
    ""desc"": ""The specific configuration variable that controls virtual addressing (va) in input/output operations""
  },
  {
    ""part"": ""="",
    ""category"": ""assignment"",
    ""desc"": ""Assignment operator to set the value""
  },
  {
    ""part"": ""<false>"",
    ""category"": ""value"",
    ""desc"": ""Boolean value to disable virtual addressing""
  }
]
"
How to use virtual addressing defined by the IO maps?	e io.va=true	"
When working with binaries in radare2, we often need to switch between physical addresses (raw file offsets) and virtual addresses (where the code/data would be loaded in memory). The question is asking about enabling virtual addressing mode.

This is a fundamental setting that affects how addresses are interpreted throughout r2. When enabled, all commands will use virtual addresses as defined by the IO maps rather than physical file offsets. This is especially important when analyzing executables that would be loaded at specific memory addresses.

Looking at the command structure, we need to modify an eval variable (e) related to IO (io) that controls virtual addressing (va). Setting it to true enables this feature.
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""modify configuration variables""
  },
  {
    ""part"": ""io.va"",
    ""category"": ""config"",
    ""desc"": ""IO virtual addressing configuration variable""
  },
  {
    ""part"": ""=true"",
    ""category"": ""value"",
    ""desc"": ""set the variable to true/enabled""
  }
]
"
Search for aligned 32bit values that represent valid mapped addresses in the current memory layout?	aav	"
To find valid addresses in memory, we need to analyze the current memory layout and look for values that could be pointers. Since we're looking for 32-bit aligned values that map to valid addresses, this is a typical use case for automatic analysis to find and validate addresses. The command should perform an analysis that looks for these potential references in the binary.

The 'aa' prefix is commonly used for analysis commands, and since we're specifically looking for values that could be valid addresses in memory, we need something that will scan and validate addresses. This points to using the 'aav' command which is designed exactly for this purpose - analyzing and finding valid address references.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis command prefix, indicating we want to perform some kind of analysis""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""second 'a' indicates an automated or all-encompassing analysis operation""
    },
    {
        ""part"": ""v"",
        ""category"": ""validation"",
        ""desc"": ""specifies that we want to validate values as addresses, looking specifically for valid mapped addresses""
    }
]
"
How can I seek to the end of the binary?		"
When we need to seek to the end of a binary, we need a way to reference the file size or end point. Looking through the seek commands, we can see that 'sg/sG' allows seeking to the beginning or end of a section or file. The uppercase G variant is what we want since it seeks to the end.
"	"
[
  {
    ""part"": ""s"", 
    ""category"": ""seek"",
    ""desc"": ""seek command to change current position""
  },
  {
    ""part"": ""G"",
    ""category"": ""location"",
    ""desc"": ""uppercase G specifies seeking to end of section/file rather than beginning""
  }
]
"
How do I seek to the symbol named 'sym.boo' in radare2?	s sym.boo	"
Looking at the seek command, we need to move the cursor to a specific symbol. The most direct way to do this is using the seek command 's' followed by the symbol name. Since we want to go to 'sym.boo', we just need to specify that symbol name directly after the seek command. This is more efficient than first getting the address of the symbol and then seeking to that address.
"	"
[
  {
    ""part"": ""s"",
    ""category"": ""seek"",
    ""desc"": ""The seek command is used to change the current position in the file""
  },
  {
    ""part"": ""<sym.boo>"",
    ""category"": ""argument"",
    ""desc"": ""The symbol name to seek to, radare2 will resolve this to its address automatically""
  }
]
"
How can I dump the current block (defined with the `b` command) to `file.bin`?	wtf file.bin	"
I need to write data from the current block to a file. This involves writing ('w') to a file ('f'), but specifically the current block. Looking at the write commands, I see 'wt' is for writing to files, and 'wtf' allows specifying both filename and size, which is perfect since we want to write the current block size.
"	"
[
  {
    ""part"": ""w"",
    ""category"": ""write"",
    ""desc"": ""write operations are needed to output data""
  },
  {
    ""part"": ""t"",
    ""category"": ""file"",
    ""desc"": ""write to file specifically, as shown by the 'wt' help showing 'Write to file'""
  },
  {
    ""part"": ""f"",
    ""category"": ""file_with_size"",
    ""desc"": ""specify file and optionally size - will use current block size if not specified""
  },
  {
    ""part"": ""<file.bin>"",
    ""category"": ""argument"",
    ""desc"": ""target filename to write the block to""
  }
]
"
What command displays the program entrypoint address?	ie	"
To find the program's entrypoint address, we need to look at binary information commands. The 'i' command family handles binary information and metadata. Since we specifically want the entrypoint, which is a basic program property, we'd want a specific subcommand that deals with entrypoints. Looking at the help, 'ie' is exactly what we need - it shows entrypoint information.
"	"
[
  {
    ""part"": ""i"", 
    ""category"": ""info"",
    ""desc"": ""binary information commands are under 'i'""
  },
  {
    ""part"": ""e"",
    ""category"": ""entrypoint"",
    ""desc"": ""specifically shows entrypoint information""
  }
]
"
How do I list all available commands for help?	?*	"
To list all available commands, we need a way to show the help menu in its entirety. The question mark (?) is universally known as the help symbol in radare2. Since we want to see ALL commands, we need a way to tell radare2 to show everything. In radare2's syntax, the asterisk (*) is commonly used as a wildcard or ""show all"" modifier. Combining these two makes perfect sense - we want to see all (*)  help (?) entries.
"	"
[
    {
        ""part"": ""?"", 
        ""category"": ""help"",
        ""desc"": ""Access the help system""
    },
    {
        ""part"": ""*"",
        ""category"": ""modifier"",
        ""desc"": ""Show all possible entries in detail, often used to get full output""
    }
]
"
How can I perform all the experimental analysis?	aaaaa	"
To perform the deepest and most experimental analysis in radare2, we need to understand the progression of analysis depth. The basic analysis command is 'aa', but we want ALL possible analysis, including experimental ones. Looking at the help, we see that adding more 'a' letters increases the analysis depth - 'aaa' is deeper than 'aa', 'aaaa' adds experimental iterations, and 'aaaaa' refines the analysis even further to find more functions. Since we want everything possible analyzed, including experimental features, we'll use 'aaaaa' which does the maximum level of analysis.
"	"
[
    {
        ""part"": ""a"", 
        ""category"": ""analysis"",
        ""desc"": ""base analysis command""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""second 'a' makes it analyze all""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""third 'a' performs deeper analysis""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""fourth 'a' adds experimental iterations""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""fifth 'a' refines analysis to find more functions""
    }
]
"
How can I analyze the program with complete non-experimental techniques?	aaaa	"
When analyzing a program in radare2, we want to start with the most comprehensive but stable analysis. The question specifically asks for non-experimental techniques, which tells me we need something thorough but reliable.

The base command for analysis is 'aa', but that's often too basic. We want something more comprehensive that includes deeper analysis. Looking at the analysis commands, 'aaaa' performs deeper analysis than 'aaa' but stops short of the experimental 'aaaaa'. This is perfect because it adds extra analysis iterations while staying within proven techniques.
"	"
[
    {
        ""part"": ""a"", 
        ""category"": ""analysis"",
        ""desc"": ""Base analysis command indicating we want to analyze""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""Second 'a' makes it analyze all functions automatically""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""Third 'a' adds deeper analysis with common techniques""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""Fourth 'a' adds additional analysis iterations but stays non-experimental""
    }
]
"
What command enumerates all the memory maps that associate virtual addressing ranges to physical offsets and its associated file?	om	"
When dealing with memory analysis, we need to understand how virtual addresses map to physical ones in a binary or process. The question asks about memory maps enumeration, which is a core functionality when analyzing binaries or debugging processes. Since we're looking for memory mappings, we'd want something that shows the relationship between virtual and physical addresses. In radare2, memory operations are typically handled by the 'o' (open/operations) commands, and specifically memory maps would be under 'om' since it deals with memory mapping operations.
"	"
[
  {
    ""part"": ""o"",
    ""category"": ""file_ops"",
    ""desc"": ""This is the base command for file operations and I/O in radare2""
  },
  {
    ""cmd"": ""m"",
    ""category"": ""memory"",
    ""desc"": ""Specifies we want to work with memory maps, which handle virtual to physical address translations""
  }
]
"
How do I write the value 0x32 in little endian 16bit?	wv2 0x32	"
To write a specific value in memory with a specific size and endianness, we need a write command that handles numeric values. Looking at the available write commands, 'wv' stands out as it's specifically designed for writing values with size control. The question asks for 16-bit (2 bytes) in little endian, and the value is 0x32. The command needs to specify both the size (2 bytes) and the value.
"	"
[
    {""part"": ""w"", ""category"": ""write"", ""desc"": ""We need to write to memory""},
    {""part"": ""v"", ""category"": ""value"", ""desc"": ""Write a value with size control""},
    {""part"": ""2"", ""category"": ""size"", ""desc"": ""Specify 16-bit (2 byte) size""},
    {""part"": ""<0x32>"", ""category"": ""argument"", ""desc"": ""The actual value to write""}
]
"
How can I retrieve the number of functions?	aflc	"
When dealing with functions in radare2, we need a way to count them. The question asks for a count of functions, so we need to use the function listing command with a modifier that gives us just the count. Looking at the function analysis commands, 'af' is for analyzing functions, 'afl' lists them, and adding 'c' gives us just the count instead of the full listing.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used for examining code""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""specifies we're working with functions""
    },
    {
        ""part"": ""l"",
        ""category"": ""list"",
        ""desc"": ""indicates we want to list functions""
    },
    {
        ""part"": ""c"",
        ""category"": ""count"",
        ""desc"": ""modifies the list command to show only the count""
    }
]
"
What is the name of the current working file?	o.	"
When we need information about the current file we're working with, we need a command that shows current file information. The 'o' command family handles file operations, and using just 'o.' will show the current filename. This is a simple way to get the name of the file currently being analyzed without any additional information.
"	"
[
  {
    ""part"": ""o"",
    ""category"": ""files"",
    ""desc"": ""file operation command, manages opened files""
  },
  {
    ""part"": ""."",
    ""category"": ""current"",
    ""desc"": ""modifier to show current filename""
  }
]
"
How do I list all the files opened?	o	"
When working with files in radare2, we need to keep track of which files are currently opened. The most basic way to do this would be to use the 'o' command without any parameters, as this is the command category for handling files and IO operations. Since we just want to list the opened files without any additional operations like opening new ones or closing existing ones, the bare 'o' command would be sufficient.
"	"
[{
    ""part"": ""o"",
    ""category"": ""files"",
    ""desc"": ""The 'o' command family handles file operations, and when used alone it lists all opened files. This is the most direct way to get a simple list of what files are currently opened in the session""
}]
"
How can I disassemble the function at address 0x401000?	pdf @ 0x401000	"
Looking at this question, we need to disassemble a function at a specific address. This means we need a command that:
1. Handles disassembly ('d' commands)
2. Works with functions ('f' related)
3. Shows the full output
4. Can work with a specific address

The `pdf` command is perfect for this - it's specifically designed to ""print disassembly of function"". The `@ 0x401000` syntax is the standard r2 way to specify an address to operate on. This combination will disassemble the entire function that starts at address 0x401000.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command, the base for many output operations""
  },
  {
    ""part"": ""d"",
    ""category"": ""disassembly"",
    ""desc"": ""specifies we want disassembly output""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""indicates we want the full function disassembly""
  },
  {
    ""part"": ""@ <0x401000>"",
    ""category"": ""address"",
    ""desc"": ""specifies the target address where the function starts""
  }
]
"
How can I analyze a function in the current seek address?	af	"
When analyzing a binary, one of the most fundamental tasks is identifying and analyzing functions. If I'm already at a particular address (the current seek) and I want to analyze what I believe is a function there, I need a command that will perform function analysis. This would involve identifying the function boundaries, basic blocks, variables, etc.

Looking through the commands, 'a' is for analysis and 'f' is typically used for function-related operations. Combining them makes perfect sense for function analysis at the current position.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""Analysis command - the primary prefix for all analysis operations""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""Function-specific analysis - tells r2 to analyze the current position as a function""
    }
]
"
Analyze function in the current address and the called ones recursively	afr	"
Looking at the question, we need to analyze a function, but not just the current one - we need to go deeper and analyze all the functions it calls too. This is a recursive operation starting from the current function.

In radare2, function analysis commands start with 'af', and since we want to do this recursively, we need something that will traverse the call graph. The 'r' suffix makes perfect sense here as it indicates recursive operation.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""Analysis commands always start with 'a' in radare2""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""Function-specific analysis commands use 'af' prefix""
  },
  {
    ""part"": ""r"",
    ""category"": ""recursive"",
    ""desc"": ""The 'r' suffix indicates recursive operation through the function's call graph""
  }
]
"
How do I step over the next instruction during debugging?	dso	"
When debugging, we often need to execute instructions without diving into function calls. The question asks about stepping over, which means we want to execute the next instruction completely (including any function call it might make) and stop at the instruction right after it. This is different from stepping into, which would enter any function call.

Looking at the debug commands (d prefix for debug), we need something related to stepping (s for step), and specifically stepping over (o for over). This maps perfectly to the 'dso' command.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""Debug command prefix - we're performing a debugging operation""
  },
  {
    ""cmd"": ""s"",
    ""category"": ""step"",
    ""desc"": ""Step command - we want to execute one instruction""
  },
  {
    ""cmd"": ""o"",
    ""category"": ""over"",
    ""desc"": ""Over modifier - specifies we want to step over rather than into""
  }
]
"
How can I view the hexdump of 64 bytes at the current position?	px 64	"
Looking at this question, we need to display data in hexadecimal format at the current position. The key elements are ""hexdump"" and a specific length of ""64 bytes"". In radare2, hexadecimal viewing is typically done with the 'p' command family for printing/displaying data, and 'x' is specifically for hexadecimal output. Since we need to specify an exact number of bytes, we'll simply append that number after the command.
"	"
[
    {
        ""part"": ""p"",
        ""category"": ""print"",
        ""desc"": ""print command is the main way to display data in r2""
    },
    {
        ""cmd"": ""x"",
        ""category"": ""format"",
        ""desc"": ""specifies hexadecimal output format for the print command""
    },
    {
        ""cmd"": ""<64>"",
        ""category"": ""argument"",
        ""desc"": ""specifies the exact number of bytes to display in the hexdump""
    }
]
"
"How do I search for the opcode ""mov eax, ebx""?"	'/a mov eax, ebx`	"
To search for a specific assembly instruction, we need a search command that understands assembly syntax. Looking at the search commands (/), we want to find something that can handle assembly patterns. The regular search won't work because we're not looking for bytes or strings, but for a specific instruction pattern. The /a command is specifically designed for searching assembly instructions, which is perfect for finding ""mov eax, ebx"" in the code.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""base search command - needed to find anything in the binary""
  },
  {
    ""part"": ""a"",
    ""category"": ""assembly"",
    ""desc"": ""specifies we want to search for assembly instructions rather than bytes or strings""
  },
  {
    ""part"": ""<mov eax, ebx>"",
    ""category"": ""argument"",
    ""desc"": ""the actual assembly instruction we're searching for""
  }
]
"
"How do I assemble and search for the bytes as instructions for ""mov x19, x1""?"	/a mov x19,x1	"
To find a specific instruction in memory, we need to search for its bytes. But since we have the assembly instruction ""mov x19, x1"", we need to use the assembly-aware search command. This is different from a regular byte search because it needs to understand ARM64 assembly syntax and convert it to the proper bytes before searching.

The search command in radare2 is / and since we want to search for assembly, we need the /a variant which is specifically designed to search for instructions by their assembly representation. This will automatically handle the conversion from assembly text to bytes and then search for those bytes in memory.
"	"
[
    {
        ""part"": ""/"", 
        ""category"": ""search"",
        ""desc"": ""Base search command - we need to find something in memory""
    },
    {
        ""part"": ""a"",
        ""category"": ""assembly"",
        ""desc"": ""Specifies we want to search for assembly instructions instead of raw bytes""
    },
    {
        ""part"": ""<mov x19,x1>"",
        ""category"": ""arguments"",
        ""desc"": ""The actual ARM64 instruction we want to find""
    }
]
"
"How can I write the string ""Hello"" at the current position?"	'w Hello	"
Looking at this question, we need to write data at the current position in memory. The most basic operation would be writing a string. Since we're dealing with basic data manipulation, we'd want a basic write command. Looking at the write commands (starting with 'w'), we can see several variations, but for a simple string write, the basic 'w' command followed by the string is what we need. The space between 'w' and the string is required to separate the command from its argument.
"	"
[
  {
    ""part"": ""w"",
    ""category"": ""write"",
    ""desc"": ""Basic write command, selected because we need to write data at current position""
  },
  {
    ""part"": ""<Hello>"",
    ""category"": ""argument"",
    ""desc"": ""The string to be written at current position""
  }
]
"
"How do I open a file called ""test.bin"" in radare2?"	o test.bin	"
To open a file in radare2, I need a command that handles file operations. Looking at the command list, 'o' is the main command for opening files and managing file descriptors. The simplest form of opening a file is just 'o' followed by the filename. Since we want to open ""test.bin"" in read-only mode (which is the default), we don't need any additional flags or modifiers.
"	"
[
  {
    ""part"": ""o"",
    ""category"": ""files"",
    ""desc"": ""The 'o' command handles all file operations in radare2, including opening, listing and closing files""
  },
  {
    ""part"": ""<test.bin>"",
    ""category"": ""argument"",
    ""desc"": ""The target file to be opened, passed as a direct argument to the open command""
  }
]
"
How can I display information about the opened file?	i	"
When you want to get information about a file that's currently opened in radare2, you need a command that shows metadata and basic properties of the file. The 'i' command is perfect for this as it's designed specifically to show information about the opened binary - things like file format, architecture, entry points, sections, etc. It's similar to what 'file' command shows in Unix but with much more detail specific to binary analysis.
"	"
[{
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""The 'i' command is the main information command in radare2, showing details about the currently opened file. It's a natural choice when you need to understand what kind of file you're analyzing.""
}]
"
Decompile the current function using r2ghidra	pdg	"
Looking at a function's decompiled code requires first understanding what we're looking at (a function) and then converting it to a higher-level representation. The 'p' command family handles printing/displaying data, and since we want to see the function in decompiled form, we need something that can handle complex code analysis. The 'pdg' command specifically targets decompilation using the r2ghidra decompiler, which is a powerful integration of the Ghidra decompiler into radare2. This is perfect for seeing the current function in C-like code instead of assembly.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""We start with print because we want to display/output something""
  },
  {
    ""part"": ""d"",
    ""category"": ""disassembly"",
    ""desc"": ""This indicates we're working with code rather than raw data""
  },
  {
    ""part"": ""g"",
    ""category"": ""ghidra"",
    ""desc"": ""This specifies we want to use the r2ghidra decompiler for high-level code output""
  }
]
"
How to decompile the function named sym.main with r2dec	pdd @ sym.main	"
Looking at this question about decompiling a specific function, I know we need to:
1. Print something (p command)
2. Since it mentions r2dec, we need the decompiler command (d)
3. We want the default decompiler output (d again)
4. We need to specify where to decompile, which is sym.main

This makes sense because r2dec is a decompiler plugin for radare2, and we want to decompile a specific function by its symbol name. The command builds up logically: first print, then use decompiler, then specify default output format, and finally target the specific function.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""start with print command as we want to output something""
  },
  {
    ""part"": ""d"",
    ""category"": ""decompile"",
    ""desc"": ""specify we want to use the decompiler functionality""
  },
  {
    ""part"": ""d"",
    ""category"": ""decompile_default"",
    ""desc"": ""use default decompiler output format (r2dec)""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""specify where to apply the command""
  },
  {
    ""part"": ""<sym.main>"",
    ""category"": ""symbol"",
    ""desc"": ""the function to decompile by its symbol name""
  }
]
"
"How do I assemble the instruction ""nop"" at the current position?"	wa nop	"
To assemble an instruction at the current position, we need a command that writes ('w') to memory, but specifically for assembly instructions. Looking at the command reference, we can see that 'wa' is exactly what we need - it's the write assembly command that takes an instruction as an argument. Since we want to write a ""nop"" instruction, we simply provide that as the argument. This will use the current architecture settings (asm.arch and asm.bits) to assemble the correct nop instruction for the target architecture.
"	"
[
  {
    ""part"": ""w"",
    ""category"": ""write"",
    ""desc"": ""We need to write to memory""
  },
  {
    ""part"": ""a"",
    ""category"": ""assembly"",
    ""desc"": ""Specifies we want to write assembly code rather than raw bytes""
  },
  {
    ""part"": ""<nop>"",
    ""category"": ""argument"",
    ""desc"": ""The actual instruction to assemble and write - in this case a no-operation instruction""
  }
]
"
I need to set the block size to 128 bytes.	b 128	"
When working with binary analysis, you often need to control how much data you're working with at once. The block size is a fundamental concept in radare2 that determines how many bytes are processed in various commands. To set this to 128 bytes, we need a command that modifies the block size. Looking at the command set, 'b' is the command that handles block size operations. Since we want to set it to a specific value (128), we can just provide that number directly as an argument.
"	"
[
  {
    ""part"": ""b"",
    ""category"": ""block"",
    ""desc"": ""Command for manipulating block size - this is the primary command for setting or showing block size""
  },
  {
    ""part"": ""<128>"",
    ""category"": ""arguments"",
    ""desc"": ""The specific size in bytes we want to set the block to""
  }
]
"
How do I display the entropy of the file?	p=e	"
When dealing with file analysis, entropy is a key metric that helps identify encrypted, compressed, or random data sections. We need a command that can show this information visually. Looking at the commands, we need something in the print category since we want to display data. The `p=` command family deals with data visualization in bars/graphs format, and specifically the 'e' modifier is used for entropy calculations.
"	"
[
    {
        ""part"": ""p"", 
        ""category"": ""print"",
        ""desc"": ""print command is the base for displaying data""
    },
    {
        ""part"": ""="",
        ""category"": ""visualization"",
        ""desc"": ""equals sign indicates we want a visual representation, usually in bar format""
    },
    {
        ""part"": ""e"",
        ""category"": ""analysis"",
        ""desc"": ""specifies entropy calculation mode for the visualization""
    }
]
"
I want to see the comments at the current address.	CC.	"
When dealing with comments in reverse engineering, you often want to see what notes or annotations exist at your current position. The current address is often referred to with a dot (.) in radare2. Since we're looking for comments, which are metadata about the code, and specifically want to see them at our current location, we need a command that combines the comment functionality with current position reference.
"	"
[
    {""part"": ""C"", ""category"": ""metadata"", ""desc"": ""Comments are a type of metadata in r2, so we start with the capital C command""},
    {""part"": ""C"", ""category"": ""comments"", ""desc"": ""Double C specifies we want to work with code comments specifically""},
    {""part"": ""."", ""category"": ""location"", ""desc"": ""The dot indicates we want to see comments at the current seek position""}
]
"
I want to list all cross-references to address 0x401000.	axt @ 0x401000	"
You want to find all references to a specific address (0x401000). This is a common reverse engineering task when you want to understand who calls or uses this address. In radare2, cross-references (xrefs) are tracked during analysis and can be displayed to show where this address is referenced from. The command should show all code/data references to this memory location.

The natural path is:
1. We need an analysis command (a)
2. Within analysis, we want to work with xrefs (x) 
3. Specifically we want to see references ""to"" this address (t)
4. Finally, we specify the target address using @ syntax
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis command prefix - we're working with analyzed data""
  },
  {
    ""part"": ""x"",
    ""category"": ""xrefs"",
    ""desc"": ""cross-references subcommand - we want to work with xrefs""
  },
  {
    ""part"": ""t"",
    ""category"": ""direction"",
    ""desc"": ""references 'to' this address (as opposed to 'from')""
  },
  {
    ""part"": ""@ <0x401000>"",
    ""category"": ""addressing"",
    ""desc"": ""specify the target address we want to examine""
  }
]
"
How can I evaluate the expression 0x400 + 0x200?	?v 0x400 + 0x200	"
When we need to evaluate mathematical expressions in radare2, we need a way to calculate values without modifying anything in the program. The question is asking about adding two hexadecimal numbers, so we need a command that can handle hex math and show the result.

The natural choice is the '?' command family since it handles various helper operations, and specifically the 'v' subcommand which is designed for evaluating expressions. This command will take the rest of the line as a math expression and compute the result.
"	"
[
  {
    ""part"": ""?"",
    ""category"": ""help/math"",
    ""desc"": ""The question mark command family handles calculations and conversions""
  },
  {
    ""part"": ""v"",
    ""category"": ""evaluate"",
    ""desc"": ""The 'v' subcommand specifically evaluates mathematical expressions""
  },
  {
    ""part"": ""<0x400 + 0x200>"",
    ""category"": ""expression"",
    ""desc"": ""The hexadecimal expression to be evaluated, using standard math operators""
  }
]
"
I need to see the help for the 'af' command.	af?	"
You want to understand the 'af' command, which is related to function analysis in radare2. This is a fundamental command for analyzing functions in a binary. The question mark suffix (?) is the universal help modifier in radare2, so you're asking for the help documentation for this specific command. Looking at the command structure, 'af' would be 'analyze function', and adding the '?' will show all the available subcommands and options for function analysis.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""The analysis command category, which handles all analysis operations""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""Specifies we want to work with functions within the analysis context""
    },
    {
        ""part"": ""?"",
        ""category"": ""help"",
        ""desc"": ""The help modifier that shows documentation for the af command""
    }
]
"
How can I print the value of the EAX register?	dr?eax	"
When working with registers in a debugger, we need a command that deals with register operations. The question asks specifically about printing a register value, which is a common debugging task. Looking at the command reference, 'dr' is the main command for CPU registers. To query a specific register's value, we need to use the question mark syntax to show the value of a given register.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""debug commands are used for register operations""
  },
  {
    ""part"": ""r"",
    ""category"": ""registers"",
    ""desc"": ""register manipulation subcommand""
  },
  {
    ""part"": ""?"",
    ""category"": ""query"",
    ""desc"": ""show value of specific register""
  },
  {
    ""part"": ""<eax>"",
    ""category"": ""argument"",
    ""desc"": ""the specific register name we want to query""
  }
]
"
I want to view 32 bytes in hexadecimal at address 0x500000.	px 32 @ 0x500000	"
You want to examine memory contents at a specific address in hexadecimal format. The natural approach would be:
1. First, we need a command to print/display data - 'p' is the base command for printing
2. Since we want hexadecimal output, 'x' is the modifier we need for hex dump
3. We need to specify how many bytes we want - that's the '32'
4. Finally, we need to tell r2 where to look - that's the @ symbol followed by the address 0x500000
"	"
[
    {""part"": ""p"", ""category"": ""print"", ""desc"": ""base command for printing data""},
    {""part"": ""x"", ""category"": ""format"", ""desc"": ""specifies hexadecimal output format""},
    {""part"": ""<32>"", ""category"": ""length"", ""desc"": ""number of bytes to display""},
    {""part"": ""@"", ""category"": ""address"", ""desc"": ""at specific address indicator""},
    {""part"": ""<0x500000>"", ""category"": ""address"", ""desc"": ""the memory address to examine""}
]
"
How do I list the sections with their computed entropy value?	iS entropy	"
To analyze sections in a binary, we need information about the sections first. Since we want to see section information AND their entropy values, we need to use the section listing command with some additional parameters. The entropy calculation will help identify potentially encrypted or compressed sections, which typically have higher entropy values than regular code or data sections.
"	"
[
  {
    ""part"": ""i"", 
    ""category"": ""information"",
    ""desc"": ""info command is used to get information about the loaded binary""
  },
  {
    ""part"": ""S"",
    ""category"": ""sections"", 
    ""desc"": ""capital S specifies we want section information rather than symbols or other binary info""
  },
  {
    ""part"": ""<entropy>"",
    ""category"": ""argument"",
    ""desc"": ""parameter that tells iS to include entropy calculations for each section""
  }
]
"
I need to continue execution until the next syscall.	dcs	"
When debugging, we often want to analyze how a program interacts with the operating system through syscalls. To do this efficiently, we need a way to run the program until it hits the next syscall. This is similar to other continue-until commands, but specifically for syscalls.

Looking at the debug commands ('d' prefix), we need something that combines continue ('dc') with syscall awareness. The 's' suffix makes sense here as it relates to syscalls, making 'dcs' an intuitive choice to continue execution until we hit the next syscall.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""This is a debugging command as we're controlling execution""
  },
  {
    ""part"": ""c"",
    ""category"": ""continue"",
    ""desc"": ""The 'continue' subcommand, as we want to resume execution""
  },
  {
    ""part"": ""s"",
    ""category"": ""syscall"",
    ""desc"": ""Specifies we want to stop at the next syscall""
  }
]
"
How can I list all the processes in the system?	dp	"
When looking for process-related operations in a debugger, we need a way to see what's running in the system. Since we're dealing with processes, the natural place to look is under the debugging commands, which typically start with 'd'. Within debugging operations, process management commands are grouped under 'p' for process. Looking at the help, 'dp' without additional arguments lists the current process and its children, which is exactly what we need to see all processes.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""Debug commands are the main category for process interaction""
  },
  {
    ""part"": ""p"",
    ""category"": ""process"",
    ""desc"": ""Process-specific commands within debugging context to manage and view process information""
  }
]
"
How can I list all the threads of the current debugged process?	dpt	"
When debugging a process, we often need to inspect its threads. Since this is a debugging operation, we need a command that starts with 'd' for debug. The process-related commands in the debugger typically use 'dp', and since we're specifically looking for threads, we need something that indicates 'thread' after that. Looking at the debug commands, 'dpt' stands out as the perfect match for listing threads of the current process.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""debug commands always start with d""
    },
    {
        ""part"": ""p"",
        ""category"": ""process"",
        ""desc"": ""process-related debug commands use dp prefix""
    },
    {
        ""part"": ""t"",
        ""category"": ""threads"",
        ""desc"": ""t specifies we want to work with threads""
    }
]
"
How do I disable the comments in the disassembly view?	e asm.comments = false	"
When looking at disassembly in radare2, comments can sometimes clutter the view. To control this kind of display feature, we need to use the configuration system ('e' command). Since this is specifically about assembly comments, it would be under the 'asm' namespace. The setting needs to be turned off, so we set it to 'false'.
"	"
[
    {
        ""part"": ""e"",
        ""category"": ""eval"",
        ""desc"": ""configure/evaluate radare2 configuration variables""
    },
    {
        ""part"": ""asm.comments"",
        ""category"": ""config_var"",
        ""desc"": ""the specific variable that controls assembly comments""
    },
    {
        ""part"": ""="",
        ""category"": ""operator"",
        ""desc"": ""assignment operator to set the value""
    },
    {
        ""part"": ""<false>"",
        ""category"": ""value"",
        ""desc"": ""boolean value to disable the feature""
    }
]
"
How can I rename a flag from 'flag.old' to 'flag.new'?	fr flag.new flag.old	"
When working with flags in radare2, you often need to rename them to make them more meaningful or correct. The question is asking about renaming a flag, so I'm looking for flag-related commands. The 'f' namespace in radare2 handles flags. Since we're renaming, we need the 'r' subcommand for rename. The order of arguments is important here - in radare2's fr command, the new name comes first, followed by the old name, similar to the Unix 'mv' command syntax.
"	"
[
    {
        ""part"": ""f"",
        ""category"": ""flags"",
        ""desc"": ""flag commands are used for managing flags""
    },
    {
        ""part"": ""r"",
        ""category"": ""rename"",
        ""desc"": ""rename subcommand for flags""
    },
    {
        ""part"": ""<flag.new>"",
        ""category"": ""arguments"",
        ""desc"": ""new name for the flag""
    },
    {
        ""part"": ""<flag.old>"",
        ""category"": ""arguments"", 
        ""desc"": ""existing flag name to be renamed""
    }
]
"
I need to change the endianness to big endian.	e cfg.bigendian = true	"
When working with binary analysis, endianness is crucial as it determines how multi-byte values are interpreted. The question asks about changing to big endian, which means we need to modify a configuration setting. In radare2, configuration changes are made using the 'e' (eval) command, followed by the variable name and value. Since endianness is a binary choice (true/false), and we want big endian, we'll set it to true. The configuration variable for endianness in radare2 is 'cfg.bigendian'.
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""The eval command is used to get/set configuration variables""
  },
  {
    ""part"": ""cfg.bigendian"",
    ""category"": ""config"",
    ""desc"": ""The specific configuration variable that controls endianness""
  },
  {
    ""part"": ""="",
    ""category"": ""operator"",
    ""desc"": ""Assignment operator to set the value""
  },
  {
    ""part"": ""<true>"",
    ""category"": ""value"",
    ""desc"": ""Boolean value to enable big endian mode""
  }
]
"
How do I continue execution until the function 'main' is executed?	dcu main	"
When debugging, we often want to quickly get to the main() function without stepping through initialization code. We need a command that will:
1. Continue execution (not step)
2. Stop at a specific address/function
3. Be part of the debug commands

The solution is to use the debug continue until (dcu) command, which lets us continue execution until we reach a specific address or function name.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""debug commands are used for controlling program execution""
  },
  {
    ""part"": ""c"", 
    ""category"": ""continue"",
    ""desc"": ""continue execution rather than single stepping""
  },
  {
    ""part"": ""u"",
    ""category"": ""until"",
    ""desc"": ""specifies we want to continue until a condition is met""
  },
  {
    ""part"": ""<main>"",
    ""category"": ""argument"",
    ""desc"": ""the function name we want to continue execution until""
  }
]
"
I want to see the usage of the 'px' command.	px?	"
You want to understand how to use the hexadecimal print command 'px'. This is a fundamental command in radare2 for viewing memory contents in hex format. Since you added the '?' suffix, you're specifically asking for help/usage information about this command. This is a common pattern in radare2 where appending '?' to any command shows its help information.

The natural path to this command comes from:
1. Needing to view memory contents
2. Wanting it in hexadecimal format
3. Looking for the print command variants
"	"
[
    {
        ""part"": ""p"", 
        ""category"": ""print"",
        ""desc"": ""Print command - base command for all data printing operations""
    },
    {
        ""part"": ""x"",
        ""category"": ""format"",
        ""desc"": ""Specifies hexadecimal output format""
    },
    {
        ""part"": ""?"",
        ""category"": ""help"",
        ""desc"": ""Request help/usage information for the command""
    }
]
"
"How can I search for a wide string (utf-16) ""hello""?"	/w hello	"
When searching in binary files, we often need to handle different string encodings. The question asks about searching for a wide string, which typically means UTF-16 where each character is represented by 2 bytes with nulls between them. 

For example, ""hello"" in UTF-16 would be represented as ""h\0e\0l\0l\0o\0"". Since we're doing a search operation (which uses the / command in radare2), we need a specific modifier to handle wide strings.
"	"
[
    {
        ""part"": ""/"",
        ""category"": ""search"",
        ""desc"": ""This is the base search command in radare2""
    },
    {
        ""part"": ""w"",
        ""category"": ""modifier"",
        ""desc"": ""Specifies wide-string search mode (UTF-16)""
    },
    {
        ""part"": ""<hello>"",
        ""category"": ""argument"",
        ""desc"": ""The string to search for, which will be automatically converted to wide format""
    }
]
"
How to scan the memory for known magic file headers	/m@e:search.align=4	"
To scan memory for magic file headers, we need a search command that specifically looks for magic bytes. Since we're dealing with file formats and magic numbers, which are specific byte patterns at the start of files, we need the search command (/), and specifically the magic variant. The @e:search.align=4 part is an important configuration to align the search on 4-byte boundaries, which is common for many file formats.

Looking at the search command options, /m stands out as it's specifically designed for ""search for known magic patterns"". This makes perfect sense since file formats are identified by their magic numbers at specific offsets.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""base search command to find patterns in memory""
  },
  {
    ""part"": ""m"",
    ""category"": ""magic"",
    ""desc"": ""specifies we want to search for magic patterns/signatures""
  },
  {
    ""part"": ""@e:search.align=4"",
    ""category"": ""configuration"",
    ""desc"": ""tells the search to align on 4-byte boundaries for better accuracy with file formats""
  }
]
"
How can I enable the IO write cache layer to avoid modifying the real file?	e io.cache = true	"
When working with binary files in reverse engineering, it's often important to make modifications without affecting the original file - this is where a write cache comes in handy. The question asks about enabling this cache layer, which is a fundamental configuration option in radare2.

This is clearly a configuration setting (as indicated by the 'e' command prefix) related to IO operations, specifically for caching write operations. Setting this to true will make all write operations happen in memory first rather than being written directly to disk.
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""The eval command is used to get/set configuration variables""
  },
  {
    ""part"": ""io.cache"",
    ""category"": ""config_var"",
    ""desc"": ""The specific configuration variable for input/output caching""
  },
  {
    ""part"": ""="",
    ""category"": ""operator"",
    ""desc"": ""Assignment operator to set the value""
  },
  {
    ""part"": ""<true>"",
    ""category"": ""value"",
    ""desc"": ""Boolean value to enable the cache feature""
  }
]
"
I want to quickly quit radare2 right now.	q!	"
You need to exit radare2 immediately without any prompts or confirmations. This is similar to how vim handles force-quit with q!. Looking at the quit commands, we see that q! is exactly what we need - it will force quit without asking any questions about saving state or confirming the action.
"	"
[
  {
    ""part"": ""q"", 
    ""category"": ""quit"",
    ""desc"": ""The base quit command - tells r2 we want to exit""
  },
  {
    ""part"": ""!"", 
    ""category"": ""modifier"",
    ""desc"": ""Force modifier - tells r2 to quit immediately without prompts""
  }
]
"
How do I undo the last seek operation?	s-	"
When navigating through a binary in radare2, you often need to seek to different addresses to analyze different parts of the code or data. But sometimes you want to go back to where you were before - just like hitting the ""back"" button in a web browser. The most intuitive way to do this would be to have an ""undo"" operation for seeks. This is exactly what we need here - to undo the last seek operation and go back to the previous position.
"	"
[
  {
    ""part"": ""s"", 
    ""category"": ""seek"",
    ""desc"": ""The seek command is used for all navigation operations""
  },
  {
    ""part"": ""-"",
    ""category"": ""undo"",
    ""desc"": ""The minus symbol is commonly used to represent 'undo' or 'go back' operations, making this an intuitive choice for undoing the last seek""
  }
]
"
I want to dump all the strings into a strings.txt file	iz > strings.txt	"
You want to extract all strings from the binary and save them to a file. Let's think about this:
1. First we need a command to list strings - that's the 'iz' command which shows strings in data sections
2. Then we need to redirect that output to a file - that's where the '>' operator comes in
3. The combination gives us a simple way to dump all strings to strings.txt
"	"
[
  {
    ""part"": ""i"", 
    ""category"": ""info"",
    ""desc"": ""information command group, used for getting data about the binary""
  },
  {
    ""part"": ""z"",
    ""category"": ""strings"",
    ""desc"": ""specifically for listing strings in data sections""
  },
  {
    ""part"": "">"",
    ""category"": ""redirection"",
    ""desc"": ""shell redirection operator to save output to file""
  },
  {
    ""part"": ""<strings.txt>"",
    ""category"": ""argument"",
    ""desc"": ""output filename where strings will be saved""
  }
]
"
How can I set a hardware breakpoint to stop the execution when the process writes anything at address 0x400800?	dbw 0x400800	"
To stop execution when a process writes to a specific memory address, we need a breakpoint - but not just any breakpoint. Since we want to catch memory writes, we need a hardware breakpoint specifically configured for write access. Hardware breakpoints are more efficient than software breakpoints for monitoring memory access and don't modify the program's code.

Looking at the debugging commands, we can see that 'dbw' is the exact command we need - it sets up a watchpoint (hardware breakpoint) that triggers on memory writes to the specified address. This is exactly what's needed to monitor write operations at 0x400800.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""we need a debug command since we're dealing with execution control""
    },
    {
        ""part"": ""b"",
        ""category"": ""breakpoint"",
        ""desc"": ""indicates we're working with breakpoints""
    },
    {
        ""part"": ""w"",
        ""category"": ""watch"",
        ""desc"": ""specifies this is a watchpoint for memory writes""
    },
    {
        ""part"": ""<0x400800>"",
        ""category"": ""address"",
        ""desc"": ""the memory address to monitor for writes""
    }
]
"
I want to see the value of the address 0x400500 in decimal.	?vi [0x400500]	"
You want to convert a hexadecimal address to its decimal representation. This is a common task when working with different number bases in reverse engineering. The natural approach is to use the calculator functionality in radare2, which is accessed through the '?' command. Since we specifically want to evaluate a value and see it in decimal (integer) format, we need the 'v' modifier for value and 'i' for integer output.
"	"
[
  {
    ""part"": ""?"",
    ""category"": ""calculator"",
    ""desc"": ""access r2's built-in calculator/evaluator""
  },
  {
    ""cmd"": ""v"",
    ""category"": ""value"",
    ""desc"": ""indicate we want to evaluate and show the actual value""
  },
  {
    ""cmd"": ""i"",
    ""category"": ""integer"",
    ""desc"": ""specify that we want the output in decimal integer format""
  },
  {
    ""cmd"": ""<0x400500>"",
    ""category"": ""argument"",
    ""desc"": ""the hexadecimal address we want to convert""
  }
]
"
I need to list all the variables in the current function.	afv	"
When dealing with functions in reverse engineering, understanding the variables is crucial for analysis. The question asks for listing variables in the current function, so I know I need a command that deals with function analysis ('a' commands) and specifically function variables. The function must be already analyzed for this to work. The natural progression would be: analyze ('a') -> function ('f') -> variables ('v').
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used for extracting information from code""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""narrows down to function-specific analysis commands""
  },
  {
    ""part"": ""v"",
    ""category"": ""variables"",
    ""desc"": ""targets the variables within the function context""
  }
]
"
"How can I search disassemble the whole section and filter the lines matching ""eax"""	output pd $SS @ $S ~eax	"
Looking at this question, we need to disassemble a whole section and find specific register usage. Let's break it down:

1. We need to disassemble (`pd` command) 
2. We need to cover the whole section (using section size with `$SS`)
3. We need to do this at the section start (`$S`)
4. Finally, we need to filter for ""eax"" occurrences

This makes sense because `pd` is for print disassembly, and using the section variables ensures we cover the exact section boundaries. The grep operator `~` at the end filters for our target register.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command is the base for viewing content""
  },
  {
    ""part"": ""d"",
    ""category"": ""disassembly"",
    ""desc"": ""specifies we want to see disassembled instructions""
  },
  {
    ""part"": ""<$SS>"",
    ""category"": ""variables"",
    ""desc"": ""section size variable to determine how many bytes to disassemble""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""specifies where to perform the operation""
  },
  {
    ""part"": ""<$S>"",
    ""category"": ""variables"",
    ""desc"": ""section start address variable""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output""
  },
  {
    ""part"": ""<eax>"",
    ""category"": ""argument"",
    ""desc"": ""the string to filter for in the output""
  }
]
"
Where is the current section address?	?v $S	"
When working with binary analysis, we often need to know where the current section starts. The question asks for the current section address, which means we need a command that will print a value (?v) related to the section ($S). The $S variable in radare2 holds the current section offset, and using ?v will display its value in a readable format.

The combination of ?v (print value) with $S (section variable) gives us exactly what we need - the address where the current section begins.
"	"
[
  {
    ""part"": ""?"",
    ""category"": ""help/evaluation"",
    ""desc"": ""evaluate expression or show help""
  },
  {
    ""part"": ""v"",
    ""category"": ""value"",
    ""desc"": ""print value in current address or from expression""
  },
  {
    ""part"": ""$S"",
    ""category"": ""variables"",
    ""desc"": ""built-in variable for current section offset""
  }
]
"
How to find out the size of the current section?	?v $SS	"
To find the size of the current section, we need a command that will print a value (?v) and we want to use one of the special variables available in radare2. Looking at the documentation, $SS is a special variable that represents the current section size. This makes perfect sense as a two-step process:

1. First, we need to print a value using ?v
2. Then, we need to reference the section size using $SS

The ?v command is specifically designed to compute expressions and show their values, making it perfect for displaying the value of the $SS variable.
"	"
[
  {
    ""part"": ""?"",
    ""category"": ""help/evaluate"",
    ""desc"": ""evaluate expressions and values""
  },
  {
    ""part"": ""v"",
    ""category"": ""value"",
    ""desc"": ""print the numeric value of an expression""
  },
  {
    ""part"": ""$SS"",
    ""category"": ""variables"",
    ""desc"": ""special variable representing the current section size""
  }
]
"
How can I find functions that call 'main'?	axt sym.main	"
When looking for references to a function, particularly 'main', we need to find cross-references (xrefs) to that symbol. The process is:
1. We need a command that deals with cross-references
2. We want to find things that point TO main, not FROM main
3. We need to specify the target as sym.main

The 'ax' command family handles cross-references, and 't' is used to find references TO a particular address or symbol. This combination will show all code locations that reference (call) the main function.
"	"
[
    {""part"": ""a"", ""category"": ""analysis"", ""desc"": ""analysis commands are used for examining code relationships""},
    {""part"": ""x"", ""category"": ""xrefs"", ""desc"": ""cross-reference subcommands to find code relationships""},
    {""part"": ""t"", ""category"": ""to"", ""desc"": ""find references TO the target (rather than from)""},
    {""part"": ""<sym.main>"", ""category"": ""argument"", ""desc"": ""the symbol name we're looking for references to""}
]
"
I want to view the hexpair string representation of the next 64 bytes.	p8 64	"
When you want to view data in hex format, you start with the print commands (p). Since you specifically want hexpairs, which are the raw bytes represented in base16 (hex) format without any additional formatting or spacing, you need the specialized print command for hexpairs which is p8. The number 64 specifies how many bytes you want to see. This is a common way to quickly inspect raw binary data in a compact hex format.
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""Print command - the base for all data visualization""
  },
  {
    ""part"": ""8"",
    ""category"": ""format"",
    ""desc"": ""Specifies hexpair format - a compact way to show raw bytes in hex""
  },
  {
    ""part"": ""<64>"",
    ""category"": ""argument"",
    ""desc"": ""Number of bytes to print in hexpair format""
  }
]
"
How do I define a structure type in radare2?	'td struct myStruct { int a; char b; };	"
To define a structure type, we need a command that deals with types ('t' commands) and specifically with defining or declaring them. Looking at the type commands, we need something that can take a string input containing C-style type definitions. The 'td' command is perfect for this as it allows loading types from a string, which is exactly what we need when defining a structure.
"	"
[
  {
    ""part"": ""t"", 
    ""category"": ""types"",
    ""desc"": ""types system command - we're working with data types""
  },
  {
    ""part"": ""d"",
    ""category"": ""define"",
    ""desc"": ""define/load types from string input - allows entering C syntax type definitions""
  },
  {
    ""part"": ""<struct myStruct { int a; char b; }>;"",
    ""category"": ""arguments"",
    ""desc"": ""C syntax structure definition containing the actual struct members""
  }
]
"
How do I define an enum type in radare2?	'td enum myEnum { NONE, ONE, TWO, LAST };	"
To define a type in radare2, we need to use the type-related commands. Since we specifically want to define an enum, we need a command that can define types. Looking at the 't' commands, we can see that 't' is for types and 'td' is specifically for loading types from a string. This makes sense because we're providing the enum definition as a C-like string that needs to be parsed and loaded into radare2's type system.

The command is straightforward - we're using the type definition command and passing it a C-style enum declaration. The command will parse this and add it to radare2's type system for later use in analysis.
"	"
[
  {
    ""part"": ""t"",
    ""category"": ""types"",
    ""desc"": ""type management is the main category we need since we're defining a type""
  },
  {
    ""part"": ""d"",
    ""category"": ""define"",
    ""desc"": ""the 'd' subcommand allows loading types from a string definition""
  },
  {
    ""part"": ""<enum myEnum { NONE, ONE, TWO, LAST }>"",
    ""category"": ""arguments"",
    ""desc"": ""the C-style enum definition to be parsed and loaded""
  }
]
"
How do I search for the string 'hello' ignoring case?	/i hello	"
We need to search for a string but we want to ignore whether it's uppercase or lowercase. Looking at the search commands (/), we need something that handles case-insensitive searches. The base search command is / and looking through the options, /i specifically mentions ""search for string ignoring case"". This is exactly what we want, followed by the string we're searching for.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""Base search command to look for patterns in memory""
  },
  {
    ""part"": ""i"",
    ""category"": ""modifier"",
    ""desc"": ""Modifier to make the search case-insensitive""
  },
  {
    ""part"": ""<hello>"",
    ""category"": ""argument"",
    ""desc"": ""The string pattern we want to search for""
  }
]
"
How can I create a new flag space named 'findings'?	fs findings	"
When working with reverse engineering, you often need to organize different types of flags (like functions, strings, or custom findings) into separate namespaces. The question asks about creating a new flag space, which is essentially creating a new namespace for flags. Looking at the command help, 'fs' is the command that manages flag spaces, and simply providing a name after it will either select an existing space or create a new one if it doesn't exist.
"	"
[
  {
    ""part"": ""f"", 
    ""category"": ""flags"",
    ""desc"": ""flags are the main category since we're dealing with flag spaces""
  },
  {
    ""part"": ""s"",
    ""category"": ""spaces"",
    ""desc"": ""s for spaces, manages flag namespaces""
  },
  {
    ""part"": ""<findings>"",
    ""category"": ""argument"",
    ""desc"": ""the name of the new flag space to create""
  }
]
"
How can I print the immediate value of the current instruction?	ao~^val[1]	"
When analyzing instructions, we often need to extract specific values. In this case, we want to get the immediate value from the current instruction. The process would be:
1. First, we need to analyze the opcode at current position
2. From the analysis, we want to extract just the immediate value
3. We'll need to use grep to filter out everything else and get just the value we want
4. The immediate value is stored in the 'val' field of the opcode analysis

This leads us to using the analyze opcode command and filtering its output to get just the immediate value field.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""We need to analyze something""
  },
  {
    ""part"": ""o"",
    ""category"": ""opcode"",
    ""desc"": ""Analyze current opcode - this gives detailed info about the instruction""
  },
  {
    ""part"": ""~"",
    ""category"": ""filter"",
    ""desc"": ""Use grep to filter the output""
  },
  {
    ""part"": ""^val"",
    ""category"": ""regex"",
    ""desc"": ""Match lines starting with 'val'""
  },
  {
    ""part"": ""[1]"",
    ""category"": ""column select"",
    ""desc"": ""Select the second column which contains the actual value""
  }
]
"
Whats the destination for the jump/branch/call at address 0x580034?	?v $j @ 0x580034	"
We need to find out where a control flow instruction (jump/branch/call) at address 0x580034 is going to. This requires:
1. Getting the value of the jump destination
2. Looking at that specific address

The `?v` command is perfect for this as it evaluates expressions. The special variable `$j` gives us the jump destination of the instruction at the current address. But since we want to check a specific address rather than current seek, we use the `@` modifier to temporarily seek to that address while executing the command.
"	"
[
  {""part"": ""?"", ""category"": ""evaluate"", ""desc"": ""evaluate mathematical expressions and variables""},
  {""part"": ""v"", ""category"": ""value"", ""desc"": ""print the value rather than full evaluation info""},
  {""part"": ""$j"", ""category"": ""variables"", ""desc"": ""special variable that contains jump destination of current instruction""},
  {""part"": ""@"", ""category"": ""temporary_seek"", ""desc"": ""perform command at specific address""},
  {""part"": ""<0x580034>"", ""category"": ""address"", ""desc"": ""the address we want to analyze""}
]
"
How do I display the executable headers of the current binary?	iH	"
To display executable headers, we need to interact with the binary analysis capabilities of r2. The binary headers contain crucial information about the file format, architecture, and other metadata. Since this is information about the binary itself, we'd look at the 'i' (information) commands. Within the information category, we specifically want to look at Headers, which leads us to 'iH' as the most direct way to display the binary headers.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""information commands are used to get details about the loaded binary""
  },
  {
    ""cmd"": ""H"",
    ""category"": ""headers"",
    ""desc"": ""specifically targets the binary headers section of the information""
  }
]
"
Emulate all the executable regions to find out computed references to strings	aae	"
We need to analyze the binary to find references to strings that aren't immediately obvious from static analysis. This requires emulation of code to discover dynamic references. Since we want to cover all executable regions, we need a comprehensive analysis command that uses ESIL (radare2's intermediate language) to emulate instructions and track their behavior. This will help identify string references that are computed at runtime rather than being direct references.

The 'aa' command family is for analysis, and since we need emulation specifically for finding references, 'aae' is the perfect fit as it uses ESIL to emulate code and find computed references.
"	"
[
  {
    ""part"": ""a"", 
    ""category"": ""analysis"",
    ""desc"": ""Analysis command family, needed to analyze code""
  },
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""Additional 'a' indicates deeper analysis mode""
  },
  {
    ""part"": ""e"",
    ""category"": ""emulation"",
    ""desc"": ""Specifies ESIL emulation to find computed references""
  }
]
"
What option must be set to create flags for every new string referenced from the analysis?	e anal.strings=true	"
To understand this question, let's break it down:
1. We need to handle strings found during analysis
2. We want to create flags for these strings
3. This is clearly an analysis-time configuration
4. The strings need to be automatically detected and flagged
5. Since it's a configuration option, it must start with 'e'
6. Since it deals with analysis, it should be under 'anal.'
7. Since it's about string handling, 'strings' makes sense as the property name
8. And since it's a boolean option (enable/disable), true/false is appropriate

This leads us to the eval variable 'anal.strings' which needs to be set to true to automatically create flags for strings found during analysis.
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""command to get/set config variables""
  },
  {
    ""part"": ""anal.strings"",
    ""category"": ""config_variable"",
    ""desc"": ""specific configuration for handling strings during analysis""
  },
  {
    ""part"": ""=true"",
    ""category"": ""value"",
    ""desc"": ""boolean value to enable the feature""
  }
]
"
I need to calculate the SHA256 hash of the current block.	ph sha256	"
When you need to calculate a cryptographic hash of data in r2, you'll want to use the print hash command. Since we specifically want SHA256, we need a command that lets us specify the hash algorithm. Looking at the command set, 'ph' is the dedicated command for printing hashes of blocks of data. The syntax is straightforward - specify the algorithm name after 'ph'. SHA256 being one of the most common hash algorithms, it makes sense it would be supported.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command - we need to output/display something""
  },
  {
    ""part"": ""h"", 
    ""category"": ""hash"",
    ""desc"": ""hash subcommand - specifically for calculating hashes""
  },
  {
    ""part"": ""<sha256>"",
    ""category"": ""algorithm"",
    ""desc"": ""specifies which hash algorithm to use - in this case SHA256""
  }
]
"
Find functions that best match the `malloc` signature.	zbr sym.__libc_malloc 10`	"
Looking at this question, we need to find functions similar to malloc. This is a signature matching problem, specifically looking for the closest matches to a known function signature. The question mentions ""malloc"" and wants to find the 10 best matches.

This is a perfect use case for the zignature search functionality, specifically the ""best match"" search variant. Since we already have a known function name (sym.__libc_malloc) and want to find similar functions, we'll use the reverse best match search.

The command should be in the zignature (z) namespace, using the best match (b) subcommand, with the reverse (r) flag to search based on a known signature.
"	"
[
  {
    ""part"": ""z"",
    ""category"": ""zignatures"",
    ""desc"": ""access the zignature analysis system""
  },
  {
    ""cmd"": ""b"",
    ""category"": ""best match"",
    ""desc"": ""search for closest matching signatures""
  },
  {
    ""cmd"": ""r"",
    ""category"": ""reverse"",
    ""desc"": ""reverse search - find functions similar to given signature""
  },
  {
    ""cmd"": ""<sym.__libc_malloc>"",
    ""category"": ""arguments"",
    ""desc"": ""the signature to compare against""
  },
  {
    ""cmd"": ""<10>"",
    ""category"": ""arguments"", 
    ""desc"": ""number of results to return""
  }
]
"
Which functions are using network-related imports?	iiccx network	"
To find functions using specific imports, we need to analyze the imports first, then look for cross-references. The question asks about network-related imports, so we need to use the import class command (iic) and then show functions calling those imports.

Looking at the command structure, we need the import information (i) specifically about import classes (ic) and their cross-references (x). The word ""network"" is used to filter only network-related imports.
"	"
[
  {
    ""part"": ""i"", 
    ""category"": ""info"",
    ""desc"": ""information command - we want to know about the binary""
  },
  {
    ""part"": ""i"", 
    ""category"": ""imports"",
    ""desc"": ""imports subcommand - narrow down to import information""
  },
  {
    ""part"": ""c"",
    ""category"": ""classes"", 
    ""desc"": ""classify imports by grouping them""
  },
  {
    ""part"": ""c"",
    ""category"": ""classify"",
    ""desc"": ""show the classified imports""
  },
  {
    ""part"": ""x"",
    ""category"": ""xrefs"",
    ""desc"": ""show cross-references - which functions use these imports""
  },
  {
    ""part"": ""<network>"",
    ""category"": ""filter"",
    ""desc"": ""filter to only show network-related imports""
  }
]
"
List functions calling imports that interact with the console, like printing text or reading from stdin	iiccx console	"
To find functions that interact with the console through imports, we need to analyze the imports first, then find the functions that call them. The question is specifically about console I/O imports.

We need a command that:
1. Lists imports (ii)
2. Groups them by class (c)
3. Filters for console-related ones (c)
4. Shows cross-references to these imports (x)

The command `iiccx console` makes sense because:
- We need to look at imports
- We want to group them by class/category
- We want to find functions calling these imports
- We specifically want console-related imports
"	"
[
  {
    ""part"": ""ii"", 
    ""category"": ""imports"",
    ""desc"": ""list imports - start by looking at imported functions""
  },
  {
    ""cmd"": ""c"",
    ""category"": ""classify"",
    ""desc"": ""group imports by their class/category""
  },
  {
    ""cmd"": ""c"",
    ""category"": ""classify"",
    ""desc"": ""show specific class info""
  },
  {
    ""cmd"": ""x"",
    ""category"": ""xrefs"",
    ""desc"": ""show cross-references/functions using these imports""
  },
  {
    ""cmd"": ""<console>"",
    ""category"": ""filter"",
    ""desc"": ""filter to only show console-related imports""
  }
]
"
Graphviz graph with all the references to `exit`	ag-;.axtg sym.imp.exit;aggd	"
We need to create a graphviz graph showing all cross-references to the exit function. This requires multiple steps:
1. First clear any existing custom graphs (ag-)
2. Then find all references to the exit symbol (.axtg)
3. Finally generate and display the graph (aggd)

This is combining graph commands with xref analysis to create a visual representation of all code paths leading to exit calls. The command uses semicolons to chain these operations together.
"	"
[
  {""part"": ""ag"", ""category"": ""analysis_graph"", ""desc"": ""graph command prefix""},
  {""part"": ""-"", ""category"": ""clear"", ""desc"": ""clear/delete the custom graph""},
  {""part"": "";"", ""category"": ""separator"", ""desc"": ""chain commands""},
  {""part"": ""."", ""category"": ""current_offset"", ""desc"": ""use current location""},
  {""part"": ""axt"", ""category"": ""xrefs"", ""desc"": ""find cross references to""},
  {""part"": ""g"", ""category"": ""graph"", ""desc"": ""output as graph commands""},
  {""part"": ""<sym.imp.exit>"", ""category"": ""argument"", ""desc"": ""target symbol to analyze""},
  {""part"": "";"", ""category"": ""separator"", ""desc"": ""chain commands""},
  {""part"": ""agg"", ""category"": ""graph_generate"", ""desc"": ""generate graph""},
  {""part"": ""d"", ""category"": ""display"", ""desc"": ""display in dot format""}
]
"
Find all references to the string containing 'usage'	axtq `izq~usage[0]`	"
To find all references to a string containing 'usage', we need to:
1. First find the string's address using string search (iz) filtered for 'usage'
2. Then find all cross-references to that address
3. Do this in a quiet format for clean output

The command builds from inside out:
1. `izq~usage[0]` - Search for strings (iz), in quiet mode (q), grep for 'usage', take first column [0]
2. This address is then passed as argument to `axt` which finds cross-references
3. The q flag makes it quiet (clean output)
"	"
[
  {
    ""part"": ""axt"",
    ""category"": ""analysis"",
    ""desc"": ""find cross-references to""
  },
  {
    ""part"": ""q"",
    ""category"": ""modifier"",
    ""desc"": ""quiet mode output""
  },
  {
    ""part"": ""`"",
    ""category"": ""command substitution"",
    ""desc"": ""execute inner command first and use result""
  },
  {
    ""part"": ""iz"",
    ""category"": ""strings"",
    ""desc"": ""list strings in data sections""
  },
  {
    ""part"": ""q"",
    ""category"": ""modifier"", 
    ""desc"": ""quiet mode for string search""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter output""
  },
  {
    ""part"": ""<usage[0]>"",
    ""category"": ""argument"",
    ""desc"": ""grep for 'usage' and take first column""
  }
]
"
I want to list all C++ virtual tables in the binary.	av	"
When analyzing C++ binaries, one of the key structures we need to understand are virtual tables (vtables) which enable polymorphism. These are tables of function pointers used for virtual method dispatch. The question asks for listing all vtables, so we need a command that specifically deals with C++ analysis and vtable enumeration. Looking through the command set, we find the 'av' command under analysis (a) that specifically deals with C++ vtables and RTTI information.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used to extract and understand program structure""
    },
    {
        ""part"": ""v"",
        ""category"": ""vtables"",
        ""desc"": ""virtual tables subcommand - specifically handles C++ vtable analysis""
    }
]
"
Compute entropy of the current section	ph entropy $SS @ $S	"
We need to calculate entropy of the current section. This requires knowing both the section's address and size, then computing entropy on that range. The command uses built-in variables $S (current section address) and $SS (current section size) to avoid having to specify these manually. The ph command is used for hash/checksum calculations, and entropy is one of its supported algorithms.

The command breaks down into calculating entropy (@) at the current section address ($S) for the length of the section ($SS).
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print/compute"",
    ""desc"": ""Print/compute command prefix""
  },
  {
    ""part"": ""h"",
    ""category"": ""hash"",
    ""desc"": ""Hash/checksum calculation subcommand""
  },
  {
    ""part"": ""<entropy>"",
    ""category"": ""algorithm"",
    ""desc"": ""Specify entropy as the hash algorithm to use""
  },
  {
    ""part"": ""<$SS>"",
    ""category"": ""variable"", 
    ""desc"": ""Section size variable to specify length""
  },
  {
    ""part"": ""@"",
    ""category"": ""at"",
    ""desc"": ""At operator to specify address""
  },
  {
    ""part"": ""<$S>"",
    ""category"": ""variable"",
    ""desc"": ""Section address variable to specify where to compute from""
  }
]
"
Compute entropy value of the current function	ph entropy $FS @ $FB	"
To compute entropy of the current function, we need several pieces of information:
1. We need a way to calculate entropy
2. We need to know the size of the function
3. We need to know where the function starts

Looking at the command structure, I can see this is using the hash command (ph) to calculate entropy over a specific range. The range is defined by:
- $FB (function begin)
- $FS (function size)

This is clever because it uses the hash command with entropy algorithm, but applies it specifically to the exact bytes of the current function by using the function begin address and function size variables.
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""Print command is used as the base for hash printing""
  },
  {
    ""part"": ""h"",
    ""category"": ""hash"",
    ""desc"": ""Hash subcommand to calculate various hashing algorithms""
  },
  {
    ""part"": ""<entropy>"",
    ""category"": ""algorithm"",
    ""desc"": ""Specifies entropy as the hash algorithm to use""
  },
  {
    ""part"": ""<$FS>"",
    ""category"": ""variable"",
    ""desc"": ""Function Size variable to specify how many bytes to analyze""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""At operator to specify where to start the analysis""
  },
  {
    ""part"": ""<$FB>"", 
    ""category"": ""variable"",
    ""desc"": ""Function Begin variable to specify the starting address""
  }
]
"
Compute entropy value of the current basic block	ph entropy $Fs @ $Fb	"
To compute entropy of a basic block, we need to:
1. Get the basic block's address ($Fb)
2. Use its size ($Fs) 
3. Calculate entropy on that specific range
4. The 'ph' command is perfect for this as it computes hashes and algorithms including entropy

The command breaks down to:
- Calculate entropy using ph
- On a block of size $Fs (current function size)
- Starting at address $Fb (current basic block start)
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""print output command""
  },
  {
    ""part"": ""h"",
    ""category"": ""hash"",
    ""desc"": ""hash algorithms subcommand""
  },
  {
    ""part"": ""entropy"",
    ""category"": ""algorithm"",
    ""desc"": ""specific algorithm to compute entropy value""
  },
  {
    ""part"": ""$Fs"",
    ""category"": ""variable"",
    ""desc"": ""size of current function""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""at specific address operator""
  },
  {
    ""part"": ""$Fb"",
    ""category"": ""variable"", 
    ""desc"": ""address of current basic block""
  }
]
"
How do I check the entropy of 4KB of data at address 0x4000?	ph entropy $K @ 0x4000	"
When dealing with data analysis, entropy is a key metric to identify compressed, encrypted or random data. To analyze entropy of a specific block of data, we need:
1. A way to calculate hash/entropy (p command family)
2. The specific hash algorithm for entropy
3. A size parameter ($K = 4KB = 4096)
4. A location to analyze (@ 0x4000)

The command builds up naturally: we need the print hash command, followed by the entropy algorithm, the size and location.
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""print command family is used for displaying/calculating data""
  },
  {
    ""part"": ""h"",
    ""category"": ""hash"",
    ""desc"": ""hash subcommand for calculating various hashes and checksums""
  },
  {
    ""part"": ""<entropy>"",
    ""category"": ""algorithm"",
    ""desc"": ""specifies entropy calculation algorithm""
  },
  {
    ""part"": ""<$K>"",
    ""category"": ""size"",
    ""desc"": ""specifies block size of 4KB (4096 bytes)""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""at operator to specify where to perform the operation""
  },
  {
    ""part"": ""<0x4000>"",
    ""category"": ""location"",
    ""desc"": ""the specific address to analyze""
  }
]
"
List all functions that can not return	tn~0x	"
Looking at functions that cannot return (like exit, abort, etc.) is an important part of analysis. The question wants to list all functions that have been marked as ""noreturn"". Since this is a listing/querying operation, we'll need to use the ""t"" (types) command family. Within that, ""tn"" handles noreturn function attributes. To get just the addresses, we'll need to filter the output with grep (~) looking for addresses that start with ""0x"".

The command builds up naturally:
1. Need to work with types -> t
2. Specifically noreturn attributes -> n 
3. Want to filter the output -> ~
4. Looking for addresses -> 0x
"	"
[
  {
    ""part"": ""t"",
    ""category"": ""types"",
    ""desc"": ""types command for working with type information""
  },
  {
    ""cmd"": ""n"",
    ""category"": ""noreturn"", 
    ""desc"": ""list noreturn function attributes""
  },
  {
    ""cmd"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output""
  },
  {
    ""cmd"": ""0x"",
    ""category"": ""filter"",
    ""desc"": ""grep pattern to match addresses""
  }
]
"
Which imports use format strings	iicc format	"
Looking at the question, we need to find imports that use format strings. This is a common analysis task when looking for potential format string vulnerabilities or understanding string handling in a binary.

The task involves imports (ii) and specifically their classification (c), and we want to find those related to format strings. We need to use the import classification feature and filter for format string related imports.

The command needs to analyze imports (ii) and classify them (c) with a specific type filter for format strings.
"	"
[
  {
    ""part"": ""ii"", 
    ""category"": ""imports"",
    ""desc"": ""list imports command - we start here because we're looking at imports""
  },
  {
    ""part"": ""c"",
    ""category"": ""classify"",
    ""desc"": ""classify imports by their type/class""
  },
  {
    ""part"": ""<format>"",
    ""category"": ""argument"",
    ""desc"": ""specifies we want to see format string related imports""
  }
]
"
Which imports interact with the network?	iicc network	"
To find network-related imports, we need to analyze the imports and classify them. The question specifically asks about network interactions, so we need a way to filter imports by their class or category. Looking at the commands, 'ii' deals with imports, and 'iic' allows classification of imports. Adding another 'c' lets us search for a specific class, in this case 'network'.
"	"
[
  {""part"": ""ii"", ""category"": ""imports"", ""desc"": ""list imports is the base command we need""},
  {""part"": ""c"", ""category"": ""classify"", ""desc"": ""adds classification capability to filter imports""},
  {""part"": ""c"", ""category"": ""search"", ""desc"": ""allows searching for a specific class""},
  {""part"": ""<network>"", ""category"": ""argument"", ""desc"": ""specifies we want to see network-related imports""}
]
"
Which functions work with files?	iiccx file	"
When looking for functions that work with files, I need to look at imports, which are managed with the 'i' commands in radare2. Since we want to know specifically about functions working with files, we need to go deeper into import classification (iic) and then look at their cross-references (x). The command chain builds up naturally as we want to see what functions are calling/using the file-related imports.

The command iiccx will show functions that are calling imports of a specific class, in this case 'file' - which means it will list all functions in the binary that are using file-related imports like open, read, write, etc.
"	"
[
  {""part"": ""i"", ""category"": ""info"", ""desc"": ""information commands to analyze binary""},
  {""part"": ""i"", ""category"": ""imports"", ""desc"": ""narrow down to import-specific commands""},
  {""part"": ""c"", ""category"": ""class"", ""desc"": ""classify imports by their type""},
  {""part"": ""c"", ""category"": ""class"", ""desc"": ""show imports grouped by class""},
  {""part"": ""x"", ""category"": ""xrefs"", ""desc"": ""show cross-references/functions using these imports""},
  {""part"": ""<file>"", ""category"": ""argument"", ""desc"": ""specify we want to see file-related imports""}
]
"
Which functions work with directories?	iiccx dir	"
When dealing with directories in the context of imports and classes, we need to find functions that work with those structures. Looking at the command structure, this seems to be about analyzing imports by class and showing cross-references. The 'iiccx' command would show functions calling the imports of a specific class or directory.

The question is asking about directory functionality, and this command helps us see what functions are using imports from a particular directory structure or namespace in the binary. This is particularly useful when analyzing how different parts of the code interact with specific library directories or namespaces.
"	"
[
    {
        ""part"": ""i"", 
        ""category"": ""info"",
        ""desc"": ""information command for binary analysis""
    },
    {
        ""part"": ""i"", 
        ""category"": ""imports"",
        ""desc"": ""narrow down to import-specific commands""
    },
    {
        ""part"": ""c"", 
        ""category"": ""class"",
        ""desc"": ""work with class information""
    },
    {
        ""part"": ""c"", 
        ""category"": ""classify"",
        ""desc"": ""further specify classification of imports""
    },
    {
        ""part"": ""x"", 
        ""category"": ""xrefs"",
        ""desc"": ""show cross references""
    },
    {
        ""part"": ""<dir>"", 
        ""category"": ""argument"",
        ""desc"": ""directory/namespace to analyze""
    }
]
"
Which functions use imports that depend on global variables and are not thread safe or reentrant?	iiccx global	"
We need to find functions that call specific imports, particularly those related to global variables that aren't thread-safe. This is a common security analysis task.

First, we need to analyze imports (ii), then we want to classify them (c), particularly looking at their class (c), and finally examine which functions are using (x) imports marked as 'global'.

The command builds up naturally:
1. ii - to work with imports
2. c - to classify them
3. c - to work with classes of imports
4. x - to show cross references
"	"
[
    {""part"": ""ii"", ""category"": ""imports"", ""desc"": ""list imports - we start here because we need to analyze imports""},
    {""part"": ""c"", ""category"": ""classify"", ""desc"": ""classify the imports to understand their types""},
    {""part"": ""c"", ""category"": ""class"", ""desc"": ""specifically work with import classes""},
    {""part"": ""x"", ""category"": ""xrefs"", ""desc"": ""show cross references to these imports""},
    {""part"": ""<global>"", ""category"": ""argument"", ""desc"": ""filter to only show global variable related imports""}
]
"
Functions calling memcpy	axtq@sym.imp.memcpy	"
To find functions calling memcpy, we need to:
1. First locate the memcpy symbol (sym.imp.memcpy)
2. Then find cross-references to it (ax command for xrefs)
3. We want it in quiet mode (q) to just get the addresses
4. We want to find functions (@) that reference memcpy

This is a cross-reference analysis task - we're looking for who calls this specific imported function. The command builds up naturally from needing to analyze xrefs (ax) in a specific format (t for ""to"") in quiet mode (q) at (@) the memcpy symbol.
"	"
[
  {
    ""part"": ""ax"", 
    ""category"": ""analysis"",
    ""desc"": ""analyze cross-references command""
  },
  {
    ""part"": ""t"",
    ""category"": ""type"",
    ""desc"": ""show references 'to' this address""
  },
  {
    ""part"": ""q"",
    ""category"": ""output"",
    ""desc"": ""quiet mode - just show addresses""
  },
  {
    ""part"": ""@"",
    ""category"": ""location"",
    ""desc"": ""at specific address/symbol""
  },
  {
    ""part"": ""<sym.imp.memcpy>"",
    ""category"": ""symbol"",
    ""desc"": ""the memcpy import symbol to analyze""
  }
]
"
How do I look for functions that might be handling XML or JSON data?	afl~xml,json,parse	"
Looking for functions that handle XML or JSON, we need to list all functions and then filter for those keywords. This is a common pattern when looking for specific functionality in a binary.

First, we need to list all functions, which is done with 'afl' (analyze function list). Then we want to filter that list for functions that might be handling these data formats. The most obvious keywords would be 'xml', 'json', and 'parse' since these often appear in function names handling these formats.

To filter for multiple terms, we can use the grep operator (~) with commas to separate multiple search terms.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used to extract information from the binary""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""specifically we want function-related analysis""
    },
    {
        ""part"": ""l"",
        ""category"": ""list"",
        ""desc"": ""list all functions that have been found""
    },
    {
        ""part"": ""~"",
        ""category"": ""grep"",
        ""desc"": ""filter the output through grep""
    },
    {
        ""part"": ""<xml,json,parse>"",
        ""category"": ""search terms"",
        ""desc"": ""comma-separated keywords to search for in function names""
    }
]
"
Give a name to all unnamed functions based on their strings and function calls	aan	"
Looking at the task of naming unnamed functions, we need an automated way to analyze functions and give them meaningful names based on their contents. This would involve looking at strings referenced within the function and any function calls made from it. Since this is an automated analysis task, we'll want something from the 'a' (analysis) commands. Looking at the available options, 'aa' is for analysis and 'aan' specifically deals with autoname functionality. This is exactly what we need - it will look at each function's characteristics and try to give it an appropriate name based on strings and function calls found within.
"	"
[
    {
        ""part"": ""a"", 
        ""category"": ""analysis"",
        ""desc"": ""Analysis command is needed since we're examining code""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""Double 'a' indicates we want to perform deeper analysis""
    },
    {
        ""part"": ""n"",
        ""category"": ""naming"",
        ""desc"": ""The 'n' specifies we want to perform automatic naming of functions""
    }
]
"
Autoname all functions	aan	"
When analyzing a binary, one of the key tasks is identifying and naming functions meaningfully. Looking at the question, we need a command that can automatically assign names to all functions in the binary. This would be part of the analysis commands, since it's about understanding program structure.

Looking through the command set, 'a' is for analysis commands. Since we want to work with function names, 'an' makes sense as it deals with naming. The additional 'a' suggests it should work on all functions automatically.

This is a common need when starting analysis of a new binary - you want meaningful names for functions based on their characteristics, rather than just generic names or addresses.
"	"
[
  {
    ""part"": ""a"", 
    ""category"": ""analysis"",
    ""desc"": ""Analysis command prefix for analyzing code and data""
  },
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""Additional 'a' indicates this is an automated/all operation""
  },
  {
    ""part"": ""n"",
    ""category"": ""names"",
    ""desc"": ""Name-related operation, specifically for automatic function naming""
  }
]
"
Suggest a new name for the current function	afna	"
Looking at this question about suggesting a new name for the current function, I immediately think about automated function naming/analysis. We need a command that deals with functions (af) and specifically with naming them automatically (n) based on analysis (a).

The command would need to be in the function analysis category since we're working with function names. Looking through the help, I see that 'afn' deals with function names, and adding 'a' suggests automatic naming based on analysis.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis commands start with 'a' since we're analyzing code""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""we're working with functions, so 'f' follows 'a'""
  },
  {
    ""part"": ""n"",
    ""category"": ""name"",
    ""desc"": ""the 'n' indicates we're dealing with naming functions""
  },
  {
    ""part"": ""a"",
    ""category"": ""automatic"",
    ""desc"": ""final 'a' indicates automatic/analysis-based naming""
  }
]
"
What is the name of the current function?	afn	"
We need to get information about the current function's name. Since we're dealing with functions, we'll use the 'a' (analysis) commands. Within analysis, 'f' is for function-related operations. To get or set the name of a function, 'n' makes sense as it commonly relates to naming things.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used for working with functions and code analysis""
  },
  {
    ""cmd"": ""f"",
    ""category"": ""function"",
    ""desc"": ""narrow down to function-specific operations""
  },
  {
    ""cmd"": ""n"",
    ""category"": ""name"",
    ""desc"": ""get or set the name of the current function""
  }
]
"
Seek to the next function	sn	"
Looking at the seek command 's', we need to move to the next function. The question is straightforward - we need to seek (change our position) to the next function in the binary. The 'sn' command combines seek with 'next', similar to how vim uses 'n' for next. This follows the common pattern in radare2 where the first letter indicates the main command category (seek in this case) and subsequent letters modify or specify the exact operation (next in this case).
"	"
[
  {
    ""part"": ""s"",
    ""category"": ""seek"",
    ""desc"": ""The seek command is used for changing the current position in the file""
  },
  {
    ""part"": ""n"",
    ""category"": ""navigation"",
    ""desc"": ""Specifies we want to move to the next item (function in this case)""
  }
]
"
Seek to the previous function	sp	"
To seek to the previous function, we need a command that changes the current position in the binary. Seeking commands start with 's' in radare2. Since we want to go to a function, and specifically the previous one, we need to look at seek commands that work with functions. Looking at the seek help, we can see 'sp' is listed as ""seek to prev function prelude"". This is exactly what we want - it will move our cursor to the start of the previous function from our current position.
"	"
[
  {
    ""part"": ""s"", 
    ""category"": ""seek"",
    ""desc"": ""seek command to change current position""
  },
  {
    ""part"": ""p"",
    ""category"": ""direction"",
    ""desc"": ""previous - moves backwards to find the function before current position""
  }
]
"
Find the next function prelude and seen there	snp	"
To find the next function prelude, we need a seek command that looks specifically for function preludes. Looking at the command set, 's' is for seeking and we want to find the 'next' occurrence of something specific - a function prelude. Function preludes are standard patterns at the beginning of functions (like push rbp, mov rbp,rsp on x86_64).

The 'n' in snp would stand for 'next' and 'p' would naturally stand for 'prelude', making this a specialized seek command to find the next function prelude pattern in the binary. This is particularly useful during binary analysis when you want to quickly navigate between functions.
"	"
[
  {
    ""part"": ""s"",
    ""category"": ""seek"",
    ""desc"": ""seeking commands are used to navigate through the file""
  },
  {
    ""part"": ""n"",
    ""category"": ""navigation"",
    ""desc"": ""find next occurrence of something""
  },
  {
    ""part"": ""p"",
    ""category"": ""prelude"",
    ""desc"": ""specifically looking for function preludes""
  }
]
"
How can I find places where the program is writing to files?	axt @sym.fwrite	"
To find where a program writes to files, we need to analyze cross-references (xrefs) to the file writing function. The standard C function 'fwrite' is commonly used for file operations, so we want to find all code locations that reference this symbol. The command needs to:
1. Find cross-references (x)
2. Look specifically for places that reference this symbol
3. Show where the function is being called from

This leads us to use 'axt' which shows xrefs-to a specific address, and we want to look at the symbol fwrite using @sym.fwrite
"	"
[
    {
        ""part"": ""ax"", 
        ""category"": ""analysis"",
        ""desc"": ""analyze xrefs - we want to find cross references""
    },
    {
        ""part"": ""t"",
        ""category"": ""type"",
        ""desc"": ""specifically xrefs-to, meaning places that reference our target""
    },
    {
        ""part"": ""@sym.fwrite"",
        ""category"": ""arguments"",
        ""desc"": ""look at the fwrite symbol specifically, using @ to specify the target""
    }
]
"
How can I find all the recursive functions in the program?	aflmr	"
To find recursive functions, we need to analyze the program's functions and look for ones that call themselves. This requires:
1. First getting a list of all functions (afl)
2. Then we want to see what they call (m for makefile format shows function calls)
3. And specifically find the recursive ones (r for recursive)

This is a function listing command that will show functions that call themselves, either directly or indirectly through other function calls.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used to analyze program elements""
    },
    {
        ""part"": ""f"", 
        ""category"": ""functions"",
        ""desc"": ""we want to work with functions""
    },
    {
        ""part"": ""l"",
        ""category"": ""listing"",
        ""desc"": ""list the functions""
    },
    {
        ""part"": ""m"",
        ""category"": ""makefile"",
        ""desc"": ""show in makefile format which shows dependencies/calls""
    },
    {
        ""part"": ""r"",
        ""category"": ""recursive"",
        ""desc"": ""filter to only show recursive functions""
    }
]
"
Which math imports is this program using?	iicc math	"
To find math imports in a program, we need to analyze the imports and classify them by their class/category. The question specifically asks about math imports, so we need a command that can show imports grouped by class and then filter for the math-related ones.

The command needs to:
1. List imports (ii)
2. Show them by class/category (c)
3. Filter specifically for math-related ones

The `iicc` command is perfect for this as it shows all imports matching a specific class name.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""info"",
    ""desc"": ""information commands are used to analyze binary properties""
  },
  {
    ""part"": ""i"",
    ""category"": ""imports"",
    ""desc"": ""second i specifies we want to look at imports""
  },
  {
    ""part"": ""c"",
    ""category"": ""classify"",
    ""desc"": ""group imports by their class/category""
  },
  {
    ""part"": ""c"",
    ""category"": ""filter"",
    ""desc"": ""show only imports matching the specified class""
  },
  {
    ""part"": ""<math>"",
    ""category"": ""argument"",
    ""desc"": ""specifies we want to see only math-related imports""
  }
]
"
Which functions are using math imports?	iiccx math	"
When looking for functions using specific imports, we need to analyze the imports and their usage. The question asks about math-related imports, so we need a command that can show functions using math imports.

Looking at the import commands, we see 'iic' deals with import classes, and adding 'cx' allows us to see cross-references to those imports. This will show us which functions are calling math-related imports.
"	"
[
  {
    ""part"": ""ii"", 
    ""category"": ""imports"",
    ""desc"": ""list imports command""
  },
  {
    ""part"": ""cc"",
    ""category"": ""classes"",
    ""desc"": ""narrow down to class-based imports""
  },
  {
    ""part"": ""x"",
    ""category"": ""xrefs"",
    ""desc"": ""show cross-references/functions using these imports""
  },
  {
    ""part"": ""<math>"",
    ""category"": ""argument"",
    ""desc"": ""filter to only show math-related imports""
  }
]
"
Is the program using the ncurses library?	il~ncurses	"
To check if a program is using the ncurses library, we need to look at the linked libraries. The question is essentially asking to search through the library listing for anything containing ""ncurses"". This requires first listing all libraries (il) and then filtering the output to find any mention of ncurses using the grep operator (~).
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""information about the binary""
  },
  {
    ""part"": ""l"",
    ""category"": ""libraries"",
    ""desc"": ""list all linked libraries""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output""
  },
  {
    ""part"": ""<ncurses>"",
    ""category"": ""search term"",
    ""desc"": ""the library name we're searching for""
  }
]
"
I want to see what kind of memory alignment the architecture uses. How do I find alignment checks?	aia~^codealign[1]	"
When dealing with architecture-specific details like memory alignment, we need to analyze the binary's internal properties. The question is about finding alignment checks specifically.

The command needs to:
1. Get architecture information/analysis (this is what 'ai' family of commands does)
2. Get detailed analysis info (that's what 'aia' does - full analysis)
3. Filter for alignment-related information (using the grep operator ~)
4. Look specifically for code alignment (^codealign to match at start of line)
5. Get the first column ([1] selector)
"	"
[
    {""part"": ""ai"", ""category"": ""analysis"", ""desc"": ""architecture information command group""},
    {""part"": ""a"", ""category"": ""analysis"", ""desc"": ""additional 'a' for detailed analysis information""},
    {""part"": ""~"", ""category"": ""grep"", ""desc"": ""filter the output""},
    {""part"": ""^codealign"", ""category"": ""pattern"", ""desc"": ""match lines starting with 'codealign'""},
    {""part"": ""[1]"", ""category"": ""column"", ""desc"": ""select the first column of the matched line""}
]
"
I want to see what kind of cleanup operations happen at program exit.,axt @sym.atexit		"
To understand what happens at program exit, we need to look at the cross-references to the atexit function, which is a standard C function that registers cleanup handlers to be called when the program exits. The command needs to:

1. Find cross-references (x)
2. Look at addresses (a) that use this symbol
3. Look specifically at the symbol atexit
4. Show all types of references (t)

This will show us all the places in the code that register cleanup handlers using atexit(), helping us understand what cleanup operations are scheduled to run at program termination.
"	"
[
  {
    ""part"": ""ax"", 
    ""category"": ""xrefs"",
    ""desc"": ""analyze cross references""
  },
  {
    ""part"": ""t"",
    ""category"": ""type"",
    ""desc"": ""show all types of references to target""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""specify location to analyze""
  },
  {
    ""part"": ""<sym.atexit>"",
    ""category"": ""symbol"",
    ""desc"": ""the atexit function symbol""
  }
]
"
How can I display all the stack backtrace in the debugger?	dbt	"
When debugging, one of the most important things to analyze is the call stack or backtrace to understand how the program got to the current point. Since we're looking for debugger functionality related to backtrace, we should look for a command that combines debugging with backtrace viewing. Looking at the help, 'dbt' stands out as the perfect match as it's under the debug commands section and specifically handles backtraces.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""This is the main debug command category, as we need debugger functionality""
    },
    {
        ""part"": ""b"",
        ""category"": ""backtrace"",
        ""desc"": ""Specifies we want backtrace functionality within debugging context""
    },
    {
        ""part"": ""t"",
        ""category"": ""trace"",
        ""desc"": ""Indicates we want to trace/display the backtrace information""
    }
]
"
Disable the automatic analysis of function arguments before calling `af` or `aa`.	e anal.vars=false	"
To optimize the analysis process, sometimes we need to control what gets analyzed. In this case, we want to prevent automatic analysis of function arguments which happens during function analysis (af) or full analysis (aa). This is a configuration setting that needs to be disabled before running those commands.

Looking through the commands, we need something that changes a configuration value ('e' command) related to analysis ('anal') and specifically about variables ('vars'). The value needs to be set to false to disable this feature.
"	"
[
    {
        ""part"": ""e"",
        ""category"": ""eval"",
        ""desc"": ""used to get/set configuration variables""
    },
    {
        ""part"": ""anal.vars"",
        ""category"": ""config"",
        ""desc"": ""specifies the configuration for automatic analysis of function arguments""
    },
    {
        ""part"": ""="",
        ""category"": ""operator"",
        ""desc"": ""assigns a value to the configuration""
    },
    {
        ""part"": ""<false>"",
        ""category"": ""value"",
        ""desc"": ""boolean value to disable the feature""
    }
]
"
Display function signature containing return and arguments types	afs	"
To display function signatures with return types and arguments, we need a command that deals with function analysis and specifically signatures. Looking at the available commands, we know we need something under the 'a' (analysis) category since we're analyzing function information. The 'f' subcategory deals with functions, and since we specifically want signatures, 's' would be the natural choice for signatures. This follows the logical pattern of narrowing down from general analysis to function-specific to signature-specific information.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""Analysis command as we're examining function information""
  },
  {
    ""cmd"": ""f"",
    ""category"": ""function"",
    ""desc"": ""Function subcommand since we're dealing with function-specific details""
  },
  {
    ""cmd"": ""s"",
    ""category"": ""signature"",
    ""desc"": ""Signature subcommand to show the function signature including return type and arguments""
  }
]
"
See the default calling convention used in this binary	e anal.cc	"
To understand the calling convention used in a binary, we need to check the analysis configuration. Since calling conventions determine how functions pass arguments and manage the stack, this is part of the analysis settings. The command should show the current value of the analysis.cc parameter, which defines the default calling convention used during analysis.

The command needs to check an eval variable (e) related to analysis (anal) specifically for calling conventions (cc).
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""command to show/modify eval variables""
  },
  {
    ""part"": ""anal.cc"",
    ""category"": ""config"",
    ""desc"": ""specific configuration variable for analysis calling convention""
  }
]
"
How do I compare two files `file1.bin` and `file2.bin`?	radiff2 -x file1.bin file2.bin	"
When comparing two binary files, we need a tool that can perform a binary diff. Since this is part of the radare2 suite, radiff2 is the specialized tool for this purpose. The question is asking for a direct comparison between two files, which suggests we want to see the differences in a hexadecimal format.

The -x flag is particularly useful here because it shows the differences in hexadecimal format, making it easy to spot byte-level changes between the files. This is more precise than a regular text diff and more appropriate for binary files.
"	"
[
  {
    ""part"": ""radiff2"",
    ""category"": ""tools"",
    ""desc"": ""specialized diff tool from radare2 suite for binary comparison""
  },
  {
    ""part"": ""-x"",
    ""category"": ""options"",
    ""desc"": ""specifies hexadecimal output format for detailed byte-level comparison""
  },
  {
    ""part"": ""<file1.bin>"",
    ""category"": ""arguments"",
    ""desc"": ""first binary file to compare""
  },
  {
    ""part"": ""<file2.bin>"",
    ""category"": ""arguments"",
    ""desc"": ""second binary file to compare against""
  }
]"
Set the calling convention of the `add` function to `cdecl`.	afc cdecl @ sym.add	"
Looking at this question, we need to set a calling convention for a specific function. In reverse engineering, calling conventions define how functions receive parameters and clean up the stack, which is crucial for proper function analysis. The `cdecl` convention is common in C programs where the caller cleans up the stack.

First, we need to use the analysis command family ('a') since we're dealing with function analysis. Within that, we need the function-specific commands ('f'), and specifically calling convention ('c'). The target function is specified by its symbol name 'sym.add', and we're using the '@' operator to specify where to apply the command.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis command family - for analyzing code and data""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""function-specific commands within analysis""
    },
    {
        ""part"": ""c"",
        ""category"": ""calling convention"",
        ""desc"": ""specify calling convention for a function""
    },
    {
        ""part"": ""<cdecl>"",
        ""category"": ""argument"",
        ""desc"": ""the specific calling convention to set""
    },
    {
        ""part"": ""@"",
        ""category"": ""operator"",
        ""desc"": ""at operator to specify where to apply the command""
    },
    {
        ""part"": ""<sym.add>"",
        ""category"": ""argument"",
        ""desc"": ""the target function to modify""
    }
]
"
List all the available calling conventions:	afcl	"
To understand calling conventions in a binary, we need to look at function analysis commands. We want to see all the possible calling conventions that r2 supports for the current architecture. This is useful when analyzing functions to understand how parameters are passed and how the stack is managed.

Looking at the command structure, we need something that deals with functions (af) and specifically calling conventions (c), and then list them (l). This would help in setting up proper analysis for different function types.
"	"
[
    {""part"": ""a"", ""category"": ""analysis"", ""desc"": ""analysis command - the main category for analyzing code""},
    {""part"": ""f"", ""category"": ""function"", ""desc"": ""function specific analysis commands""},
    {""part"": ""c"", ""category"": ""calling convention"", ""desc"": ""narrow down to calling convention related commands""},
    {""part"": ""l"", ""category"": ""list"", ""desc"": ""list all available calling conventions""}
]
"
Show basic block information in JSON	afbij	"
To show basic block information in JSON format, we need to think about the command hierarchy in radare2. We're dealing with functions and their basic blocks, so we start with 'af' for analysis of functions. Since we want basic block information, we add 'b' for basic blocks. We want it in JSON format so we add 'j', and since we want information/details we add 'i'. The order of these modifiers matters in radare2, with the JSON modifier typically coming last.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used to analyze code""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""specifies we're working with functions""
  },
  {
    ""part"": ""b"",
    ""category"": ""basic_block"",
    ""desc"": ""indicates we want to work with basic blocks of the function""
  },
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""shows detailed information about the basic blocks""
  },
  {
    ""part"": ""j"",
    ""category"": ""format"",
    ""desc"": ""outputs the result in JSON format""
  }
]
"
Convert JSON output from command to Key=Value syntax, the same way GRON works:	ij~{=}	"
We need to convert JSON output to a flattened key=value format. Let's break this down:
1. First we need the JSON output of the binary info, which comes from `i` command
2. We want it in JSON format, so we add `j`
3. Then we need to transform it, so we use the `~` grep operator
4. The `{=}` is a special modifier for the grep that converts JSON to key=value pairs, similar to how gron works
"	"
[{
    ""cmd"": ""i"",
    ""category"": ""info"",
    ""desc"": ""get information about the binary""
}, {
    ""cmd"": ""j"",
    ""category"": ""format"",
    ""desc"": ""output in JSON format""
}, {
    ""cmd"": ""~"",
    ""category"": ""filter"",
    ""desc"": ""grep operator to filter/transform output""
}, {
    ""cmd"": ""{=}"",
    ""category"": ""modifier"",
    ""desc"": ""special JSON to key=value converter modifier""
}]
"
Indent JSON using the ~ operator	ij~{}	"
I need to format JSON output in a more readable way. I know 'i' commands show info about the binary, and 'ij' gives that in JSON format. But raw JSON can be hard to read, so I need to pipe it through a filter that indents it nicely. The '~' operator is used for filtering and formatting, and specifically '~{}' is the JSON indentation modifier.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""info"",
    ""desc"": ""Show information about the binary""
  },
  {
    ""part"": ""j"", 
    ""category"": ""output"",
    ""desc"": ""Output in JSON format""
  },
  {
    ""part"": ""~"",
    ""category"": ""filter"",
    ""desc"": ""Pipe output through filter""
  },
  {
    ""part"": ""{}"",
    ""category"": ""modifier"",
    ""desc"": ""JSON indentation formatting""
  }
]
"
Show code locations, relationing source-line with address	CLL	"
When working with debugging or analysis, it's often crucial to understand the relationship between source code lines and their corresponding addresses in memory. Since we're looking to list or show information about code locations, and specifically about source lines, we need a command that deals with source line information. Looking through the command set, the 'CL' commands handle 'code line' information, which is exactly what we need. The additional 'L' indicates we want to list this information.
"	"
[
  {
    ""part"": ""C"",
    ""category"": ""metadata"",
    ""desc"": ""Metadata management command - we're working with code information""
  },
  {
    ""part"": ""L"",
    ""category"": ""line"",
    ""desc"": ""Specifically dealing with code line information""
  },
  {
    ""part"": ""L"",
    ""category"": ""list"",
    ""desc"": ""List operation - we want to show all the code line information""
  }
]
"
Describe the current instruction	aod	"
When analyzing code, we often need to understand what an instruction does. This question asks how to get a description of the current instruction. Looking through the commands, we need something that deals with analyzing opcodes, and specifically their description. The command should be under analysis (a) and opcode (o) related commands, and we want the description (d).
"	"
[
    {""part"": ""a"", ""category"": ""analysis"", ""desc"": ""analysis commands are used for understanding code""},
    {""part"": ""o"", ""category"": ""opcode"", ""desc"": ""opcode-specific analysis commands""},
    {""part"": ""d"", ""category"": ""description"", ""desc"": ""get the description/documentation of the instruction""}
]
"
Show me the ESIL expression that represents the current instruction	aoeq	"
We need to display the ESIL (Evaluable Strings Intermediate Language) representation of the current instruction. Since we want just the ESIL expression without additional information, we need a command that analyzes opcodes and shows only the ESIL part. Looking at the command structure, we need something that combines analysis (a), opcode (o), ESIL (e), and quiet mode (q).
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis command namespace - we need to analyze something""
    },
    {
        ""cmd"": ""o"",
        ""category"": ""opcode"",
        ""desc"": ""opcode analysis - we want to look at the current instruction""
    },
    {
        ""cmd"": ""e"",
        ""category"": ""esil"",
        ""desc"": ""esil output - we want the ESIL representation""
    },
    {
        ""cmd"": ""q"",
        ""category"": ""modifier"",
        ""desc"": ""quiet mode - we only want the ESIL expression without any other output""
    }
]
"
All the ESIL expressions for the current basic block	aoeq $Fi	"
We need to analyze ESIL expressions for instructions in the current basic block. Breaking this down:
1. We need ESIL output ('ao' family of commands)
2. We want just the expressions (e for esil)
3. We want it quiet (q)
4. We want it for the basic block, which is represented by $Fi (current function instruction count)
"	"
[
  {
    ""part"": ""ao"", 
    ""category"": ""analyze"",
    ""desc"": ""analyze opcodes - this is the base command for opcode analysis""
  },
  {
    ""part"": ""e"",
    ""category"": ""esil"",
    ""desc"": ""request ESIL expressions specifically""
  },
  {
    ""part"": ""q"",
    ""category"": ""output"",
    ""desc"": ""quiet mode - only show the ESIL expressions without additional info""
  },
  {
    ""part"": ""<$Fi>"",
    ""category"": ""arguments"",
    ""desc"": ""special variable representing number of instructions in current function""
  }
]
"
Evalute the ESIL expression `1,2,+,r0,:=`	'ae 1,2,+,r0,:=	"
Looking at this question, we need to evaluate an ESIL (Evaluable Strings Intermediate Language) expression. ESIL is r2's own assembly-like language used for emulation and analysis. The expression `1,2,+,r0,:=` pushes values onto a stack and performs operations.

To evaluate an ESIL expression, we need the 'ae' command which stands for ""analyze ESIL"". This makes sense because we want to analyze/evaluate what this ESIL expression does.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used for deeper inspection of code""
  },
  {
    ""part"": ""e"",
    ""category"": ""esil"",
    ""desc"": ""esil subcommand indicates we want to work with ESIL expressions""
  },
  {
    ""part"": ""<1,2,+,r0,:=>"",
    ""category"": ""argument"",
    ""desc"": ""the ESIL expression to evaluate: push 1, push 2, add them, store in r0""
  }
]
"
Translate and evaluate this expression `rax = rbx + 3` using ESIL emulation.	'ae 3,rbx,+,rax,:=	"
To translate and evaluate an arithmetic expression using ESIL (Evaluable Strings Intermediate Language), we need to use the 'ae' command which stands for 'analyze ESIL'. The expression needs to be converted to ESIL's reverse polish notation where operands come first followed by operators.

In this case, we want to:
1. Push the constant 3 onto the stack
2. Push the value of rbx register
3. Add them together (+)
4. Assign (:=) the result to rax register

This maps perfectly to the ESIL expression: ""3,rbx,+,rax,:="" where commas separate each operation
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analyze"",
        ""desc"": ""we need analysis capabilities to evaluate expressions""
    },
    {
        ""part"": ""e"",
        ""category"": ""esil"",
        ""desc"": ""specifically we want ESIL evaluation""
    },
    {
        ""part"": ""<3,rbx,+,rax,:=>"",
        ""category"": ""arguments"",
        ""desc"": ""the ESIL expression in reverse polish notation: push 3, push rbx, add them, assign to rax""
    }
]
"
Type of the instruction at address 0x808044	ao@0x808044~^type[1]	"
We need to find out the type of instruction at a specific address. This requires analyzing the opcode at that location and then filtering to get just the type information.

First we need the opcode analysis command ('ao'), then target it at the specific address using '@', and finally filter the output to get just the type field. The filter needs to match lines starting with ""type"" and take the second column (index 1).
"	"
[
  {""part"": ""ao"", ""category"": ""analysis"", ""desc"": ""analyze opcode - gives detailed info about instruction""},
  {""part"": ""@"", ""category"": ""addressing"", ""desc"": ""specify address to analyze""},
  {""part"": ""<0x808044>"", ""category"": ""argument"", ""desc"": ""the target address to analyze""},
  {""part"": ""~"", ""category"": ""filter"", ""desc"": ""grep-like filter of output""},
  {""part"": ""^type"", ""category"": ""filter_pattern"", ""desc"": ""match lines starting with 'type'""},
  {""part"": ""[1]"", ""category"": ""filter_column"", ""desc"": ""select second column of matching line""}
]
"
Size in bytes of the current instruction	aos	"
To find the size of the current instruction, I need a command that analyzes opcodes. Looking at the available commands, 'a' is for analysis and 'ao' is for analyzing opcodes. Since I specifically want the size of the instruction, 's' for size would be the logical addition to 'ao'.
"	"
[
  {""part"": ""a"", ""category"": ""analysis"", ""desc"": ""analysis commands are needed to examine instruction properties""},
  {""part"": ""o"", ""category"": ""opcodes"", ""desc"": ""narrow down to opcode analysis which deals with individual instructions""},
  {""part"": ""s"", ""category"": ""size"", ""desc"": ""specifically get the size information for the opcode""}
]
"
Size in bytes of the current instruction	ao~^size[1]	"
We need to find the size of the current instruction in bytes. This requires analyzing the opcode at the current position and extracting just the size information.

First, we need opcode analysis, which suggests using the 'ao' command for analyzing opcodes. But we don't want all the analysis information - just the size. Looking at the output format of 'ao', it contains a ""size"" field, so we can use grep to extract just that.

The grep needs to be anchored to the start of the line (^) to avoid false matches, and we want the second column [1] which contains the actual value.
"	"
[
  {
    ""part"": ""ao"",
    ""category"": ""analysis"",
    ""desc"": ""analyze opcode - gives detailed information about current instruction""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output using grep""
  },
  {
    ""part"": ""^size"",
    ""category"": ""pattern"",
    ""desc"": ""match lines starting with 'size'""
  },
  {
    ""part"": ""[1]"",
    ""category"": ""column_select"",
    ""desc"": ""select the second column which contains the numeric value""
  }
]
"
Seek to the program counter	sr PC	"
When working with debuggers or analyzing programs, we often need to move our cursor to where the program execution currently is - the Program Counter (PC). This is a common operation when debugging to see what instruction is about to be executed.

Looking at the command set, we need to use the seek command (s) since we want to move the cursor. But we specifically want to seek to a register value, which suggests using the 'sr' variant of seek. The PC parameter tells it which register to use as the target address.
"	"
[
  {
    ""part"": ""s"", 
    ""category"": ""seek"",
    ""desc"": ""Base seek command - tells r2 we want to move the cursor""
  },
  {
    ""part"": ""r"",
    ""category"": ""register"", 
    ""desc"": ""Specifies we want to seek to a register's value""
  },
  {
    ""part"": ""<PC>"",
    ""category"": ""arguments"",
    ""desc"": ""The name of the register we want to seek to - Program Counter""
  }
]
"
Seek 3 instructions forward	so 3	"
When we need to move the seek position based on instructions rather than bytes, we need a command that understands instruction boundaries. The seek command 's' is the base command for moving around, but we need a variant that works with opcodes. Looking at the seek help, we find 'so' which seeks by opcode count. Since we want to move forward 3 instructions, we simply append the number 3.
"	"
[
    {
        ""part"": ""s"",
        ""category"": ""seek"",
        ""desc"": ""base seek command for changing current position""
    },
    {
        ""cmd"": ""o"",
        ""category"": ""opcode"",
        ""desc"": ""specifies we want to seek by opcode count rather than bytes""
    },
    {
        ""cmd"": ""<3>"",
        ""category"": ""argument"",
        ""desc"": ""number of opcodes to seek forward""
    }
]
"
Temporal seek to the program counter and show the 32 bytes in hexpairs	p8 32 @r:PC	"
We need to read some bytes at the program counter (PC) register. This requires two things:
1. We need to read bytes and show them in hexadecimal format
2. We need to do this at the PC location, but only temporarily (not changing our current seek)

The command needs to:
- Print bytes in hex format
- Use a temporary seek to the PC register value
- Specify how many bytes we want to see (32)

This leads us to use p8 for hex byte printing with a temporary seek using @ and accessing the register value using r:
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""print command is needed to output data""
  },
  {
    ""part"": ""8"",
    ""category"": ""format"",
    ""desc"": ""print bytes in hexpairs format""
  },
  {
    ""part"": ""<32>"",
    ""category"": ""count"",
    ""desc"": ""number of bytes to print""
  },
  {
    ""part"": ""@"",
    ""category"": ""temporary_seek"",
    ""desc"": ""perform temporary seek without changing current position""
  },
  {
    ""part"": ""r:"",
    ""category"": ""register"",
    ""desc"": ""access register value""
  },
  {
    ""part"": ""<PC>"",
    ""category"": ""register_name"",
    ""desc"": ""specify the Program Counter register""
  }
]
"
Set the value 0x8822 to the `rax` register	dr rax=0x8822	"
To modify a register's value, we need to use the debug register commands. Since we want to set a specific value, we need the basic register manipulation command followed by the register name and value. The format for setting register values is straightforward - register name followed by equals sign and the value.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""debug commands are needed to interact with registers""
    },
    {
        ""part"": ""r"",
        ""category"": ""registers"",
        ""desc"": ""register manipulation subcommand""
    },
    {
        ""part"": ""<rax=0x8822>"",
        ""category"": ""arguments"",
        ""desc"": ""register name followed by equals and hex value to set""
    }
]
"
List all the register names	drl	"
We need to list register names. This is related to debugging and register operations. Looking at the help, we can see that 'dr' is the base command for register operations. Since we specifically want to list names, we need a modifier that focuses on listing. The 'l' modifier is commonly used for listing in r2, and checking the dr help shows 'drl' is exactly what we need to ""list all register names"".
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""debug commands are used for register operations""
  },
  {
    ""part"": ""r"",
    ""category"": ""registers"",
    ""desc"": ""register subcommands to work with CPU registers""
  },
  {
    ""part"": ""l"",
    ""category"": ""list"",
    ""desc"": ""list modifier to show all register names""
  }
]
"
Which strings are used in the current function?	"pdsf~"""	"
To find strings in the current function, we need a command that:
1. Works with functions ('f' is often used for function-related operations)
2. Shows summary/strings information ('s' is often used for strings)
3. Can be filtered to show only strings ('~' is used for grep/filtering)

Looking at the help, 'pds' is for ""print disasm summary"", and 'pdsf' specifically shows function summary including strings. The '~""' at the end filters to show only the lines containing quotes, which effectively shows only the strings.
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""Print command - the base for most output commands""
  },
  {
    ""part"": ""d"",
    ""category"": ""disassembly"",
    ""desc"": ""Disassembly context - we want to analyze code""
  },
  {
    ""part"": ""s"",
    ""category"": ""summary"",
    ""desc"": ""Summary mode - gives us overview information""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""Function context - limit analysis to current function""
  },
  {
    ""part"": ""~\"""",
    ""category"": ""filter"",
    ""desc"": ""Grep filter for quotes - shows only lines with strings""
  }
]
"
How can I read the contents of the file /etc/motd	cat /etc/motd	"
You want to read the contents of a file, which in Unix-like systems is commonly done with 'cat'. In radare2, there's a similar command for reading files. Looking through the command reference, I see that under the 'm' (mountpoints) commands there's 'mc' which is specifically described as ""cat: Show the contents of the given file"". This is exactly what we need for reading /etc/motd.
"	"
[
  {
    ""part"": ""m"", 
    ""category"": ""mountpoints"",
    ""desc"": ""mountpoints management commands are used for file operations""
  },
  {
    ""part"": ""c"",
    ""category"": ""cat"",
    ""desc"": ""show contents, similar to Unix cat command""
  },
  {
    ""part"": ""</etc/motd>"",
    ""category"": ""argument"",
    ""desc"": ""path to the file we want to read""
  }
]
"
What's the operating system running in the host machine?	uname	"
When we need system information about the host machine, the standard Unix/Linux command is 'uname'. Since radare2 provides a wrapper around system commands, it makes sense to use the 'uname' command directly. This will show the operating system name, which is exactly what we're looking for. The command is straightforward and doesn't need any additional flags since we just want the basic OS information.
"	"
[{
    ""part"": ""uname"",
    ""category"": ""system"",
    ""desc"": ""Unix command to display system information, specifically the operating system name in this basic form""
}]
"
Retrieve host machine details in JSON format	uname -j	"
Looking at the question, we need system information about the host machine, and specifically want it in JSON format. The 'uname' command is the standard Unix/Linux way to get system information, and since we want JSON output, we'll need a flag for that. Looking at the uname help in radare2, I see there's a -j flag specifically for JSON output. This makes perfect sense as it's a common pattern in radare2 to use -j for JSON output across many commands.
"	"
[
  {
    ""part"": ""uname"", 
    ""category"": ""system"",
    ""desc"": ""base command to show system information""
  },
  {
    ""part"": ""-j"",
    ""category"": ""output_format"",
    ""desc"": ""flag to specify JSON output format""
  }
]
"
Host architecture	uname -a	"
When looking for system information about the host architecture, we need a command that queries system details. The 'uname' command is a standard Unix command for this purpose, and radare2 provides a wrapper for it. Looking through the help, we can see that 'u' command has a subcommand for uname with various options, where -a shows ""all"" system details, which is exactly what we need.
"	"
[
  {
    ""part"": ""u"", 
    ""category"": ""system"",
    ""desc"": ""system-related commands, including uname functionality""
  },
  {
    ""part"": ""name"",
    ""category"": ""system info"",
    ""desc"": ""specific subcommand for system information""
  },
  {
    ""part"": ""-a"",
    ""category"": ""arguments"",
    ""desc"": ""flag to show all system information details""
  }
]
"
Increase the current buffer block by 1 byte	b+1	"
To modify the block size in radare2, we need to use the block size commands. Since we want to increase it by 1 byte, we need a command that can increment the current block size. Looking at the block size commands (b), we can see there's a syntax that allows incrementing using + followed by the number of bytes. This is exactly what we need - increase the current block size by 1 byte.
"	"
[
    {
        ""part"": ""b"", 
        ""category"": ""block"",
        ""desc"": ""block size command - controls working block size""
    },
    {
        ""part"": ""+"",
        ""category"": ""operator"",
        ""desc"": ""increment operator for block size""
    },
    {
        ""part"": ""<1>"",
        ""category"": ""argument"",
        ""desc"": ""number of bytes to increase block size by""
    }
]
"
Change the buffer block size to 128	b 128	"
To change the buffer block size, I need a command that deals with block operations. The block size is a fundamental concept in radare2 that determines how many bytes are processed at once for various operations like printing, analyzing, etc. Looking at the command list, 'b' is the dedicated command for block size operations. Since we want to set it to a specific value (128), we can directly append that number.
"	"
[
  {
    ""part"": ""b"",
    ""category"": ""block"",
    ""desc"": ""block size command - the main command for manipulating the working block size""
  },
  {
    ""part"": ""<128>"",
    ""category"": ""arguments"",
    ""desc"": ""numeric value to set the new block size in bytes""
  }
]
"
Determine the current block size	b	"
When working with binary analysis, we often need to know how many bytes we're working with in the current block. The block size is a fundamental concept in radare2 that determines how many bytes are processed in various operations. The question asks for the current block size, which suggests we need a command that will display this value rather than set it. Looking through the command set, 'b' without any arguments is the most direct way to show the current block size.
"	"
[{
    ""part"": ""b"",
    ""category"": ""block"",
    ""desc"": ""The 'b' command alone shows the current block size. This is the simplest form of the block size command, which when used without arguments acts as a getter rather than a setter""
}]
"
Size of the current basic block	?vi $b	"
To get the size of the current basic block, we need a command that will print a value ($b) as a number. The $b is a special variable in radare2 that represents the current block size.

Looking at the command list, we see that ?v is used to compute expressions and show their values. The 'i' modifier makes it show the value as a decimal number (integer).

So we need to print the value of the block size variable ($b) as an integer.
"	"
[
  {
    ""part"": ""?"",
    ""category"": ""help/evaluate"",
    ""desc"": ""evaluate expressions and values""
  },
  {
    ""cmd"": ""v"",
    ""category"": ""value"",
    ""desc"": ""show value/result of expression""
  },
  {
    ""cmd"": ""i"",
    ""category"": ""integer"",
    ""desc"": ""format output as decimal integer""
  },
  {
    ""cmd"": ""<$b>"",
    ""category"": ""variable"",
    ""desc"": ""special variable representing current block size""
  }
]
"
Current working directory	pwd	"
When looking for a command to show the current working directory, it's natural to think of the standard Unix/Linux command 'pwd' (Print Working Directory). Since radare2 aims to provide familiar command-line experience and often mirrors common shell commands, it makes sense that they would implement 'pwd' in the same way. Looking through the command list, I can see it's directly supported as a basic command under the 'p' (print) family of commands.
"	"
[{
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""print commands are used for displaying information""
}, {
    ""part"": ""w"",
    ""category"": ""working"",
    ""desc"": ""specifies we want information about the working context""
}, {
    ""part"": ""d"",
    ""category"": ""directory"",
    ""desc"": ""indicates we want the current directory path""
}]
"
Analyze all functions referenced from a CALL instruction	aac	"
When analyzing a binary, one of the key tasks is understanding function relationships through call instructions. We need to find all the functions that are being called from other functions. This requires analyzing cross-references created by CALL instructions.

The task needs an analysis command (starting with 'a') that specifically looks at calls. Since we want it automated and focused on calls, 'aac' makes sense - it will analyze all cross-references created by call instructions to identify and create functions at the target addresses.
"	"
[
  {
    ""part"": ""a"", 
    ""category"": ""analysis"",
    ""desc"": ""Analysis command - we need to analyze something""
  },
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""Additional 'a' indicates we want automated analysis""
  },
  {
    ""part"": ""c"",
    ""category"": ""calls"",
    ""desc"": ""Specifies we want to analyze function calls specifically""
  }
]
"
Find all functions calling `system`	axt	"
To find functions calling a specific function like 'system', we need to analyze cross-references (xrefs). Since we want to find who is calling this function, we need to find references TO this address. The command should search through the analyzed code and show us which functions are making calls to 'system'.

The natural thought process would be:
1. We need cross-references (x)
2. We want to find references TO an address (t)
3. We want to analyze (a) these references

This leads us to combine these requirements into a command that looks for cross-references to a given address.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""we start with analysis commands since we're looking through analyzed code""
  },
  {
    ""part"": ""x"",
    ""category"": ""xrefs"",
    ""desc"": ""cross-references are needed to find relationships between functions""
  },
  {
    ""part"": ""t"",
    ""category"": ""to"",
    ""desc"": ""specifically we want references TO our target function (vs 'from' with f)""
  }
]
"
Which functions are calling exit?	axtf sym.imp.exit	"
To find functions calling exit(), we need to:
1. First locate references to the exit symbol (cross references)
2. But specifically we want function-level references, not just any reference
3. The command should combine cross-reference analysis with function filtering

The command builds up naturally:
- ax for cross references
- t to find references TO the target
- f to filter for function-level references only
- Then specify the target symbol sym.imp.exit
"	"
[
  {
    ""part"": ""ax"", 
    ""category"": ""analysis"",
    ""desc"": ""cross reference command to find code/data references""
  },
  {
    ""part"": ""t"",
    ""category"": ""references"", 
    ""desc"": ""find references TO the target (vs from)""
  },
  {
    ""part"": ""f"",
    ""category"": ""functions"",
    ""desc"": ""filter to only show function-level references""
  },
  {
    ""part"": ""<sym.imp.exit>"",
    ""category"": ""arguments"",
    ""desc"": ""the exit() function import symbol to find references to""
  }
]
"
List all syscalls matching by name 	/asl~write	"
To find syscalls by name, I need to first understand what syscalls are available in the current architecture, then filter them to show only the ones matching a specific name pattern.

The 'as' command family deals with syscalls in radare2. To list syscalls I need 'asl' which shows all syscalls for the current architecture. But I want to filter this list to only show entries containing ""write"", so I need to pipe the output through grep using the '~' operator.
"	"
[
  {
    ""part"": ""a"", 
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used to extract information from the binary""
  },
  {
    ""part"": ""s"",
    ""category"": ""syscall"",
    ""desc"": ""syscall subcommands for analyzing system calls""
  },
  {
    ""part"": ""l"",
    ""category"": ""list"",
    ""desc"": ""list all syscalls for current architecture""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter output using internal grep""
  },
  {
    ""part"": ""<write>"",
    ""category"": ""argument"",
    ""desc"": ""pattern to search for in syscall names""
  }
]
"
List config vars in JSON format	ej	"
Looking at this question, we need to display configuration variables in a machine-readable format. Since we need JSON output, we'll need a command that deals with configuration variables (which start with 'e' in radare2) and then specify JSON output (which is typically done with 'j' in radare2).

The 'e' command is used to manage evaluable variables (config vars), and adding 'j' will give us JSON output. This is a common pattern in radare2 where adding 'j' to a command produces JSON output.
"	"
[
  {
    ""part"": ""e"",
    ""category"": ""eval"",
    ""desc"": ""The base command for managing configuration variables""
  },
  {
    ""part"": ""j"",
    ""category"": ""output"",
    ""desc"": ""Modifier to output the results in JSON format""
  }
]
"
Change the local variable named `counter` to use the type `int32_t`	afvt counter int32_t	"
We need to modify a local variable's type in the current function. This is an analysis operation since we're working with function variables. The command should start with 'af' for analysis of functions. Since we're dealing with variables, we add 'v'. Finally, we want to change the type, so 't' makes sense. Then we specify the variable name and its new type.
"	"
[
  {
    ""part"": ""af"",
    ""category"": ""analysis_function"",
    ""desc"": ""analysis command specifically for functions""
  },
  {
    ""cmd"": ""v"",
    ""category"": ""variables"",
    ""desc"": ""operate on function variables""
  },
  {
    ""cmd"": ""t"",
    ""category"": ""type"",
    ""desc"": ""change type of variable""
  },
  {
    ""cmd"": ""<counter>"",
    ""category"": ""arguments"",
    ""desc"": ""name of variable to modify""
  },
  {
    ""cmd"": ""<int32_t>"",
    ""category"": ""arguments"",
    ""desc"": ""new type to assign to the variable""
  }
]
"
Show the type for the local variable named `counter`	afvt argv	"
Looking at the question, we need to find out the type of a local variable named 'counter'. This involves working with function variables, specifically changing or displaying their types.

The command needs to:
1. Work with function variables (afv)
2. Deal with types (t)
3. Target a specific variable name (counter)

The command `afvt` is perfect for this as it's specifically designed to change/show types for function variables. The format is `afvt <varname>`, where varname is the variable we want to inspect.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used for analyzing code and data""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""function-specific commands""
    },
    {
        ""part"": ""v"",
        ""category"": ""variables"",
        ""desc"": ""deals with function variables""
    },
    {
        ""part"": ""t"",
        ""category"": ""types"",
        ""desc"": ""type-related operations on variables""
    },
    {
        ""part"": ""<argv>"",
        ""category"": ""argument"",
        ""desc"": ""the name of the variable whose type we want to see""
    }
]
"
How do I list all function arguments for `main`?	afv~^arg	"
To list function arguments for main, I need to:
1. First analyze the function variables - that's what afv does
2. Then I need to filter the output to only show arguments
3. The ~ operator is for grep/filtering
4. The ^arg pattern will match lines starting with ""arg""

This makes sense because function arguments are stored as variables within a function's scope, and afv shows all function variables. The grep filter ensures we only see the argument-related entries.
"	"
[
  {
    ""part"": ""af"", 
    ""category"": ""analysis"",
    ""desc"": ""analyze function command group""
  },
  {
    ""part"": ""v"",
    ""category"": ""variables"",
    ""desc"": ""show function variables/args/locals""
  },
  {
    ""part"": ""~"",
    ""category"": ""filter"",
    ""desc"": ""grep operator to filter output""
  },
  {
    ""part"": ""^arg"",
    ""category"": ""pattern"",
    ""desc"": ""regex pattern to match lines starting with 'arg'""
  }
]
"
How do I list all basic block references?	abl	"
When working with basic blocks in reverse engineering, you often need to see how they're connected and what references exist between them. The question asks for listing all basic block references, which suggests we need a command that deals with basic block analysis and specifically listing references. Since we're dealing with basic blocks, we'll want to use the 'ab' (analyze basic block) command family, and since we want a list of references, 'l' for list makes sense.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used for examining code structure""
    },
    {
        ""part"": ""b"",
        ""category"": ""basic block"",
        ""desc"": ""narrows down to basic block specific operations""
    },
    {
        ""part"": ""l"",
        ""category"": ""list"",
        ""desc"": ""lists all basic block references in current function""
    }
]
"
Set the calling convention of the `add` function to `cdecl`.	afc cdecl @ sym.add	"
To set a calling convention for a function, we need to modify its function properties. The question specifically wants to set the calling convention to 'cdecl' for the 'add' function. This is a function analysis operation, and since we're working with calling conventions, we'll need the analysis function calling-convention command set. The target location is specified using the symbol name 'sym.add'.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used for analyzing code""
  },
  {
    ""part"": ""f"",
    ""category"": ""function"",
    ""desc"": ""function-specific analysis commands""
  },
  {
    ""part"": ""c"",
    ""category"": ""calling convention"",
    ""desc"": ""manage calling conventions for functions""
  },
  {
    ""part"": ""<cdecl>"",
    ""category"": ""argument"",
    ""desc"": ""the specific calling convention to set""
  },
  {
    ""part"": ""@"",
    ""category"": ""address"",
    ""desc"": ""specify target location""
  },
  {
    ""part"": ""<sym.add>"",
    ""category"": ""argument"",
    ""desc"": ""the function name to apply the calling convention to""
  }
]
"
How do I look for functions that might be doing crypto stuff? Like searching for AES or SHA	afl~crypto,aes,sha,md5;iiccx crypto	"
Looking for crypto functions requires a multi-pronged approach. First, we need to list all functions and filter them for crypto-related names. Then we also want to look at imports that might be calling crypto libraries. The command combines these two approaches:

First part uses `afl` to list functions and filters for common crypto terms. The second part after the semicolon uses `iiccx` to show functions calling crypto-related imports.

This is a smart combination because crypto implementations often either have descriptive names or use well-known crypto libraries through imports. The filter looks for common crypto algorithm names like aes, sha, and md5.
"	"
[
  {
    ""part"": ""afl"", 
    ""category"": ""analysis"",
    ""desc"": ""List all functions - this gives us the full function list to search through""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""Filter the function list""
  },
  {
    ""part"": ""<crypto,aes,sha,md5>"",
    ""category"": ""search terms"",
    ""desc"": ""Common crypto algorithm names to search for""
  },
  {
    ""part"": "";"",
    ""category"": ""separator"",
    ""desc"": ""Chain multiple commands""
  },
  {
    ""part"": ""iiccx"",
    ""category"": ""imports"",
    ""desc"": ""Show functions calling imports of a specific class""
  },
  {
    ""part"": ""<crypto>"",
    ""category"": ""argument"",
    ""desc"": ""Look specifically for crypto-related imports""
  }
]
"
How do I get the size of the instruction pointer by the program counter that is going to be executed 	aos@r:PC	"
Looking at this question, we need to find the size of an instruction at a specific address - the program counter (PC). The key elements are:
1. We need the size of an instruction ('o' for opcode)
2. We want it at a specific register (PC)
3. We need to use register syntax (@r:)

The command builds up naturally:
1. 'a' for analysis commands since we're analyzing an instruction
2. 'o' for opcode analysis
3. 's' for size specifically
4. '@r:PC' to specify we want this at the PC register's location
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis command prefix - we're analyzing something""
    },
    {
        ""part"": ""o"",
        ""category"": ""opcode"",
        ""desc"": ""opcode subcommand - we want to analyze an instruction""
    },
    {
        ""part"": ""s"",
        ""category"": ""size"",
        ""desc"": ""size subcommand - specifically get the size""
    },
    {
        ""part"": ""@r:PC"",
        ""category"": ""location"",
        ""desc"": ""specify the location using register syntax, pointing to Program Counter""
    }
]
"
Seek to the next data block (consider changing the block size with the `b` command)	b++	"
When working with data in radare2, we often need to navigate through blocks of data. The question asks about seeking to the next data block, and mentions the block size command 'b'. This immediately suggests we need to move forward by one block size. 

In radare2, seeking is done with 's' commands, and there's a special syntax for seeking by block size. Since we want to go forward one block, we'd use '++' which is a special seek operator that moves forward by the current block size.
"	"
[
    {""part"": ""b"", ""category"": ""block"", ""desc"": ""indicates we're working with blocks of data""},
    {""part"": ""++"", ""category"": ""operators"", ""desc"": ""special operator to seek forward by block size - this is actually a shorthand for 's++' which seeks forward by block size""}
]
"
Seek to the previous data block (consider changing the block size with the `b` command)	b--	"
When working with data in radare2, we often need to navigate through blocks of data. The block size is a fundamental concept that determines how much data we work with at once. To move backward by one block, we need a command that combines the seek functionality with block size awareness. 

The natural thought process is:
1. We want to seek
2. We want to move backwards
3. We want to move by the current block size

This leads us to use the block-based seek command with a double minus to indicate ""backwards by block size"".
"	"
[
  {
    ""part"": ""b"", 
    ""category"": ""block"",
    ""desc"": ""indicates we're working with block operations""
  },
  {
    ""part"": ""--"",
    ""category"": ""movement"",
    ""desc"": ""double minus indicates seek backwards by block size - similar to how s-- works for seeking""
  }
]
"
How to find the distance between `sym.main` and `sym.hello`	?vi sym.main-sym.hello	"
When we need to find the distance between two symbols, we need to calculate their offset difference. The question is asking about the distance between two symbols `sym.main` and `sym.hello`. In radare2, we can use arithmetic operations on symbols directly. 

The command needs to:
1. Calculate the difference between the two symbol addresses (sym.main-sym.hello)
2. Show the result in a way that's easy to read
3. Handle the value interpretation correctly (not just raw hex)

The `v` command family is perfect for this as it handles value printing and calculations, and `vi` specifically interprets the result as a signed integer, which makes sense when looking for a distance that could be positive or negative.
"	"
[
  {
    ""part"": ""v"", 
    ""category"": ""values"",
    ""desc"": ""value processing command to evaluate expressions""
  },
  {
    ""part"": ""i"",
    ""category"": ""format"",
    ""desc"": ""interpret result as signed integer""
  },
  {
    ""part"": ""<sym.main-sym.hello>"",
    ""category"": ""expression"",
    ""desc"": ""arithmetic expression calculating difference between two symbols""
  }
]
"
Considering the current instruction is a branch, jump or call, follow the jump destination	s $j	"
When analyzing code, one of the most common needs is following control flow - especially when looking at branches, jumps or calls. The question indicates we want to follow where a jump/branch/call goes to.

In radare2, the current instruction's jump destination is stored in a special variable $j. So to follow that destination, we need to seek (change our current position) to that address.

The most basic and direct way to do this is using the seek command 's' followed by the address we want to go to. Since we want to go to the jump destination stored in $j, we can use 's $j'.
"	"
[
  {
    ""part"": ""s"",
    ""category"": ""seek"",
    ""desc"": ""The seek command is used to change the current position in the file/memory""
  },
  {
    ""part"": ""<$j>"", 
    ""category"": ""variable"",
    ""desc"": ""Special variable that contains the jump destination address of the current instruction""
  }
]
"
Considering the instruction in the current address is a conditional jump or call, follow the fallback destination when the condition does not match	s $f	"
When dealing with conditional jumps/calls, we need a way to follow the code path when the condition is NOT met (the fallback path). Looking at the current address, we want to seek to where execution would continue if the condition fails.

In assembly, when a conditional instruction fails, execution continues to the next instruction after the jump/call. This is known as the fallback address.

Looking through the command help, we can see that 's' is for seeking, and there's a special flag variable '$f' that contains ""jump fail address (e.g. jz 0x10 => next instruction)"". This is exactly what we need - seeking to the address where execution would continue if the jump fails.
"	"
[
  {
    ""part"": ""s"",
    ""category"": ""seek"",
    ""desc"": ""We need to change current position, so seek command is appropriate""
  },
  {
    ""cmd"": ""$f"",
    ""category"": ""variables"", 
    ""desc"": ""Special flag variable that contains the fallback address for conditional jumps/calls""
  }
]
"
Get the size of the flag named `section.0.__TEXT.__text`	?vi $s{section.0.__TEXT.__text}	"
To get the size of a flag, we need to use the special syntax for flag sizes in radare2. The question is asking for the size of a specific flag related to a text section. The command uses `?v` to evaluate an expression, with `i` for immediate value, and then uses the special syntax `$s{flagname}` which returns the size of the specified flag. This is a common pattern when working with sections and flags in r2.
"	"
[
  {""part"": ""?"", ""category"": ""evaluate"", ""desc"": ""evaluate expressions and print results""},
  {""part"": ""v"", ""category"": ""value"", ""desc"": ""print immediate value""},
  {""part"": ""i"", ""category"": ""immediate"", ""desc"": ""show value as immediate number""},
  {""part"": ""$s{<section.0.__TEXT.__text>}"", ""category"": ""flag_size"", ""desc"": ""get size of specified flag using special syntax""}
]
"
Count the amount of basic blocks the function in the current address have	afi~^num-bbs[1]	"
We need to get information about the function at the current address and specifically extract the number of basic blocks it contains. This is a common analysis task that requires:
1. Getting function information (which is done with `afi`)
2. Filtering the output to find the line containing basic block count
3. Extracting just the number

The command uses `afi` to analyze and get function info, then uses grep (`~`) with `^num-bbs` to match the line starting with ""num-bbs"", and `[1]` to get the second column which contains the actual number.
"	"
[
  {
    ""part"": ""af"", 
    ""category"": ""analysis"",
    ""desc"": ""analyze function command prefix""
  },
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""get detailed info about current function""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output with grep""
  },
  {
    ""part"": ""^num-bbs"",
    ""category"": ""regex"",
    ""desc"": ""match line starting with num-bbs""
  },
  {
    ""part"": ""[1]"",
    ""category"": ""column-select"",
    ""desc"": ""select the second column containing the number""
  }
]
"
Count how many instructions this function have	afi~^num-ins[1]	"
To count instructions in a function, we need to analyze function information and filter for the specific field that shows instruction count. Looking at the help, 'afi' provides function information in a detailed format, and we want to extract just the number of instructions. The tilde (~) operator allows us to filter the output, and we want to specifically match the line starting with ""num-ins"" and get its second column (index [1]).
"	"
[
  {
    ""part"": ""af"",
    ""category"": ""analysis"",
    ""desc"": ""analyze function command prefix""
  },
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""show detailed function information""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter output using grep-like syntax""
  },
  {
    ""part"": ""^num-ins"",
    ""category"": ""regex"",
    ""desc"": ""match line starting with 'num-ins'""
  },
  {
    ""part"": ""[1]"",
    ""category"": ""column-select"",
    ""desc"": ""select the second column (the actual number)""
  }
]
"
Lowest address for the current function	afi~^minbound[1]	"
To find the lowest address of the current function, we need to:
1. Get information about the current function
2. Filter that information to find the minimum boundary
3. Extract just the value we need

The command 'afi' gives detailed function information, including boundaries. The filter using '~' with '^minbound' will match the line starting with ""minbound"", and [1] will get the second column which contains the actual address value.
"	"
[
  {
    ""part"": ""af"",
    ""category"": ""analysis"",
    ""desc"": ""analyze function command prefix""
  },
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""detailed information about current function""
  },
  {
    ""part"": ""~"",
    ""category"": ""filter"",
    ""desc"": ""grep-like filter to search output""
  },
  {
    ""part"": ""^minbound"",
    ""category"": ""regex"",
    ""desc"": ""match line starting with 'minbound'""
  },
  {
    ""part"": ""[1]"",
    ""category"": ""column select"",
    ""desc"": ""select the second column containing the address value""
  }
]
"
Maximum address for the current function	afi~^maxbound[1]	"
To find the maximum address of the current function, we need to:
1. Get function information - that's what 'af' commands do
2. Get detailed info about the function - that's what 'afi' does
3. Filter the output to find the max boundary - need to use grep (~) 
4. Get specifically the first column after ""maxbound"" - that's what [1] does

The command combines function analysis info with grep filtering to extract just the maximum boundary address from the function info output.
"	"
[
  {
    ""part"": ""af"", 
    ""category"": ""analysis_function"",
    ""desc"": ""analyze function command group""
  },
  {
    ""part"": ""i"",
    ""category"": ""info"",
    ""desc"": ""get detailed information about the function""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output using grep""
  },
  {
    ""part"": ""^maxbound"",
    ""category"": ""regex"",
    ""desc"": ""match lines starting with 'maxbound'""
  },
  {
    ""part"": ""[1]"",
    ""category"": ""column_select"", 
    ""desc"": ""select the first column after the match""
  }
]
"
Is this function calling itself? It is recurisve?	afi~^recursive	"
To determine if a function is recursive, we need to analyze function information and specifically look for the recursive attribute. The question is asking about recursion, so we need to:
1. Get function information (afi)
2. Filter the output to only show lines containing ""recursive""
3. The ^ in the grep means ""starting with"" to avoid false matches
"	"
[
  {
    ""part"": ""af"", 
    ""category"": ""analysis"",
    ""desc"": ""analyze function - get detailed info about current function""
  },
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""show detailed information about the analyzed function""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""filter the output""
  },
  {
    ""part"": ""^recursive"",
    ""category"": ""regex"",
    ""desc"": ""match lines starting with 'recursive' to find this specific attribute""
  }
]
"
What prints the current time?	pt.	"
When looking for time-related commands, I first think about where this would logically be categorized. Since it's about printing data, it makes sense to start with 'p' for print commands. Within the print commands, 't' is commonly used for ""time"" in many tools. Looking at the help, I can see `pt` is indeed for timestamps. The dot modifier is often used in radare2 to reference the ""current"" state or value. So `pt.` would naturally print the current time rather than converting a value at the current address.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""Print command - the base command for outputting data""
  },
  {
    ""cmd"": ""t"",
    ""category"": ""time"",
    ""desc"": ""Timestamp subcommand - specifically for handling time-related output""
  },
  {
    ""cmd"": ""."",
    ""category"": ""current"",
    ""desc"": ""Modifier to show current time rather than converting a value""
  }
]
"
List all strings in current block	psb	"
Looking at this question, we need to list strings in the current block of memory. This is clearly a printing operation, and specifically for strings. Since we want to list ALL strings in the current block, we need a command that will scan through the block and identify all string-like sequences. Looking at the ps family of commands, 'psb' specifically handles this use case - it's designed to print strings found in the current block rather than just a single string at the current offset.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""This is a print command, as we want to output/display data""
  },
  {
    ""part"": ""s"",
    ""category"": ""string"",
    ""desc"": ""We're specifically dealing with strings, so 's' modifier is needed""
  },
  {
    ""part"": ""b"",
    ""category"": ""block"",
    ""desc"": ""The 'b' specifies we want to operate on the entire current block rather than just at current offset""
  }
]
"
Fun way to view hex with emojis	pxe	"
Looking at a way to display hex values, but make it more visually interesting or fun. Since we want to view hex data, we'll start with the 'p' command for printing. We need hex output, so 'px' is the base hexdump command. The 'e' modifier makes it fun by converting the hex values to emojis - this is a creative way to visualize binary data that might help spot patterns or just make the analysis more enjoyable.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""Base printing command, needed to output data""
  },
  {
    ""part"": ""x"",
    ""category"": ""hex"",
    ""desc"": ""Specifies hexadecimal output format""
  },
  {
    ""part"": ""e"",
    ""category"": ""visualization"",
    ""desc"": ""Converts hex values to emoji representations for a fun visualization""
  }
]
"
Print pascal string in the current offset	psp	"
We need to print a pascal string, which is a string format where the first byte indicates the length of the string, followed by the actual string data. This is different from null-terminated strings. Given we need to print one, we'll want to use a print command that's specifically designed for pascal strings.

Looking through the print commands (p), we see there's a specific set of commands for strings (ps) and within that, a dedicated command for pascal strings (psp). This makes perfect sense as it will read the first byte as length and then print the following bytes as a string.
"	"
[
    {
        ""part"": ""p"",
        ""category"": ""print"",
        ""desc"": ""We start with print command as we want to output data""
    },
    {
        ""cmd"": ""s"",
        ""category"": ""string"",
        ""desc"": ""Specifies we want to print string data""
    },
    {
        ""cmd"": ""p"",
        ""category"": ""pascal"",
        ""desc"": ""Indicates we want to handle the string as a pascal string (length-prefixed)""
    }
]
"
Show hexdump until hitting a null byte	px0	"
We need to show data in hexadecimal format, but only until we hit a null byte (0x00). This is commonly used when dealing with C-style strings or looking at null-terminated data structures. Since we're looking at hex data, we'll start with the 'p' command for printing, followed by 'x' for hex format. The '0' modifier tells it to stop at the first null byte rather than continuing for a fixed length.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command is the base for data visualization""
  },
  {
    ""part"": ""x"",
    ""category"": ""format"",
    ""desc"": ""specifies hexadecimal output format""
  },
  {
    ""part"": ""0"",
    ""category"": ""modifier"",
    ""desc"": ""tells the command to stop at first null byte (0x00)""
  }
]
"
Show current basic block bytes in hexpair string format	p8b	"
To show bytes of the current basic block, we need a command that prints bytes in hexadecimal format, but specifically for a basic block. Looking at the print commands ('p'), we need something that shows raw bytes in hexpair format ('8'), and we want to limit it to the current basic block ('b'). The command needs to combine these capabilities to print the hexadecimal representation of bytes in the current basic block.
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""Print command is needed as we want to display data""
  },
  {
    ""cmd"": ""8"",
    ""category"": ""format"",
    ""desc"": ""Specifies output as 8bit hexpair format"" 
  },
  {
    ""cmd"": ""b"",
    ""category"": ""scope"",
    ""desc"": ""Limits the operation to the current basic block""
  }
]
"
Parse X509 certificate	pFx	"
Looking at a request to parse an X.509 certificate. This is a common digital certificate format used in PKI and SSL/TLS. We need a command that can handle binary ASN.1 DER encoded data, which is how X.509 certs are structured. The command needs to parse and display the certificate fields in a readable format.

Looking at the available commands, I see the pF family of commands is dedicated to parsing various binary formats. Since X.509 is a specific format, I'd expect to find a dedicated subcommand for it.
"	"
[
  {
    ""part"": ""p"", 
    ""category"": ""print"",
    ""desc"": ""Print command - we want to output/display data""
  },
  {
    ""part"": ""F"",
    ""category"": ""format"",
    ""desc"": ""Format parser - used for parsing structured binary data formats""
  },
  {
    ""part"": ""x"",
    ""category"": ""x509"",
    ""desc"": ""X.509 specific parser - tells pF to interpret the data as an X.509 certificate""
  }
]
"
Decode PKCS7 format	pFp	"
Looking at the question, we need to decode PKCS7 format data. PKCS7 is a cryptographic standard used for signing and encrypting data, so we'd want a command that can parse and display this format. Since this is a specialized format, it would likely be under a dedicated parsing or format-related command. Looking through the help, we can see the pF command family is designed for parsing various formats like ASN1, PKCS, X509, etc. The 'p' prefix indicates printing/parsing, and 'F' is for format-specific operations. The 'p' suffix specifically targets PKCS7 format.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""Print command prefix, indicating output/display operation""
  },
  {
    ""part"": ""F"",
    ""category"": ""format"",
    ""desc"": ""Format-specific parsing, used for structured data formats like ASN1, PKCS, etc.""
  },
  {
    ""part"": ""p"",
    ""category"": ""pkcs"",
    ""desc"": ""Specifically targets PKCS7 format parsing and display""
  }
]
"
Show ASN1 object identifiers	pFo	"
Looking at the question, we need to display ASN1 object identifiers. ASN1 is a standard notation for data structures used in cryptography and telecommunications. The object identifiers (OIDs) are unique identifiers for objects in ASN1.

Looking through the commands, I see pF is the base command for parsing various formats like ASN1, PKCS, X509, etc. Since we specifically want object identifiers, we need the 'o' subcommand to parse and display OIDs.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""Print command - the base for most data display operations""
  },
  {
    ""part"": ""F"",
    ""category"": ""format"",
    ""desc"": ""Parse and print formatted data structures like ASN1, PKCS, etc.""
  },
  {
    ""part"": ""o"",
    ""category"": ""oid"",
    ""desc"": ""Specifically parse and show ASN1 Object Identifiers""
  }
]
"
Parse iOS PLIST binary	pFB	"
When dealing with iOS binary files, we often need to parse PLIST (Property List) files which are used to store serialized objects. The question asks for a way to parse binary PLIST files, so we need a command that handles file parsing ('p' commands) and specifically binary formats ('F' commands). Looking through the help, we can see that pF commands are specifically designed for parsing various binary formats, and pFB is dedicated to iOS Binary PLIST parsing.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""Print command, used as base for all data printing/parsing operations""
  },
  {
    ""part"": ""F"",
    ""category"": ""format"",
    ""desc"": ""Indicates we want to parse a specific binary format (like ASN1, PKCS, protobuf, etc)""
  },
  {
    ""part"": ""B"",
    ""category"": ""binary_plist"",
    ""desc"": ""Specifies we want to parse an iOS Binary PLIST format""
  }
]
"
Decode protobuf content	pFb	"
Looking at this question about decoding protobuf content, I know we need a command that can parse and display protocol buffer data. Protocol buffers are a binary serialization format, so we need a specialized parser. Looking at the command set, the 'pF' commands are specifically for parsing various structured formats (ASN1, PKCS, XML, etc). The 'b' suffix would naturally indicate ""protocol buffer"" format.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""Print command is the base for displaying data in different formats""
  },
  {
    ""part"": ""F"",
    ""category"": ""format"",
    ""desc"": ""Capital F indicates we want to parse a structured format rather than just raw bytes""
  },
  {
    ""part"": ""b"",
    ""category"": ""protobuf"",
    ""desc"": ""Specifies protocol buffer format as the parsing target""
  }
]
"
Parse and show ASN1/DER data	pFa	"
When dealing with ASN1/DER data, we need a specialized parser to handle the structured format. ASN.1 (Abstract Syntax Notation One) and DER (Distinguished Encoding Rules) are complex encoding formats commonly used in cryptographic certificates, keys and other security-related data.

Looking at the commands available, I see we need the File format parser command group (pF) which handles various structured binary formats. Since we specifically want ASN1/DER parsing, we need the 'a' subcommand which is dedicated to ASN1/DER decoding.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""We start with print as we want to display/show the data""
  },
  {
    ""part"": ""F"",
    ""category"": ""format"",
    ""desc"": ""Capital F indicates we want to parse a specific file format""
  },
  {
    ""part"": ""a"",
    ""category"": ""asn1"",
    ""desc"": ""Specifies ASN1/DER as the format to parse and display""
  }
]
"
Decode Android XML binary	pFA	"
Looking at the question, we need to decode Android Binary XML format. This is a common task when analyzing Android APKs since many important files like AndroidManifest.xml and layout files are stored in a binary format for space efficiency and faster parsing.

Looking through the commands, I see it falls under the 'pF' family which handles parsing of various structured file formats. The 'pF' command is used for parsing ASN1, PKCS, X509, DER, protobuf and Android XML formats - exactly what we need.

Since we specifically want to handle Android Binary XML, we need the 'A' subcommand to specify that format. The command will parse and display the XML in a human-readable format.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""Print command - we want to output/display something""
  },
  {
    ""cmd"": ""F"",
    ""category"": ""format"",
    ""desc"": ""Parse structured formats - this handles various binary formats like ASN1, protobuf, etc.""
  },
  {
    ""cmd"": ""A"",
    ""category"": ""android"",
    ""desc"": ""Specifies Android Binary XML format parsing""
  }
]
"
Display hexdump with annotated comments, bookmarks and flags	pxa	"
When looking at a hexdump, sometimes you want more context than just raw bytes. The question asks for a hexdump with annotations, which means we need something more detailed than a basic hex view. We need the 'print' command family since we're displaying data, and specifically a hex variant that shows additional metadata like comments, bookmarks and flags alongside the hex values.

The natural progression would be:
1. We need a print command (p)
2. We want hex format (x)
3. We want annotations (a)
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""Print command - the base command for displaying data""
  },
  {
    ""cmd"": ""x"",
    ""category"": ""format"",
    ""desc"": ""Specifies hexadecimal output format""
  },
  {
    ""cmd"": ""a"",
    ""category"": ""display"",
    ""desc"": ""Adds annotations - shows comments, bookmarks and flags alongside the hex values""
  }
]
"
Decode data from address 0x450032 as base64	p6d @ 0x450032	"
Looking at this question, we need to decode base64 data at a specific address. Breaking this down:
1. We need to print/decode something (p command family)
2. Since we're dealing with base64, we need the base64 decoder command (6)
3. We want to decode rather than encode (d)
4. And we need to do this at a specific address (@ syntax)

The command makes sense because it combines base64 decoding with address specification to decode data stored at that memory location.
"	"
[
    {""part"": ""p"", ""category"": ""print"", ""desc"": ""print command family - we need to output something""},
    {""part"": ""6"", ""category"": ""encoding"", ""desc"": ""specifies base64 operation mode""},
    {""part"": ""d"", ""category"": ""decode"", ""desc"": ""specifies decode operation (as opposed to encode)""},
    {""part"": ""@"", ""category"": ""addressing"", ""desc"": ""indicates we're specifying an address to operate on""},
    {""part"": ""<0x450032>"", ""category"": ""argument"", ""desc"": ""the specific memory address to decode from""}
]
"
Generate 32 space separated 4 digit PIN patterns	ppn 32	"
You need to generate PIN patterns, which are typically 4-digit numeric codes. The question asks for 32 of them, space-separated. Looking at the pattern generation commands under `pp`, we find `ppn` which is specifically designed for numeric PIN patterns.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command is the base for pattern operations""
  },
  {
    ""part"": ""p"",
    ""category"": ""pattern"",
    ""desc"": ""second p indicates we're working with patterns""
  },
  {
    ""part"": ""n"",
    ""category"": ""numeric"",
    ""desc"": ""n specifies we want numeric PIN patterns""
  },
  {
    ""part"": ""<32>"",
    ""category"": ""argument"",
    ""desc"": ""number of patterns to generate""
  }
]
"
Display code analysis coverage. How much executable region is code 	a~^per[1]	"
To find code analysis coverage, we need to analyze the binary and then get statistics about it. The question wants to know what percentage of the executable regions contain valid code.

The 'a' command is for analysis, and we need to filter the output to only show the percentage. The filter needs to look for lines starting with ""per"" and take the first column.

This makes sense because running analysis will show stats about the code coverage, including percentages, and we can extract just that number.
"	"
[
  {
    ""part"": ""a"", 
    ""category"": ""analysis"",
    ""desc"": ""Run analysis command to get code statistics""
  },
  {
    ""part"": ""~"",
    ""category"": ""grep"",
    ""desc"": ""Filter the output using grep""
  },
  {
    ""part"": ""^per"",
    ""category"": ""regex"",
    ""desc"": ""Match lines starting with 'per'""
  },
  {
    ""part"": ""[1]"",
    ""category"": ""column select"",
    ""desc"": ""Take the first column of the matched line""
  }
]
"
Find new functions by scanning for function preludes	aap	"
To find new functions in a binary, we need to analyze the code. One effective way is to look for function preludes - these are common instruction patterns that typically appear at the start of functions, like ""push ebp"" in x86. Since this is an analysis task, we'll want an analysis command, and since we specifically want to find preludes, there should be a dedicated command for this common task.

Looking through the help, under the 'aa' (analyze all) family of commands, there's 'aap' which specifically does prelude scanning. This makes perfect sense as a way to quickly identify potential function starts without doing a full recursive analysis.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used for examining code structure""
    },
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""second 'a' indicates this is an automated analysis command""
    },
    {
        ""part"": ""p"",
        ""category"": ""preludes"",
        ""desc"": ""specifically targets function preludes, which are common patterns at function starts""
    }
]
"
Find the path between sym.main and sym.usage listing the addresses of the basic blocks involved	abp sym.usage @ sym.main	"
We need to analyze the path between two functions by listing their basic blocks. This is a control flow analysis task, and since we're looking for a path between specific points, we need a command that can handle basic block path analysis. Looking at the commands, we need something that works with basic blocks ('ab' commands) and specifically can find paths ('abp'). The command needs to start from sym.main and find its way to sym.usage, so we use the @ operator to set the starting point at sym.main.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""Analysis commands are needed for working with program structure""
  },
  {
    ""part"": ""b"",
    ""category"": ""basic blocks"",
    ""desc"": ""We're working with basic blocks which are fundamental units of code""
  },
  {
    ""part"": ""p"",
    ""category"": ""path"",
    ""desc"": ""Find paths between blocks""
  },
  {
    ""part"": ""<sym.usage>"",
    ""category"": ""argument"",
    ""desc"": ""Target function we want to reach""
  },
  {
    ""part"": ""@"",
    ""category"": ""operator"",
    ""desc"": ""At operator to specify where to start the analysis""
  },
  {
    ""part"": ""<sym.main>"",
    ""category"": ""argument"",
    ""desc"": ""Starting point for the path analysis""
  }
]
"
Colorize in red the basic block at address 0x102030	abc red @ 0x102030	"
Looking at this question, we need to colorize a specific basic block at a given address. This is a task related to basic block manipulation and visualization. The address is provided (0x102030) and we want to color it red.

Looking through the commands, we find 'ab' which deals with basic blocks, and specifically 'abc' which handles coloring of basic blocks. The syntax allows us to specify a color and an address.

The command is structured to color ('abc') with the color 'red' at the specific address ('@ 0x102030'). This is a way to visually distinguish this basic block from others, which can be useful for analysis and visualization purposes.
"	"
[
  {
    ""part"": ""ab"", 
    ""category"": ""analysis_basicblock"",
    ""desc"": ""basic block commands, needed for block operations""
  },
  {
    ""cmd"": ""c"",
    ""category"": ""color"",
    ""desc"": ""specifies we want to color the block""
  },
  {
    ""cmd"": ""<red>"",
    ""category"": ""arguments"",
    ""desc"": ""the color we want to apply""
  },
  {
    ""cmd"": ""@"",
    ""category"": ""address_specifier"",
    ""desc"": ""indicates we're specifying an address""
  },
  {
    ""cmd"": ""<0x102030>"",
    ""category"": ""address"",
    ""desc"": ""the specific address where we want to apply the color""
  }
]
"
How do I find uses of `alloca` which might lead to stack exhaustion bugs?	/r sym.imp.alloca	"
To find potential stack exhaustion bugs involving alloca(), we need to find all cross-references to where alloca is used in the code. Since alloca() allocates space on the stack frame of the current function, finding places where it's called with large or unchecked values could indicate stack overflow vulnerabilities.

The question implies we need to search for references to the alloca symbol. The /r command is perfect for this as it searches for references to a specific address or symbol. We want to look specifically at the imported alloca symbol (sym.imp.alloca).
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""Initiate a search command""
  },
  {
    ""part"": ""r"",
    ""category"": ""references"", 
    ""desc"": ""Search for references/cross-references""
  },
  {
    ""part"": ""<sym.imp.alloca>"",
    ""category"": ""symbol"",
    ""desc"": ""The imported symbol name for alloca function""
  }
]
"
How can I print the decompiled output of a function using the internal pseudo-disasm representation?	pdc	"
When dealing with functions, we often want to see a higher-level representation than pure assembly. The question asks specifically about decompiled output using pseudo-disassembly, which suggests we need a print command that can show function contents in a C-like syntax. The 'pdc' command is perfect for this as it uses r2's internal pseudo-decompiler to present the function in a more readable format. This is particularly useful when you want to quickly understand the logic of a function without dealing with raw assembly instructions.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command, the base for most output operations""
  },
  {
    ""cmd"": ""d"",
    ""category"": ""disassembly"",
    ""desc"": ""indicates we want to work with disassembled code""
  },
  {
    ""cmd"": ""c"",
    ""category"": ""decompile"",
    ""desc"": ""specifies we want the C-like pseudo-code output format""
  }
]
"
How do I identify calls to potentially dangerous functions like popen?	/r sym.imp.popen	"
When looking for dangerous functions like popen, we want to search for references to that symbol in the code. The question specifically mentions popen, which would be imported as an external symbol. In radare2, external symbols are typically prefixed with ""sym.imp."". To find all references to this function, we need to use the reference search command (/r) followed by the symbol name.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""base search command to find patterns""
  },
  {
    ""part"": ""r"",
    ""category"": ""references"",
    ""desc"": ""specifies we want to search for references to something""
  },
  {
    ""part"": ""<sym.imp.popen>"",
    ""category"": ""argument"",
    ""desc"": ""the specific imported symbol we're searching for, prefixed with sym.imp. to match the import table entry""
  }
]
"
What command searches for UTF-16 `foo` string?	/w foo	"
Looking for a string in UTF-16 format means we need a search command that handles wide characters. In UTF-16, each character takes 2 bytes, so 'foo' would be stored as 'f\0o\0o\0'. The question asks for a way to search for ""foo"" in this format.

Starting with '/' which is the base search command, we need a modifier that handles wide-character strings. Looking at the /? help, we see '/w' is specifically designed for searching wide strings, which is exactly what we need for UTF-16.
"	"
[
    {
        ""part"": ""/"",
        ""category"": ""search"",
        ""desc"": ""Base search command - starts all search operations""
    },
    {
        ""part"": ""w"",
        ""category"": ""modifier"",
        ""desc"": ""Wide-string search modifier for UTF-16 encoding""
    },
    {
        ""part"": ""<foo>"",
        ""category"": ""argument"",
        ""desc"": ""The string to search for, will be converted to UTF-16 format internally""
    }
]
"
How do I view all the memory maps of a process?	dm	"
When working with a process in a debugger, one of the most fundamental things you need to understand is how memory is laid out. The memory maps show you where different segments like code, data, stack, and heap are located. Since this is about viewing memory information, and we're dealing with process memory maps, we need a command that deals with memory operations. The 'm' commands in radare2 typically deal with memory operations, and since we want to see the maps specifically, 'dm' (debug maps) is the natural choice.
"	"
[
    {
        ""part"": ""d"",
        ""category"": ""debug"",
        ""desc"": ""debug commands are used when working with live processes""
    },
    {
        ""part"": ""m"",
        ""category"": ""maps"",
        ""desc"": ""maps subcommand shows memory layout information""
    }
]
"
How can I show the function's cyclomatic complexity?	afC	"
When analyzing code quality and complexity, cyclomatic complexity is a key metric that measures the number of linearly independent paths through a function. Since we're dealing with function analysis, we'll need something in the 'af' (analyze function) family of commands. The cyclomatic complexity is specifically what we want to measure, so we need something that calculates this metric. Looking at the function analysis commands, afC stands out as the specific command for this purpose.
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used for code analysis""
    },
    {
        ""part"": ""f"",
        ""category"": ""function"",
        ""desc"": ""narrows down to function-specific analysis""
    },
    {
        ""part"": ""C"",
        ""category"": ""complexity"",
        ""desc"": ""specifically calculates cyclomatic complexity of the current function""
    }
]
"
How do I change the current block size?	b 256	"
When working with binary analysis, you often need to control how much data you're working with at once. The block size is a fundamental concept in radare2 that determines how many bytes are processed in various commands. If you want to change this, you'd need a command that directly modifies this parameter. Looking at the basic command set, 'b' is the command that deals with block size operations.
"	"
[
    {
        ""part"": ""b"",
        ""category"": ""block"",
        ""desc"": ""The block command is specifically designed to manage block size""
    },
    {
        ""part"": ""<256>"",
        ""category"": ""arguments"",
        ""desc"": ""The numeric argument specifies the new block size in bytes""
    }
]
"
How do I scan the binary for ROP gadgets?	/R	"
To find ROP gadgets, we need a command that can search through the binary and identify sequences of instructions that end in a return. This is a common task in exploit development and reverse engineering. The search command in radare2 is ""/"" and since ROP gadgets are a specific type of search, it makes sense to look for a specialized version of the search command. Looking at the help, /R is specifically designed for ROP gadget searching.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""base search command - we're looking for something in the binary""
  },
  {
    ""part"": ""R"",
    ""category"": ""rop"",
    ""desc"": ""specifies we want to search for ROP gadgets specifically - capital R indicates a specialized search mode for return-oriented programming sequences""
  }
]
"
How do I identify the compiler used in this binary?	i~^compiler	"
Looking at the binary information would be key to finding compiler details. The 'i' command shows information about the binary, but there's a lot of output. We need to filter it to just show compiler-related information. The '~' operator acts as a grep, and the '^compiler' pattern will match lines starting with ""compiler"", which is exactly what we want to see in the binary information.
"	"
[
    {
        ""part"": ""i"",
        ""category"": ""information"",
        ""desc"": ""shows binary information and metadata""
    },
    {
        ""part"": ""~"",
        ""category"": ""grep"",
        ""desc"": ""filters the output""
    },
    {
        ""part"": ""^compiler"",
        ""category"": ""pattern"",
        ""desc"": ""matches lines starting with 'compiler' in the output""
    }
]
"
How can I search for all conditional jumps?	/at cjmp	"
When searching for specific instruction types in a binary, we need a search command that understands assembly. The question asks specifically about conditional jumps, which are a specific type of instruction. Looking at the help, we can see that /a is for searching assembly instructions, and /at is specifically for searching by instruction type. The 'cjmp' parameter tells it to look for conditional jumps specifically.

The search command (/) with assembly type (at) searching for conditional jumps (cjmp) is the most direct way to find all conditional jump instructions in the current binary.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""Base search command to find patterns in memory""
  },
  {
    ""cmd"": ""a"",
    ""category"": ""assembly"",
    ""desc"": ""Specifies we want to search for assembly instructions""
  },
  {
    ""cmd"": ""t"",
    ""category"": ""type"",
    ""desc"": ""Indicates we want to search by instruction type""
  },
  {
    ""cmd"": ""<cjmp>"",
    ""category"": ""argument"",
    ""desc"": ""The type of instruction we're looking for - conditional jumps""
  }
]
"
What to demangle the symbol string '_T3foo4bara' using the c++ demangler?	'iD cxx _T3foo4bara	"
Looking at this question, we need to demangle a symbol string that appears to be mangled using C++ name mangling. The string '_T3foo4bara' looks like a mangled symbol that needs to be converted back to its human-readable form. 

In radare2, symbol demangling is typically handled through the 'i' (information) commands since it's related to binary information analysis. When dealing with symbols and their representations, we need something that can handle different demangling schemes, which points us to the 'iD' command that specifically handles demangling with support for different languages.

The key elements needed are:
1. The demangler type (cxx for C++)
2. The mangled symbol to decode
"	"
[
    {
        ""part"": ""i"",
        ""category"": ""information"",
        ""desc"": ""information command - used for getting details about the binary and its contents""
    },
    {
        ""part"": ""D"",
        ""category"": ""demangle"",
        ""desc"": ""specifies we want to demangle a symbol""
    },
    {
        ""part"": ""<cxx>"",
        ""category"": ""argument"",
        ""desc"": ""specifies C++ as the demangling scheme to use""
    },
    {
        ""part"": ""<_T3foo4bara>"",
        ""category"": ""argument"",
        ""desc"": ""the actual mangled symbol string we want to demangle""
    }
]
"
List all the noreturn symbol names and function addresses	tn	"
We need to list functions that are marked as ""noreturn"" - these are functions that never return to their caller, like exit() or abort(). This is important for analysis and control flow understanding. The command should be in the 't' category since it deals with types and analysis metadata. Looking through the help, I see 'tn' is specifically for managing noreturn marks, and using it without arguments lists them all.
"	"
[
  {
    ""part"": ""t"",
    ""category"": ""types"",
    ""desc"": ""Types command category - since we're dealing with function metadata""
  },
  {
    ""cmd"": ""n"",
    ""category"": ""noreturn"",
    ""desc"": ""List noreturn functions - when used without arguments it shows all noreturn marks""
  }
]
"
How do I search for all indirect jumps?	/at jmp	"
When looking for specific types of instructions in a binary, we need a search command that understands assembly. The question asks for indirect jumps, which are a specific type of jump instruction where the destination is determined at runtime (like `jmp eax`).

Starting with '/' tells me this is a search command. But we need a specialized search that understands instruction types. Looking at the search subcommands, 'at' stands out as it's for searching by instruction types. Since we're looking for indirect jumps specifically, we provide 'jmp' as the type argument.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""initiate a search operation""
  },
  {
    ""cmd"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""specify that we want to search in analyzed code""
  },
  {
    ""cmd"": ""t"",
    ""category"": ""type"",
    ""desc"": ""indicate we want to search by instruction type""
  },
  {
    ""cmd"": ""<jmp>"",
    ""category"": ""argument"",
    ""desc"": ""specify we want to find jump instructions""
  }
]
"
How do I search for all call instructions?	/at call	"
To find all call instructions in the binary, we need to search through the code. Since we're looking specifically for instructions of a certain type (calls), we'll want to use the instruction type search feature. Looking through the search commands (/), there's a specific subcommand for searching by instruction type (/at). Since we want to find CALL instructions specifically, we'll use ""call"" as the type argument.

This makes sense because:
1. We need to search (/) through the code
2. We want to find instructions by their type (at)
3. We specifically want call instructions
"	"
[
  {
    ""part"": ""/"", 
    ""category"": ""search"",
    ""desc"": ""Search command - the main way to find things in r2""
  },
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""Analysis-based search, working with code rather than raw bytes""
  },
  {
    ""part"": ""t"",
    ""category"": ""type"",
    ""desc"": ""Search by instruction type rather than specific bytes or strings""
  },
  {
    ""part"": ""<call>"",
    ""category"": ""argument"",
    ""desc"": ""The specific instruction type we want to find - call instructions""
  }
]
"
How do I search for all call to register?	/at rcall	"
When searching for specific types of instructions, we need to use the `/a` command family which handles assembly-level searches. Since we want to find a specific type of instruction (calls to registers), we'll want to use the type-based search `/at`. The parameter `rcall` specifies we're looking for register calls specifically.

This is a powerful way to find all instructions that perform calls using registers as their target, which is often useful for analyzing indirect calls or function pointers.
"	"
[
  {
    ""part"": ""/"",
    ""category"": ""search"",
    ""desc"": ""base search command""
  },
  {
    ""part"": ""a"",
    ""category"": ""assembly"",
    ""desc"": ""specifies we're searching for assembly instructions""
  },
  {
    ""part"": ""t"",
    ""category"": ""type"",
    ""desc"": ""indicates we want to search by instruction type""
  },
  {
    ""part"": ""<rcall>"",
    ""category"": ""argument"",
    ""desc"": ""specifies we want register call instructions""
  }
]
"
How can I see the disassembly of the 16 bytes at address 0x203040	pD 16 @ 0x203040	"
Looking at the question, we need to disassemble a specific number of bytes at a particular address. The key elements here are:
1. We want to see disassembly (not just hex dump)
2. We want exactly 16 bytes (not instructions)
3. We need to do this at a specific address (0x203040)

Looking through the commands, 'p' is our print command prefix, and since we want disassembly, we need 'D' (uppercase) which specifically disassembles bytes rather than instructions (which would be lowercase 'd'). The number specifies how many bytes, and the @ symbol allows us to specify the address where we want to perform this operation.
"	"
[
    {
        ""part"": ""p"",
        ""category"": ""print"",
        ""desc"": ""print command prefix for output operations""
    },
    {
        ""part"": ""D"",
        ""category"": ""disassembly"",
        ""desc"": ""specifically disassemble bytes (uppercase D for bytes, lowercase d would be for instructions)""
    },
    {
        ""part"": ""<16>"",
        ""category"": ""count"",
        ""desc"": ""number of bytes to disassemble""
    },
    {
        ""part"": ""@"",
        ""category"": ""address"",
        ""desc"": ""at symbol to specify where to perform the operation""
    },
    {
        ""part"": ""<0x203040>"",
        ""category"": ""address"",
        ""desc"": ""the specific address where to perform the disassembly""
    }
]
"
Recursively disassemble all the basic blocks of the function `sym.main`	pdr @ sym.main	"
When I need to analyze a function's control flow, I want to see all possible execution paths through its basic blocks. The question asks for recursive disassembly of sym.main, which means we need to follow all branches and show the disassembly of each basic block in a logical order.

First, we need to print (p) something. Since we want disassembly, we use 'd' for that. But we don't want linear disassembly - we want recursive disassembly that follows the function's control flow graph, so we add 'r' for recursive. Finally, we need to specify where to do this - at the main function, so we use @ to seek to sym.main.

This will give us a complete view of the function's execution paths by recursively traversing all basic blocks, making it much more useful than linear disassembly for understanding complex control flow.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""We start with print command as we want to output something""
  },
  {
    ""cmd"": ""d"",
    ""category"": ""disassembly"", 
    ""desc"": ""We want to see the disassembly of the code""
  },
  {
    ""cmd"": ""r"",
    ""category"": ""recursive"",
    ""desc"": ""Make the disassembly recursive - follow all branches and basic blocks""
  },
  {
    ""cmd"": ""@"",
    ""category"": ""seek"",
    ""desc"": ""Specify where to perform the operation""
  },
  {
    ""cmd"": ""<sym.main>"",
    ""category"": ""argument"",
    ""desc"": ""The target function to analyze""
  }
]
"
Show signature for all the functions in the program	afs @@F	"
I need to show function signatures for all functions in the program. This requires two parts:
1. A command to show function signatures (afs)
2. A way to apply it to all functions (@@F)

The command needs to work with function analysis first, then iterate through all functions. The @@ iterator is perfect for this as it allows running a command on multiple targets, and the F suffix specifically targets all functions.
"	"
[
  {
    ""part"": ""af"", 
    ""category"": ""analysis"",
    ""desc"": ""analyze function command group""
  },
  {
    ""part"": ""s"",
    ""category"": ""signatures"", 
    ""desc"": ""get/set function signature at current address""
  },
  {
    ""part"": ""@@"",
    ""category"": ""iterator"",
    ""desc"": ""run command on multiple targets""
  },
  {
    ""part"": ""F"",
    ""category"": ""functions"",
    ""desc"": ""apply to all functions in binary""
  }
]
"
How do I find all cross-references to `function_name`?	axt @ function_name	"
When working with functions, we often need to find all the places that call or reference a particular function. The question asks about cross-references, which are essentially references from one part of the code to another. In radare2, cross-references are managed with the 'ax' command family, and to find references TO something (rather than FROM something), we use 'axt'. The @ symbol is used to specify the address or name we want to analyze.

So to find all the places that reference a specific function, we need:
1. A command for cross-references
2. Specifically one that shows references TO a location
3. A way to specify the function name
"	"
[
    {
        ""part"": ""a"",
        ""category"": ""analysis"",
        ""desc"": ""analysis commands are used for code analysis""
    },
    {
        ""part"": ""x"",
        ""category"": ""xrefs"",
        ""desc"": ""handles cross-references in the code""
    },
    {
        ""part"": ""t"",
        ""category"": ""to"",
        ""desc"": ""specifically find references TO this address/function""
    },
    {
        ""part"": ""@"",
        ""category"": ""address"",
        ""desc"": ""specifies where to perform the operation""
    },
    {
        ""part"": ""<function_name>"",
        ""category"": ""argument"",
        ""desc"": ""the name of the function to find references to""
    }
]
"
Continue execution until `ret`	dcr	"
When debugging, we often want to continue execution until we hit a specific instruction type. In this case, we want to continue until we hit a return instruction (ret). This is particularly useful when stepping through function calls and wanting to continue until the function returns.

The command needs to combine debug continuation with a condition for the ret instruction. Looking at the debug commands (d), we need something that continues (dc) but with a specific condition - in this case until we hit a return.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""debug command prefix, since we're working with program execution""
  },
  {
    ""cmd"": ""c"",
    ""category"": ""continue"",
    ""desc"": ""continue execution, as we want the program to keep running""
  },
  {
    ""cmd"": ""r"",
    ""category"": ""return"",
    ""desc"": ""specifies to continue until a ret instruction is found""
  }
]
"
Considering the program counter is in library code, continue the execution until falling into program code	dcp	"
To handle this situation, we need a way to continue execution but stop when we get back to the program's own code rather than library code. We need the debugger (d) to continue (c) but specifically until we hit program (p) code. This makes sense because libraries are mapped differently than the main program's code sections, so we can distinguish between them.
"	"
[
  {
    ""part"": ""d"",
    ""category"": ""debug"",
    ""desc"": ""we need debugging commands since we're dealing with execution control""
  },
  {
    ""cmd"": ""c"",
    ""category"": ""continue"",
    ""desc"": ""continue execution rather than step""
  },
  {
    ""cmd"": ""p"",
    ""category"": ""program"",
    ""desc"": ""specifies to continue until we hit program code (non-library)""
  }
]
"
Resolve the syscall number for the `fork`	asl fork	"
Looking at the question, we need to find out the syscall number for the 'fork' system call. This is a common task when doing syscall analysis or debugging. The command should look up the syscall number in the current architecture's syscall table. The 'asl' command is specifically designed for this - it's part of the analysis ('a') commands, specifically for syscalls ('s'), and the 'l' indicates we want to lookup a specific syscall name.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used to extract information from the binary""
  },
  {
    ""part"": ""s"",
    ""category"": ""syscall"",
    ""desc"": ""specifies we're working with syscall-related analysis""
  },
  {
    ""part"": ""l"",
    ""category"": ""lookup"",
    ""desc"": ""indicates we want to lookup/list a specific syscall""
  },
  {
    ""part"": ""<fork>"",
    ""category"": ""argument"",
    ""desc"": ""the name of the syscall we want to lookup""
  }
]
"
What's the syscall number to perform `write`	asl write	"
To find the syscall number for 'write', we need to use the syscall list functionality. The question is asking for a specific syscall number lookup, and 'asl' is the command that lists syscalls and can convert between names and numbers. Since we're looking for the 'write' syscall specifically, we need to use 'asl' followed by the syscall name to get its number.
"	"
[
  {
    ""part"": ""a"",
    ""category"": ""analysis"",
    ""desc"": ""analysis commands are used for deep inspection of code""
  },
  {
    ""part"": ""s"",
    ""category"": ""syscall"",
    ""desc"": ""syscall-specific analysis commands""
  },
  {
    ""part"": ""l"",
    ""category"": ""list"",
    ""desc"": ""list operation to show syscall information""
  },
  {
    ""part"": ""<write>"",
    ""category"": ""argument"",
    ""desc"": ""the syscall name we want to look up""
  }
]
"
Copy 10 bytes from 0x1020 to 0x8090	wf 0x1020 10 @ 0x8090	"
We need to copy bytes from one location to another. This is essentially a memory copy operation. Looking at the command options, we need something that can write data at a specific address. The 'w' commands are for writing, and among those, 'wf' is specifically for writing from one location to another. The source address is 0x1020, we want 10 bytes, and we want to write them at 0x8090. The '@' syntax is used in radare2 to specify the destination address.
"	"
[
  {
    ""part"": ""w"",
    ""category"": ""write"",
    ""desc"": ""Write command - needed because we're writing data""
  },
  {
    ""part"": ""f"",
    ""category"": ""file/from"",
    ""desc"": ""Specifies we're writing FROM somewhere else in the file""
  },
  {
    ""part"": ""<0x1020>"",
    ""category"": ""arguments"",
    ""desc"": ""Source address to copy from""
  },
  {
    ""part"": ""<10>"",
    ""category"": ""arguments"",
    ""desc"": ""Number of bytes to copy""
  },
  {
    ""part"": ""@"",
    ""category"": ""address_specifier"",
    ""desc"": ""Tells radare2 where to perform the operation""
  },
  {
    ""part"": ""<0x8090>"",
    ""category"": ""arguments"",
    ""desc"": ""Destination address where to write the bytes""
  }
]
"
How do I view all the ELF sections?	iS	"
When dealing with ELF files, sections are fundamental parts of the binary structure that contain different types of data (like code, data, symbols, etc.). To view these, I need a command that deals with binary information (i commands) and specifically sections. The 'iS' command is perfect as it's designed to list sections and segments.
"	"
[
  {
    ""part"": ""i"",
    ""category"": ""information"",
    ""desc"": ""information command group - used for getting details about the loaded binary""
  },
  {
    ""part"": ""S"",
    ""category"": ""sections"",
    ""desc"": ""sections subcommand - specifically lists sections and segments of the binary""
  }
]
"
How do I view all the ELF segments?	iSS	"
When dealing with ELF files, we need to look at the binary information commands, which all start with 'i'. Since we specifically want to look at segments, which are a structural part of the ELF format, we need the section/segment related commands. Looking at the help, iS deals with sections, and iSS specifically lists memory segments, which is exactly what we need for ELF segments.
"	"
[
    {
        ""part"": ""i"",
        ""category"": ""information"",
        ""desc"": ""Binary information commands are accessed through i""
    },
    {
        ""part"": ""S"",
        ""category"": ""sections"",
        ""desc"": ""Section-related information, first S indicates we're working with section commands""
    },
    {
        ""part"": ""S"",
        ""category"": ""segments"",
        ""desc"": ""Second S specifies we want segments specifically instead of sections""
    }
]
"
"Assemble the instruction ""nop"" and show me the bytes"	'pa nop	"
To get the bytes for a NOP instruction, we need to convert assembly to hex bytes. We want to print/show the assembled form of ""nop"", so we need a command that takes assembly as input and gives us the raw bytes. The 'p' commands are for printing/showing data, and 'a' is commonly used for assembly-related operations. Looking at the help, 'pa' is exactly what we need - it prints the hex bytes that correspond to the given assembly instruction.
"	"
[
    {
        ""part"": ""p"",
        ""category"": ""print"",
        ""desc"": ""We want to show/print something""
    },
    {
        ""cmd"": ""a"",
        ""category"": ""assembly"",
        ""desc"": ""Assembly-specific printing operation - converts assembly to bytes""
    },
    {
        ""cmd"": ""<nop>"",
        ""category"": ""argument"",
        ""desc"": ""The assembly instruction we want to convert to bytes""
    }
]
"
"How can I assemble a ""ret"""	'pa ret	"
To assemble a single instruction, we need a command that converts assembly to bytes. Looking at the documentation, we need something that can print/assemble, and specifically handle assembly instructions. The 'p' commands are for printing, and looking through the options, 'pa' stands out as it's specifically for assembly operations. Since we want to assemble a single instruction (""ret""), this is exactly what we need - it will convert that instruction into its corresponding hex bytes.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command is the base for outputting data""
  },
  {
    ""part"": ""a"",
    ""category"": ""assembly"",
    ""desc"": ""assembly modifier tells print command to handle assembly operations""
  },
  {
    ""part"": ""<ret>"",
    ""category"": ""argument"",
    ""desc"": ""the actual instruction to be assembled into bytes""
  }
]
"
Disassemble the bytes 10203040 and show me the instruction	'pad 10203040	"
You want to disassemble some raw bytes given in hex format (10203040) and see what instruction they represent. This is a common reverse engineering task when looking at raw binary data and wanting to understand the machine code.

First, we need a command that can handle assembly/disassembly operations - that's where 'pa' comes in. The 'pad' variant specifically takes hex bytes as input and shows you the corresponding assembly instruction, which is exactly what we need here.
"	"
[
  {
    ""part"": ""p"",
    ""category"": ""print"",
    ""desc"": ""print command family, used for displaying data""
  },
  {
    ""part"": ""a"",
    ""category"": ""assembly"",
    ""desc"": ""assembly/disassembly operations""
  },
  {
    ""part"": ""d"",
    ""category"": ""disassembly"",
    ""desc"": ""specifies we want to disassemble hex bytes""
  },
  {
    ""part"": ""<10203040>"",
    ""category"": ""arguments"",
    ""desc"": ""the actual hex bytes we want to disassemble""
  }
]
"
Make this function return zero	wao ret0	"
When I want to modify an existing instruction to make it return a specific value, I need to use write assembly operations. Looking at the question, they want to make a function return zero, which means modifying the return instruction or adding one that returns 0. The wao command is specifically designed for these assembly operation modifications, and ret0 is the exact operation to make a function return 0.
"	"
[
  {
    ""part"": ""w"",
    ""category"": ""write"",
    ""desc"": ""We need to write/modify instructions""
  },
  {
    ""cmd"": ""a"",
    ""category"": ""assembly"",
    ""desc"": ""We're dealing with assembly-level modifications""
  },
  {
    ""cmd"": ""o"",
    ""category"": ""operation"",
    ""desc"": ""We want to perform an operation on the current instruction""
  },
  {
    ""cmd"": ""<ret0>"",
    ""category"": ""arguments"",
    ""desc"": ""The specific operation to make the function return 0""
  }
]
"
Write a return in the address 0x102030	wao ret @ 0x102030	"
Looking at this question, we need to modify an instruction at a specific address to make it a return instruction. This is an assembly operation modification task.

First, we need a way to write assembly ('w' command family). Since we're modifying an existing instruction, we need the assembly operation modification command ('wao'). The 'ret' parameter tells it to make the instruction a return.

The syntax requires specifying the target address after the @ symbol.
"	"
[
    {""part"": ""w"", ""category"": ""write"", ""desc"": ""We need to write to memory""},
    {""part"": ""a"", ""category"": ""assembly"", ""desc"": ""We're doing an assembly-level operation""},
    {""part"": ""o"", ""category"": ""operation"", ""desc"": ""Modify an existing operation rather than writing new bytes""},
    {""part"": ""<ret>"", ""category"": ""argument"", ""desc"": ""The instruction we want to write - a return instruction""},
    {""part"": ""@"", ""category"": ""addressing"", ""desc"": ""Specify where to perform the operation""},
    {""part"": ""<0x102030>"", ""category"": ""address"", ""desc"": ""The target address where we want to write the return""}
]
"
Force the function in the current address to return	wao ret	"
Looking at this question, we need to modify the behavior of a function at runtime to force it to return. This is a common debugging/analysis task where you want to skip the rest of a function's execution. Since we're modifying an opcode (instruction), we'll need to use write commands, specifically write-analysis-opcode commands that can understand and modify assembly instructions.

The command should modify the current instruction to make it a return instruction, effectively forcing the function to end at that point. This is an assembly-level operation that requires understanding of the current opcode and how to patch it.
"	"
[
  {
    ""part"": ""w"", 
    ""category"": ""write"",
    ""desc"": ""We need to write/modify something in memory""
  },
  {
    ""part"": ""a"",
    ""category"": ""assembly"",
    ""desc"": ""We're dealing with assembly level modifications""
  },
  {
    ""part"": ""o"",
    ""category"": ""opcode"",
    ""desc"": ""We want to modify an opcode/instruction""
  },
  {
    ""part"": ""<ret>"",
    ""category"": ""argument"",
    ""desc"": ""The specific operation we want - convert current instruction to return""
  }
]
"
"Echo the text ""hello world"""	'?e hello world	"
To echo text in radare2, we need a command that can print or display text to the console. Looking at the command set, the question mark (?) commands include utilities and helpers. The '?e' command is specifically designed for echoing text or messages, similar to 'echo' in shell scripting. The text ""hello world"" needs to be printed exactly as provided.
"	"
[
  {
    ""part"": ""?"",
    ""category"": ""help/util"",
    ""desc"": ""access utility commands""
  },
  {
    ""part"": ""e"",
    ""category"": ""echo"",
    ""desc"": ""echo text to console""
  },
  {
    ""part"": ""<hello world>"",
    ""category"": ""argument"",
    ""desc"": ""the literal text to be displayed""
  }
]
"
"Invoke clippy to show the text ""Hello world"""	'?E Hello world	"
You want to print some text in a special way. Looking at the command help, I see the '?' command is for evaluation and help commands. Within that, 'E' is specifically for echo-like operations that can print messages. The single quote at the start is a special prefix that tells r2 to not evaluate any special characters in the command, ensuring the text is printed exactly as written.

This is essentially r2's version of ""echo"" or ""print"", but with the ability to handle special characters safely through the single quote prefix.
"	"
[
  {""part"": ""'"", ""category"": ""prefix"", ""desc"": ""tells r2 to treat the following command literally, without evaluating special chars""},
  {""part"": ""?"", ""category"": ""evaluate"", ""desc"": ""access evaluation and help commands""},
  {""part"": ""E"", ""category"": ""echo"", ""desc"": ""print text to console""},
  {""part"": ""<Hello world>"", ""category"": ""argument"", ""desc"": ""the text to be displayed""}
]
"
What's the size of the file in human units (KB/MB/GB)?	rh	"
When dealing with file sizes, we often want to see them in human-readable format rather than raw bytes. The question asks specifically about human units like KB/MB/GB, which immediately makes me think of utilities like 'ls -h' in Unix. In radare2, since we're dealing with file operations, this would be under the resize/file size category, which uses the 'r' commands. Looking at the options, 'rh' stands out as it specifically mentions ""show size in human format"".
"	"
[
  {
    ""part"": ""r"",
    ""category"": ""resize"",
    ""desc"": ""resize/file operations command family""
  },
  {
    ""cmd"": ""h"",
    ""category"": ""format"",
    ""desc"": ""human-readable format modifier, similar to common Unix tools' -h flag""
  }
]
"
